{"status": "1", "message": "OK", "result": [{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Token Minter\r\n@author Curve Finance\r\n@license MIT\r\n\"\"\"\r\n\r\n# Original idea and credit:\r\n# Curve Finance's Token Minter\r\n# https://resources.curve.fi/base-features/understanding-gauges\r\n# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/Minter.vy\r\n# This contract is an almost-identical fork of Curve's contract\r\n\r\ninterface LiquidityGauge:\r\n    # Presumably, other gauges will provide the same interfaces\r\n    def integrate_fraction(addr: address) -> uint256: view\r\n    def user_checkpoint(addr: address) -> bool: nonpayable\r\n\r\ninterface MERC20:\r\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface GaugeController:\r\n    def gauge_types(addr: address) -> int128: view\r\n\r\n\r\nevent Minted:\r\n    recipient: indexed(address)\r\n    gauge: address\r\n    minted: uint256\r\n\r\n\r\ntoken: public(address)\r\ncontroller: public(address)\r\n\r\n# user -> gauge -> value\r\nminted: public(HashMap[address, HashMap[address, uint256]])\r\n\r\n# minter -> user -> can mint?\r\nallowed_to_mint_for: public(HashMap[address, HashMap[address, bool]])\r\n\r\n\r\n@external\r\ndef __init__(_token: address, _controller: address):\r\n    self.token = _token\r\n    self.controller = _controller\r\n\r\n\r\n@internal\r\ndef _mint_for(gauge_addr: address, _for: address):\r\n    assert GaugeController(self.controller).gauge_types(gauge_addr) >= 0  # dev: gauge is not added\r\n\r\n    LiquidityGauge(gauge_addr).user_checkpoint(_for)\r\n    total_mint: uint256 = LiquidityGauge(gauge_addr).integrate_fraction(_for)\r\n    to_mint: uint256 = total_mint - self.minted[_for][gauge_addr]\r\n\r\n    if to_mint != 0:\r\n        MERC20(self.token).mint(_for, to_mint)\r\n        self.minted[_for][gauge_addr] = total_mint\r\n\r\n        log Minted(_for, gauge_addr, total_mint)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint(gauge_addr: address):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` and send to them\r\n    @param gauge_addr `LiquidityGauge` address to get mintable amount from\r\n    \"\"\"\r\n    self._mint_for(gauge_addr, msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint_many(gauge_addrs: address[8]):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` across multiple gauges\r\n    @param gauge_addrs List of `LiquidityGauge` addresses\r\n    \"\"\"\r\n    for i in range(8):\r\n        if gauge_addrs[i] == ZERO_ADDRESS:\r\n            break\r\n        self._mint_for(gauge_addrs[i], msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint_for(gauge_addr: address, _for: address):\r\n    \"\"\"\r\n    @notice Mint tokens for `_for`\r\n    @dev Only possible when `msg.sender` has been approved via `toggle_approve_mint`\r\n    @param gauge_addr `LiquidityGauge` address to get mintable amount from\r\n    @param _for Address to mint to\r\n    \"\"\"\r\n    if self.allowed_to_mint_for[msg.sender][_for]:\r\n        self._mint_for(gauge_addr, _for)\r\n\r\n\r\n@external\r\ndef toggle_approve_mint(minting_user: address):\r\n    \"\"\"\r\n    @notice allow `minting_user` to mint for `msg.sender`\r\n    @param minting_user Address to toggle permission for\r\n    \"\"\"\r\n    self.allowed_to_mint_for[minting_user][msg.sender] = not self.allowed_to_mint_for[minting_user][msg.sender]", "ABI": "[{\"name\":\"Minted\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":false},{\"name\":\"minted\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_controller\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"gauge_addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":112442},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint_many\",\"inputs\":[{\"name\":\"gauge_addrs\",\"type\":\"address[8]\"}],\"outputs\":[],\"gas\":499092},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint_for\",\"inputs\":[{\"name\":\"gauge_addr\",\"type\":\"address\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[],\"gas\":115035},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_approve_mint\",\"inputs\":[{\"name\":\"minting_user\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38051},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2580},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2610},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3172},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_to_mint_for\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3202}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000072953a5c32413614d24c29c84a66ae4b59581bbf000000000000000000000000b992e8e1943f40f89301ab89a5c254f567af5b63", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}