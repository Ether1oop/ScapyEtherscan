{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BaseMath {\r\n    uint constant public DECIMAL_PRECISION = 1e18;\r\n}\r\n\r\n// taken from: https://github.com/liquity/dev/blob/8371355b2f11bee9fa599f9223f4c2f6f429351f/packages/contracts/contracts/Dependencies/LiquityMath.sol\r\ncontract ChickenMath is BaseMath {\r\n\r\n    /*\r\n     * Multiply two decimal numbers and use normal rounding rules:\r\n     * -round product up if 19'th mantissa digit >= 5\r\n     * -round product down if 19'th mantissa digit < 5\r\n     *\r\n     * Used only inside the exponentiation, decPow().\r\n     */\r\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return (x * y + DECIMAL_PRECISION / 2) / DECIMAL_PRECISION;\r\n    }\r\n\r\n    /*\r\n     * decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\r\n     *\r\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\r\n     *\r\n     * Called by ChickenBondManager.calcRedemptionFeePercentage, that represents time in units of minutes:\r\n     *\r\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\r\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\r\n     *\r\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\r\n     * negligibly different from just passing the cap, since:\r\n     * the decayed base rate will be 0 for 1000 years or > 1000 years\r\n     */\r\n    function decPow(uint256 _base, uint256 _exponent) internal pure returns (uint) {\r\n\r\n        if (_exponent > 525600000) {_exponent = 525600000;}  // cap to avoid overflow\r\n\r\n        if (_exponent == 0) {return DECIMAL_PRECISION;}\r\n\r\n        uint256 y = DECIMAL_PRECISION;\r\n        uint256 x = _base;\r\n        uint256 n = _exponent;\r\n\r\n        // Exponentiation-by-squaring\r\n        while (n > 1) {\r\n            if (n % 2 != 0) {\r\n                y = decMul(x, y);\r\n            }\r\n            x = decMul(x, x);\r\n            n = n / 2;\r\n        }\r\n\r\n        return decMul(x, y);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface ILUSDToken is IERC20 { \r\n    \r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n\r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\r\n\r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ninterface IBLUSDToken is IERC20 {\r\n    function mint(address _to, uint256 _bLUSDAmount) external;\r\n\r\n    function burn(address _from, uint256 _bLUSDAmount) external;\r\n}\r\n\r\ninterface ICurvePool is IERC20 { \r\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external returns (uint256 mint_amount);\r\n\r\n    function remove_liquidity(uint256 burn_amount, uint256[2] memory _min_amounts) external;\r\n\r\n    function remove_liquidity_one_coin(uint256 _burn_amount, int128 i, uint256 _min_received) external;\r\n\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address _receiver) external returns (uint256);\r\n\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address _receiver) external returns (uint256);\r\n\r\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\r\n\r\n    function calc_token_amount(uint256[2] memory _amounts, bool _is_deposit) external view returns (uint256);\r\n\r\n    function balances(uint256 arg0) external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function get_dy(int128 i,int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function get_dy_underlying(int128 i,int128 j, uint256 dx) external view returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function fee() external view returns (uint256);\r\n\r\n    function D() external returns (uint256);\r\n\r\n    function future_A_gamma_time() external returns (uint256);\r\n}\r\n\r\ninterface IYearnVault is IERC20 { \r\n    function deposit(uint256 _tokenAmount) external returns (uint256);\r\n\r\n    function withdraw(uint256 _tokenAmount) external returns (uint256);\r\n\r\n    function lastReport() external view returns (uint256);\r\n\r\n    function totalDebt() external view returns (uint256);\r\n\r\n    function calcTokenToYToken(uint256 _tokenAmount) external pure returns (uint256); \r\n\r\n    function token() external view returns (address);\r\n\r\n    function availableDepositLimit() external view returns (uint256);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function setDepositLimit(uint256 limit) external;\r\n\r\n    function withdrawalQueue(uint256) external returns (address);\r\n}\r\n\r\ninterface IBAMM {\r\n    function deposit(uint256 lusdAmount) external;\r\n\r\n    function withdraw(uint256 lusdAmount, address to) external;\r\n\r\n    function swap(uint lusdAmount, uint minEthReturn, address payable dest) external returns(uint);\r\n\r\n    function getSwapEthAmount(uint lusdQty) external view returns(uint ethAmount, uint feeLusdAmount);\r\n\r\n    function getLUSDValue() external view returns (uint256, uint256, uint256);\r\n\r\n    function setChicken(address _chicken) external;\r\n}\r\n\r\ninterface IChickenBondManager {\r\n    // Valid values for `status` returned by `getBondData()`\r\n    enum BondStatus {\r\n        nonExistent,\r\n        active,\r\n        chickenedOut,\r\n        chickenedIn\r\n    }\r\n\r\n    function lusdToken() external view returns (ILUSDToken);\r\n    function bLUSDToken() external view returns (IBLUSDToken);\r\n    function curvePool() external view returns (ICurvePool);\r\n    function bammSPVault() external view returns (IBAMM);\r\n    function yearnCurveVault() external view returns (IYearnVault);\r\n    // constants\r\n    function INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL() external pure returns (int128);\r\n\r\n    function createBond(uint256 _lusdAmount) external returns (uint256);\r\n    function createBondWithPermit(\r\n        address owner, \r\n        uint256 amount, \r\n        uint256 deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external  returns (uint256);\r\n    function chickenOut(uint256 _bondID, uint256 _minLUSD) external;\r\n    function chickenIn(uint256 _bondID) external;\r\n    function redeem(uint256 _bLUSDToRedeem, uint256 _minLUSDFromBAMMSPVault) external returns (uint256, uint256);\r\n\r\n    // getters\r\n    function calcRedemptionFeePercentage(uint256 _fractionOfBLUSDToRedeem) external view returns (uint256);\r\n    function getBondData(uint256 _bondID) external view returns (uint256 lusdAmount, uint64 claimedBLUSD, uint64 startTime, uint64 endTime, uint8 status);\r\n    function getLUSDToAcquire(uint256 _bondID) external view returns (uint256);\r\n    function calcAccruedBLUSD(uint256 _bondID) external view returns (uint256);\r\n    function calcBondBLUSDCap(uint256 _bondID) external view returns (uint256);\r\n    function getLUSDInBAMMSPVault() external view returns (uint256);\r\n    function calcTotalYearnCurveVaultShareValue() external view returns (uint256);\r\n    function calcTotalLUSDValue() external view returns (uint256);\r\n    function getPendingLUSD() external view returns (uint256);\r\n    function getAcquiredLUSDInSP() external view returns (uint256);\r\n    function getAcquiredLUSDInCurve() external view returns (uint256);\r\n    function getTotalAcquiredLUSD() external view returns (uint256);\r\n    function getPermanentLUSD() external view returns (uint256);\r\n    function getOwnedLUSDInSP() external view returns (uint256);\r\n    function getOwnedLUSDInCurve() external view returns (uint256);\r\n    function calcSystemBackingRatio() external view returns (uint256);\r\n    function calcUpdatedAccrualParameter() external view returns (uint256);\r\n    function getBAMMLUSDDebt() external view returns (uint256);\r\n}\r\n\r\ninterface IBondNFT is IERC721Enumerable {\r\n    struct BondExtraData {\r\n        uint80 initialHalfDna;\r\n        uint80 finalHalfDna;\r\n        uint32 troveSize;         // Debt in LUSD\r\n        uint32 lqtyAmount;        // Holding LQTY, staking or deposited into Pickle\r\n        uint32 curveGaugeSlopes;  // For 3CRV and Frax pools combined\r\n    }\r\n\r\n    function mint(address _bonder, uint256 _permanentSeed) external returns (uint256, uint80);\r\n    function setFinalExtraData(address _bonder, uint256 _tokenID, uint256 _permanentSeed) external returns (uint80);\r\n    function chickenBondManager() external view returns (IChickenBondManager);\r\n    function getBondAmount(uint256 _tokenID) external view returns (uint256 amount);\r\n    function getBondStartTime(uint256 _tokenID) external view returns (uint256 startTime);\r\n    function getBondEndTime(uint256 _tokenID) external view returns (uint256 endTime);\r\n    function getBondInitialHalfDna(uint256 _tokenID) external view returns (uint80 initialHalfDna);\r\n    function getBondInitialDna(uint256 _tokenID) external view returns (uint256 initialDna);\r\n    function getBondFinalHalfDna(uint256 _tokenID) external view returns (uint80 finalHalfDna);\r\n    function getBondFinalDna(uint256 _tokenID) external view returns (uint256 finalDna);\r\n    function getBondStatus(uint256 _tokenID) external view returns (uint8 status);\r\n    function getBondExtraData(uint256 _tokenID) external view returns (uint80 initialHalfDna, uint80 finalHalfDna, uint32 troveSize, uint32 lqtyAmount, uint32 curveGaugeSlopes);\r\n}\r\n\r\ninterface IYearnRegistry {\r\n    function latestVault(address _tokenAddress) external returns (address);\r\n}\r\n\r\ninterface ICurveLiquidityGaugeV5 is IERC20 {\r\n    // Public state getters\r\n\r\n    function reward_data(address _reward_token) external returns (\r\n        address token,\r\n        address distributor,\r\n        uint256 period_finish,\r\n        uint256 rate,\r\n        uint256 last_update,\r\n        uint256 integral\r\n    );\r\n\r\n    // User-facing functions\r\n\r\n    function deposit(uint256 _value) external;\r\n    function deposit(uint256 _value, address _addr) external;\r\n    function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\r\n\r\n    function withdraw(uint256 _value) external;\r\n    function withdraw(uint256 _value, bool _claim_rewards) external;\r\n\r\n    function claim_rewards() external;\r\n    function claim_rewards(address _addr) external;\r\n    function claim_rewards(address _addr, address _receiver) external;\r\n\r\n    function user_checkpoint(address addr) external returns (bool);\r\n    function set_rewards_receiver(address _receiver) external;\r\n    function kick(address addr) external;\r\n\r\n    // Admin functions\r\n\r\n    function deposit_reward_token(address _reward_token, uint256 _amount) external;\r\n    function add_reward(address _reward_token, address _distributor) external;\r\n    function set_reward_distributor(address _reward_token, address _distributor) external;\r\n    function set_killed(bool _is_killed) external;\r\n\r\n    // View methods\r\n\r\n    function claimed_reward(address _addr, address _token) external view returns (uint256);\r\n    function claimable_reward(address _user, address _reward_token) external view returns (uint256);\r\n    function claimable_tokens(address addr) external view returns (uint256);\r\n\r\n    function integrate_checkpoint() external view returns (uint256);\r\n    function future_epoch_time() external view returns (uint256);\r\n    function inflation_rate() external view returns (uint256);\r\n\r\n    function version() external view returns (string memory);\r\n}\r\n\r\n// import \"forge-std/console.sol\";\r\n\r\ncontract ChickenBondManager is ChickenMath, IChickenBondManager {\r\n\r\n    // ChickenBonds contracts and addresses\r\n    IBondNFT immutable public bondNFT;\r\n\r\n    IBLUSDToken immutable public bLUSDToken;\r\n    ILUSDToken immutable public lusdToken;\r\n\r\n    // External contracts and addresses\r\n    ICurvePool immutable public curvePool; // LUSD meta-pool (i.e. coin 0 is LUSD, coin 1 is LP token from a base pool)\r\n    ICurvePool immutable public curveBasePool; // base pool of curvePool\r\n    IBAMM immutable public bammSPVault; // B.Protocol Stability Pool vault\r\n    IYearnVault immutable public yearnCurveVault;\r\n    IYearnRegistry immutable public yearnRegistry;\r\n    ICurveLiquidityGaugeV5 immutable public curveLiquidityGauge;\r\n\r\n    address immutable public yearnGovernanceAddress;\r\n\r\n    uint256 immutable public CHICKEN_IN_AMM_FEE;\r\n\r\n    uint256 private pendingLUSD;          // Total pending LUSD. It will always be in SP (B.Protocol)\r\n    uint256 private permanentLUSD;        // Total permanent LUSD\r\n    uint256 private bammLUSDDebt;         // Amount \u201cowed\u201d by B.Protocol to ChickenBonds, equals deposits - withdrawals + rewards\r\n    uint256 public yTokensHeldByCBM;      // Computed balance of Y-tokens of LUSD-3CRV vault owned by this contract\r\n                                          // (to prevent certain attacks where attacker increases the balance and thus the backing ratio)\r\n\r\n    // --- Data structures ---\r\n\r\n    struct ExternalAdresses {\r\n        address bondNFTAddress;\r\n        address lusdTokenAddress;\r\n        address curvePoolAddress;\r\n        address curveBasePoolAddress;\r\n        address bammSPVaultAddress;\r\n        address yearnCurveVaultAddress;\r\n        address yearnRegistryAddress;\r\n        address yearnGovernanceAddress;\r\n        address bLUSDTokenAddress;\r\n        address curveLiquidityGaugeAddress;\r\n    }\r\n\r\n    struct Params {\r\n        uint256 targetAverageAgeSeconds;        // Average outstanding bond age above which the controller will adjust `accrualParameter` in order to speed up accrual\r\n        uint256 initialAccrualParameter;        // Initial value for `accrualParameter`\r\n        uint256 minimumAccrualParameter;        // Stop adjusting `accrualParameter` when this value is reached\r\n        uint256 accrualAdjustmentRate;          // `accrualParameter` is multiplied `1 - accrualAdjustmentRate` every time there's an adjustment\r\n        uint256 accrualAdjustmentPeriodSeconds; // The duration of an adjustment period in seconds\r\n        uint256 chickenInAMMFee;                // Fraction of bonded amount that is sent to Curve Liquidity Gauge to incentivize LUSD-bLUSD liquidity\r\n        uint256 curveDepositDydxThreshold;      // Threshold of SP => Curve shifting\r\n        uint256 curveWithdrawalDxdyThreshold;   // Threshold of Curve => SP shifting\r\n        uint256 bootstrapPeriodChickenIn;       // Min duration of first chicken-in\r\n        uint256 bootstrapPeriodRedeem;          // Redemption lock period after first chicken in\r\n        uint256 bootstrapPeriodShift;           // Period after launch during which shifter functions are disabled\r\n        uint256 shifterDelay;                   // Duration of shifter countdown\r\n        uint256 shifterWindow;                  // Interval in which shifting is possible after countdown finishes\r\n        uint256 minBLUSDSupply;                 // Minimum amount of bLUSD supply that must remain after a redemption\r\n        uint256 minBondAmount;                  // Minimum amount of LUSD that needs to be bonded\r\n        uint256 nftRandomnessDivisor;           // Divisor for permanent LUSD amount in NFT pseudo-randomness computation (see comment below)\r\n        uint256 redemptionFeeBeta;              // Parameter by which to divide the redeemed fraction, in order to calculate the new base rate from a redemption\r\n        uint256 redemptionFeeMinuteDecayFactor; // Factor by which redemption fee decays (exponentially) every minute\r\n    }\r\n\r\n    struct BondData {\r\n        uint256 lusdAmount;\r\n        uint64 claimedBLUSD; // In BLUSD units without decimals\r\n        uint64 startTime;\r\n        uint64 endTime; // Timestamp of chicken in/out event\r\n        BondStatus status;\r\n    }\r\n\r\n    uint256 public firstChickenInTime; // Timestamp of the first chicken in after bLUSD supply is zero\r\n    uint256 public totalWeightedStartTimes; // Sum of `lusdAmount * startTime` for all outstanding bonds (used to tell weighted average bond age)\r\n    uint256 public lastRedemptionTime; // The timestamp of the latest redemption\r\n    uint256 public baseRedemptionRate; // The latest base redemption rate\r\n    mapping (uint256 => BondData) private idToBondData;\r\n\r\n    /* migration: flag which determines whether the system is in migration mode.\r\n\r\n    When migration mode has been triggered:\r\n\r\n    - No funds are held in the permanent bucket. Liquidity is either pending, or acquired\r\n    - Bond creation and public shifter functions are disabled\r\n    - Users with an existing bond may still chicken in or out\r\n    - Chicken-ins will no longer send the LUSD surplus to the permanent bucket. Instead, they refund the surplus to the bonder\r\n    - bLUSD holders may still redeem\r\n    - Redemption fees are zero\r\n    */\r\n    bool public migration;\r\n\r\n    uint256 public countChickenIn;\r\n    uint256 public countChickenOut;\r\n\r\n    // --- Constants ---\r\n\r\n    uint256 constant MAX_UINT256 = type(uint256).max;\r\n    int128 public constant INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL = 0;\r\n    int128 constant INDEX_OF_3CRV_TOKEN_IN_CURVE_POOL = 1;\r\n\r\n    uint256 constant public SECONDS_IN_ONE_MINUTE = 60;\r\n\r\n    uint256 public immutable BOOTSTRAP_PERIOD_CHICKEN_IN; // Min duration of first chicken-in\r\n    uint256 public immutable BOOTSTRAP_PERIOD_REDEEM;     // Redemption lock period after first chicken in\r\n    uint256 public immutable BOOTSTRAP_PERIOD_SHIFT;      // Period after launch during which shifter functions are disabled\r\n\r\n    uint256 public immutable SHIFTER_DELAY;               // Duration of shifter countdown\r\n    uint256 public immutable SHIFTER_WINDOW;              // Interval in which shifting is possible after countdown finishes\r\n\r\n    uint256 public immutable MIN_BLUSD_SUPPLY;            // Minimum amount of bLUSD supply that must remain after a redemption\r\n    uint256 public immutable MIN_BOND_AMOUNT;             // Minimum amount of LUSD that needs to be bonded\r\n    // This is the minimum amount the permanent bucket needs to be increased by an attacker (through previous chicken in or redemption fee),\r\n    // in order to manipulate the obtained NFT. If the attacker finds the desired outcome at attempt N,\r\n    // the permanent increase should be N * NFT_RANDOMNESS_DIVISOR.\r\n    // It also means that as long as Permanent doesn\u2019t change in that order of magnitude, attacker can try to manipulate\r\n    // only changing the event date.\r\n    uint256 public immutable NFT_RANDOMNESS_DIVISOR;\r\n\r\n    /*\r\n     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\r\n     * Corresponds to (1 / ALPHA) in the Liquity white paper.\r\n     */\r\n    uint256 public immutable BETA;\r\n    uint256 public immutable MINUTE_DECAY_FACTOR;\r\n\r\n    uint256 constant CURVE_FEE_DENOMINATOR = 1e10;\r\n\r\n    // Thresholds of SP <=> Curve shifting\r\n    uint256 public immutable curveDepositLUSD3CRVExchangeRateThreshold;\r\n    uint256 public immutable curveWithdrawal3CRVLUSDExchangeRateThreshold;\r\n\r\n    // Timestamp at which the last shifter countdown started\r\n    uint256 public lastShifterCountdownStartTime;\r\n\r\n    // --- Accrual control variables ---\r\n\r\n    // `block.timestamp` of the block in which this contract was deployed.\r\n    uint256 public immutable deploymentTimestamp;\r\n\r\n    // Average outstanding bond age above which the controller will adjust `accrualParameter` in order to speed up accrual.\r\n    uint256 public immutable targetAverageAgeSeconds;\r\n\r\n    // Stop adjusting `accrualParameter` when this value is reached.\r\n    uint256 public immutable minimumAccrualParameter;\r\n\r\n    // Number between 0 and 1. `accrualParameter` is multiplied by this every time there's an adjustment.\r\n    uint256 public immutable accrualAdjustmentMultiplier;\r\n\r\n    // The duration of an adjustment period in seconds. The controller performs at most one adjustment per every period.\r\n    uint256 public immutable accrualAdjustmentPeriodSeconds;\r\n\r\n    // The number of seconds it takes to accrue 50% of the cap, represented as an 18 digit fixed-point number.\r\n    uint256 public accrualParameter;\r\n\r\n    // Counts the number of adjustment periods since deployment.\r\n    // Updated by operations that change the average outstanding bond age (createBond, chickenIn, chickenOut).\r\n    // Used by `_calcUpdatedAccrualParameter` to tell whether it's time to perform adjustments, and if so, how many times\r\n    // (in case the time elapsed since the last adjustment is more than one adjustment period).\r\n    uint256 public accrualAdjustmentPeriodCount;\r\n\r\n    // --- Events ---\r\n\r\n    event BaseRedemptionRateUpdated(uint256 _baseRedemptionRate);\r\n    event LastRedemptionTimeUpdated(uint256 _lastRedemptionFeeOpTime);\r\n    event BondCreated(address indexed bonder, uint256 bondId, uint256 amount, uint80 bondInitialHalfDna);\r\n    event BondClaimed(\r\n        address indexed bonder,\r\n        uint256 bondId,\r\n        uint256 lusdAmount,\r\n        uint256 bLusdAmount,\r\n        uint256 lusdSurplus,\r\n        uint256 chickenInFeeAmount,\r\n        bool migration,\r\n        uint80 bondFinalHalfDna\r\n    );\r\n    event BondCancelled(address indexed bonder, uint256 bondId, uint256 principalLusdAmount, uint256 minLusdAmount, uint256 withdrawnLusdAmount, uint80 bondFinalHalfDna);\r\n    event BLUSDRedeemed(address indexed redeemer, uint256 bLusdAmount, uint256 minLusdAmount, uint256 lusdAmount, uint256 yTokens, uint256 redemptionFee);\r\n    event MigrationTriggered(uint256 previousPermanentLUSD);\r\n    event AccrualParameterUpdated(uint256 accrualParameter);\r\n\r\n    // --- Constructor ---\r\n\r\n    constructor\r\n    (\r\n        ExternalAdresses memory _externalContractAddresses, // to avoid stack too deep issues\r\n        Params memory _params\r\n    )\r\n    {\r\n        bondNFT = IBondNFT(_externalContractAddresses.bondNFTAddress);\r\n        lusdToken = ILUSDToken(_externalContractAddresses.lusdTokenAddress);\r\n        bLUSDToken = IBLUSDToken(_externalContractAddresses.bLUSDTokenAddress);\r\n        curvePool = ICurvePool(_externalContractAddresses.curvePoolAddress);\r\n        curveBasePool = ICurvePool(_externalContractAddresses.curveBasePoolAddress);\r\n        bammSPVault = IBAMM(_externalContractAddresses.bammSPVaultAddress);\r\n        yearnCurveVault = IYearnVault(_externalContractAddresses.yearnCurveVaultAddress);\r\n        yearnRegistry = IYearnRegistry(_externalContractAddresses.yearnRegistryAddress);\r\n        yearnGovernanceAddress = _externalContractAddresses.yearnGovernanceAddress;\r\n\r\n        deploymentTimestamp = block.timestamp;\r\n        targetAverageAgeSeconds = _params.targetAverageAgeSeconds;\r\n        accrualParameter = _params.initialAccrualParameter;\r\n        minimumAccrualParameter = _params.minimumAccrualParameter;\r\n        require(minimumAccrualParameter > 0, \"CBM: Min accrual parameter cannot be zero\");\r\n        accrualAdjustmentMultiplier = 1e18 - _params.accrualAdjustmentRate;\r\n        accrualAdjustmentPeriodSeconds = _params.accrualAdjustmentPeriodSeconds;\r\n\r\n        curveLiquidityGauge = ICurveLiquidityGaugeV5(_externalContractAddresses.curveLiquidityGaugeAddress);\r\n        CHICKEN_IN_AMM_FEE = _params.chickenInAMMFee;\r\n\r\n        uint256 fee = curvePool.fee(); // This is practically immutable (can only be set once, in `initialize()`)\r\n\r\n        // By exchange rate, we mean the rate at which Curve exchanges LUSD <=> $ value of 3CRV (at the virtual price),\r\n        // which is reduced by the fee.\r\n        // For convenience, we want to parameterize our thresholds in terms of the spot prices -dy/dx & -dx/dy,\r\n        // which are not exposed by Curve directly. Instead, we turn our thresholds into thresholds on the exchange rate\r\n        // by taking into account the fee.\r\n        curveDepositLUSD3CRVExchangeRateThreshold =\r\n            _params.curveDepositDydxThreshold * (CURVE_FEE_DENOMINATOR - fee) / CURVE_FEE_DENOMINATOR;\r\n        curveWithdrawal3CRVLUSDExchangeRateThreshold =\r\n            _params.curveWithdrawalDxdyThreshold * (CURVE_FEE_DENOMINATOR - fee) / CURVE_FEE_DENOMINATOR;\r\n\r\n        BOOTSTRAP_PERIOD_CHICKEN_IN = _params.bootstrapPeriodChickenIn;\r\n        BOOTSTRAP_PERIOD_REDEEM = _params.bootstrapPeriodRedeem;\r\n        BOOTSTRAP_PERIOD_SHIFT = _params.bootstrapPeriodShift;\r\n        SHIFTER_DELAY = _params.shifterDelay;\r\n        SHIFTER_WINDOW = _params.shifterWindow;\r\n        MIN_BLUSD_SUPPLY = _params.minBLUSDSupply;\r\n        require(_params.minBondAmount > 0, \"CBM: MIN BOND AMOUNT parameter cannot be zero\"); // We can still use 1e-18\r\n        MIN_BOND_AMOUNT = _params.minBondAmount;\r\n        NFT_RANDOMNESS_DIVISOR = _params.nftRandomnessDivisor;\r\n        BETA = _params.redemptionFeeBeta;\r\n        MINUTE_DECAY_FACTOR = _params.redemptionFeeMinuteDecayFactor;\r\n\r\n        // TODO: Decide between one-time infinite LUSD approval to Yearn and Curve (lower gas cost per user tx, less secure\r\n        // or limited approval at each bonder action (higher gas cost per user tx, more secure)\r\n        lusdToken.approve(address(bammSPVault), MAX_UINT256);\r\n        lusdToken.approve(address(curvePool), MAX_UINT256);\r\n        curvePool.approve(address(yearnCurveVault), MAX_UINT256);\r\n        lusdToken.approve(address(curveLiquidityGauge), MAX_UINT256);\r\n\r\n        // Check that the system is hooked up to the correct latest Yearn vault\r\n        assert(address(yearnCurveVault) == yearnRegistry.latestVault(address(curvePool)));\r\n    }\r\n\r\n    // --- User-facing functions ---\r\n\r\n    function createBond(uint256 _lusdAmount) public returns (uint256) {\r\n        _requireMinBond(_lusdAmount);\r\n        _requireMigrationNotActive();\r\n\r\n        _updateAccrualParameter();\r\n\r\n        // Mint the bond NFT to the caller and get the bond ID\r\n        (uint256 bondID, uint80 initialHalfDna) = bondNFT.mint(msg.sender, permanentLUSD / NFT_RANDOMNESS_DIVISOR);\r\n\r\n        //Record the user\u2019s bond data: bond_amount and start_time\r\n        BondData memory bondData;\r\n        bondData.lusdAmount = _lusdAmount;\r\n        bondData.startTime = uint64(block.timestamp);\r\n        bondData.status = BondStatus.active;\r\n        idToBondData[bondID] = bondData;\r\n\r\n        pendingLUSD += _lusdAmount;\r\n        totalWeightedStartTimes += _lusdAmount * block.timestamp;\r\n\r\n        lusdToken.transferFrom(msg.sender, address(this), _lusdAmount);\r\n\r\n        // Deposit the LUSD to the B.Protocol LUSD vault\r\n        _depositToBAMM(_lusdAmount);\r\n\r\n        emit BondCreated(msg.sender, bondID, _lusdAmount, initialHalfDna);\r\n\r\n        return bondID;\r\n    }\r\n\r\n    function createBondWithPermit(\r\n        address owner, \r\n        uint256 amount, \r\n        uint256 deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external returns (uint256) {\r\n        // LCB-10: don't call permit if the user already has the required amount permitted\r\n        if (lusdToken.allowance(owner, address(this)) < amount) {\r\n            lusdToken.permit(owner, address(this), amount, deadline, v, r, s);\r\n        }\r\n        return createBond(amount);\r\n    }\r\n\r\n    function chickenOut(uint256 _bondID, uint256 _minLUSD) external {\r\n        BondData memory bond = idToBondData[_bondID];\r\n\r\n        _requireCallerOwnsBond(_bondID);\r\n        _requireActiveStatus(bond.status);\r\n\r\n        _updateAccrualParameter();\r\n\r\n        idToBondData[_bondID].status = BondStatus.chickenedOut;\r\n        idToBondData[_bondID].endTime = uint64(block.timestamp);\r\n        uint80 newDna = bondNFT.setFinalExtraData(msg.sender, _bondID, permanentLUSD / NFT_RANDOMNESS_DIVISOR);\r\n\r\n        countChickenOut += 1;\r\n\r\n        pendingLUSD -= bond.lusdAmount;\r\n        totalWeightedStartTimes -= bond.lusdAmount * bond.startTime;\r\n\r\n        /* In practice, there could be edge cases where the pendingLUSD is not fully backed:\r\n        * - Heavy liquidations, and before yield has been converted\r\n        * - Heavy loss-making liquidations, i.e. at <100% CR\r\n        * - SP or B.Protocol vault hack that drains LUSD\r\n        *\r\n        * The user can decide how to handle chickenOuts if/when the recorded pendingLUSD is not fully backed by actual\r\n        * LUSD in B.Protocol / the SP, by adjusting _minLUSD */\r\n        uint256 lusdToWithdraw = _requireEnoughLUSDInBAMM(bond.lusdAmount, _minLUSD);\r\n\r\n        // Withdraw from B.Protocol LUSD vault\r\n        _withdrawFromBAMM(lusdToWithdraw, msg.sender);\r\n\r\n        emit BondCancelled(msg.sender, _bondID, bond.lusdAmount, _minLUSD, lusdToWithdraw, newDna);\r\n    }\r\n\r\n    // transfer _lusdToTransfer to the LUSD/bLUSD AMM LP Rewards staking contract\r\n    function _transferToRewardsStakingContract(uint256 _lusdToTransfer) internal {\r\n        uint256 lusdBalanceBefore = lusdToken.balanceOf(address(this));\r\n        curveLiquidityGauge.deposit_reward_token(address(lusdToken), _lusdToTransfer);\r\n\r\n        assert(lusdBalanceBefore - lusdToken.balanceOf(address(this)) == _lusdToTransfer);\r\n    }\r\n\r\n    function _withdrawFromSPVaultAndTransferToRewardsStakingContract(uint256 _lusdAmount) internal {\r\n        // Pull the LUSD amount from B.Protocol LUSD vault\r\n        _withdrawFromBAMM(_lusdAmount, address(this));\r\n\r\n        // Deposit in rewards contract\r\n        _transferToRewardsStakingContract(_lusdAmount);\r\n    }\r\n\r\n    /* Divert acquired yield to LUSD/bLUSD AMM LP rewards staking contract\r\n     * It happens on the very first chicken in event of the system, or any time that redemptions deplete bLUSD total supply to zero\r\n     * Assumption: When there have been no chicken ins since the bLUSD supply was set to 0 (either due to system deployment, or full bLUSD redemption),\r\n     * all acquired LUSD must necessarily be pure yield.\r\n     */\r\n    function _firstChickenIn(uint256 _bondStartTime, uint256 _bammLUSDValue, uint256 _lusdInBAMMSPVault) internal returns (uint256) {\r\n        //assert(!migration); // we leave it as a comment so we can uncomment it for automated testing tools\r\n\r\n        require(block.timestamp >= _bondStartTime + BOOTSTRAP_PERIOD_CHICKEN_IN, \"CBM: First chicken in must wait until bootstrap period is over\");\r\n        firstChickenInTime = block.timestamp;\r\n\r\n        (\r\n            uint256 acquiredLUSDInSP,\r\n            /* uint256 acquiredLUSDInCurve */,\r\n            /* uint256 ownedLUSDInSP */,\r\n            /* uint256 ownedLUSDInCurve */,\r\n            /* uint256 permanentLUSDCached */\r\n        ) = _getLUSDSplit(_bammLUSDValue);\r\n\r\n        // Make sure that LUSD available in B.Protocol is at least as much as acquired\r\n        // If first chicken in happens after an scenario of heavy liquidations and before ETH has been sold by B.Protocol\r\n        // so that there\u2019s not enough LUSD available in B.Protocol to transfer all the acquired bucket to the staking contract,\r\n        // the system would start with a backing ratio greater than 1\r\n        require(_lusdInBAMMSPVault >= acquiredLUSDInSP, \"CBM: Not enough LUSD available in B.Protocol\");\r\n\r\n        // From SP Vault\r\n        if (acquiredLUSDInSP > 0) {\r\n            _withdrawFromSPVaultAndTransferToRewardsStakingContract(acquiredLUSDInSP);\r\n        }\r\n\r\n        return _lusdInBAMMSPVault - acquiredLUSDInSP;\r\n    }\r\n\r\n    function chickenIn(uint256 _bondID) external {\r\n        BondData memory bond = idToBondData[_bondID];\r\n\r\n        _requireCallerOwnsBond(_bondID);\r\n        _requireActiveStatus(bond.status);\r\n\r\n        uint256 updatedAccrualParameter = _updateAccrualParameter();\r\n        (uint256 bammLUSDValue, uint256 lusdInBAMMSPVault) = _updateBAMMDebt();\r\n\r\n        (uint256 chickenInFeeAmount, uint256 bondAmountMinusChickenInFee) = _getBondWithChickenInFeeApplied(bond.lusdAmount);\r\n\r\n        /* Upon the first chicken-in after a) system deployment or b) redemption of the full bLUSD supply, divert\r\n        * any earned yield to the bLUSD-LUSD AMM for fairness.\r\n        *\r\n        * This is not done in migration mode since there is no need to send rewards to the staking contract.\r\n        */\r\n        if (bLUSDToken.totalSupply() == 0 && !migration) {\r\n            lusdInBAMMSPVault = _firstChickenIn(bond.startTime, bammLUSDValue, lusdInBAMMSPVault);\r\n        }\r\n\r\n        // Get the LUSD amount to acquire from the bond in proportion to the system's current backing ratio, in order to maintain said ratio.\r\n        uint256 lusdToAcquire = _calcAccruedAmount(bond.startTime, bondAmountMinusChickenInFee, updatedAccrualParameter);\r\n        // Get backing ratio and accrued bLUSD\r\n        uint256 backingRatio = _calcSystemBackingRatioFromBAMMValue(bammLUSDValue);\r\n        uint256 accruedBLUSD = lusdToAcquire * 1e18 / backingRatio;\r\n\r\n        idToBondData[_bondID].claimedBLUSD = uint64(Math.min(accruedBLUSD / 1e18, type(uint64).max)); // to units and uint64\r\n        idToBondData[_bondID].status = BondStatus.chickenedIn;\r\n        idToBondData[_bondID].endTime = uint64(block.timestamp);\r\n        uint80 newDna = bondNFT.setFinalExtraData(msg.sender, _bondID, permanentLUSD / NFT_RANDOMNESS_DIVISOR);\r\n\r\n        countChickenIn += 1;\r\n\r\n        // Subtract the bonded amount from the total pending LUSD (and implicitly increase the total acquired LUSD)\r\n        pendingLUSD -= bond.lusdAmount;\r\n        totalWeightedStartTimes -= bond.lusdAmount * bond.startTime;\r\n\r\n        // Get the remaining surplus from the LUSD amount to acquire from the bond\r\n        uint256 lusdSurplus = bondAmountMinusChickenInFee - lusdToAcquire;\r\n\r\n        // Handle the surplus LUSD from the chicken-in:\r\n        if (!migration) { // In normal mode, add the surplus to the permanent bucket by increasing the permament tracker. This implicitly decreases the acquired LUSD.\r\n            permanentLUSD += lusdSurplus;\r\n        } else { // In migration mode, withdraw surplus from B.Protocol and refund to bonder\r\n            // TODO: should we allow to pass in a minimum value here too?\r\n            (,lusdInBAMMSPVault,) = bammSPVault.getLUSDValue();\r\n            uint256 lusdToRefund = Math.min(lusdSurplus, lusdInBAMMSPVault);\r\n            if (lusdToRefund > 0) { _withdrawFromBAMM(lusdToRefund, msg.sender); }\r\n        }\r\n\r\n        bLUSDToken.mint(msg.sender, accruedBLUSD);\r\n\r\n        // Transfer the chicken in fee to the LUSD/bLUSD AMM LP Rewards staking contract during normal mode.\r\n        if (!migration && lusdInBAMMSPVault >= chickenInFeeAmount) {\r\n            _withdrawFromSPVaultAndTransferToRewardsStakingContract(chickenInFeeAmount);\r\n        }\r\n\r\n        emit BondClaimed(msg.sender, _bondID, bond.lusdAmount, accruedBLUSD, lusdSurplus, chickenInFeeAmount, migration, newDna);\r\n    }\r\n\r\n    function redeem(uint256 _bLUSDToRedeem, uint256 _minLUSDFromBAMMSPVault) external returns (uint256, uint256) {\r\n        _requireNonZeroAmount(_bLUSDToRedeem);\r\n        _requireRedemptionNotDepletingbLUSD(_bLUSDToRedeem);\r\n\r\n        require(block.timestamp >= firstChickenInTime + BOOTSTRAP_PERIOD_REDEEM, \"CBM: Redemption after first chicken in must wait until bootstrap period is over\");\r\n\r\n        (\r\n            uint256 acquiredLUSDInSP,\r\n            uint256 acquiredLUSDInCurve,\r\n            /* uint256 ownedLUSDInSP */,\r\n            uint256 ownedLUSDInCurve,\r\n            uint256 permanentLUSDCached\r\n        ) = _getLUSDSplitAfterUpdatingBAMMDebt();\r\n\r\n        uint256 fractionOfBLUSDToRedeem = _bLUSDToRedeem * 1e18 / bLUSDToken.totalSupply();\r\n        // Calculate redemption fee. No fee in migration mode.\r\n        uint256 redemptionFeePercentage = migration ? 0 : _updateRedemptionFeePercentage(fractionOfBLUSDToRedeem);\r\n        // Will collect redemption fees from both buckets (in LUSD).\r\n        uint256 redemptionFeeLUSD;\r\n\r\n        // TODO: Both _requireEnoughLUSDInBAMM and _updateBAMMDebt call B.Protocol getLUSDValue, so it may be optmized\r\n        // Calculate the LUSD to withdraw from LUSD vault, withdraw and send to redeemer. Move the fee to the permanent bucket.\r\n        uint256 lusdToWithdrawFromSP;\r\n        { // Block scoping to avoid stack too deep issues\r\n            uint256 acquiredLUSDInSPToRedeem = acquiredLUSDInSP * fractionOfBLUSDToRedeem / 1e18;\r\n            uint256 acquiredLUSDInSPToWithdraw = acquiredLUSDInSPToRedeem * (1e18 - redemptionFeePercentage) / 1e18;\r\n            redemptionFeeLUSD += acquiredLUSDInSPToRedeem - acquiredLUSDInSPToWithdraw;\r\n            lusdToWithdrawFromSP = _requireEnoughLUSDInBAMM(acquiredLUSDInSPToWithdraw, _minLUSDFromBAMMSPVault);\r\n            if (lusdToWithdrawFromSP > 0) { _withdrawFromBAMM(lusdToWithdrawFromSP, msg.sender); }\r\n        }\r\n\r\n        // Send yTokens to the redeemer according to the proportion of owned LUSD in Curve that's being redeemed\r\n        uint256 yTokensFromCurveVault;\r\n        if (ownedLUSDInCurve > 0) {\r\n            uint256 acquiredLUSDInCurveToRedeem = acquiredLUSDInCurve * fractionOfBLUSDToRedeem / 1e18;\r\n            uint256 lusdToWithdrawFromCurve = acquiredLUSDInCurveToRedeem * (1e18 - redemptionFeePercentage) / 1e18;\r\n            redemptionFeeLUSD += acquiredLUSDInCurveToRedeem - lusdToWithdrawFromCurve;\r\n            yTokensFromCurveVault = yTokensHeldByCBM * lusdToWithdrawFromCurve / ownedLUSDInCurve;\r\n            if (yTokensFromCurveVault > 0) { _transferFromCurve(msg.sender, yTokensFromCurveVault); }\r\n        }\r\n\r\n        // Move the fee to permanent. This implicitly removes it from the acquired bucket\r\n        permanentLUSD = permanentLUSDCached + redemptionFeeLUSD;\r\n\r\n        _requireNonZeroAmount(lusdToWithdrawFromSP + yTokensFromCurveVault);\r\n\r\n        // Burn the redeemed bLUSD\r\n        bLUSDToken.burn(msg.sender, _bLUSDToRedeem);\r\n\r\n        emit BLUSDRedeemed(msg.sender, _bLUSDToRedeem, _minLUSDFromBAMMSPVault, lusdToWithdrawFromSP, yTokensFromCurveVault, redemptionFeeLUSD);\r\n\r\n        return (lusdToWithdrawFromSP, yTokensFromCurveVault);\r\n    }\r\n\r\n    function shiftLUSDFromSPToCurve(uint256 _maxLUSDToShift) external {\r\n        _requireShiftBootstrapPeriodEnded();\r\n        _requireMigrationNotActive();\r\n        _requireNonZeroBLUSDSupply();\r\n        _requireShiftWindowIsOpen();\r\n\r\n        (uint256 bammLUSDValue, uint256 lusdInBAMMSPVault) = _updateBAMMDebt();\r\n        uint256 lusdOwnedInBAMMSPVault = bammLUSDValue - pendingLUSD;\r\n\r\n        uint256 totalLUSDInCurve = getTotalLUSDInCurve();\r\n        // it can happen due to profits from shifts or rounding errors:\r\n        _requirePermanentGreaterThanCurve(totalLUSDInCurve);\r\n\r\n        // Make sure pending bucket is not moved to Curve, so it can be withdrawn on chicken out\r\n        uint256 clampedLUSDToShift = Math.min(_maxLUSDToShift, lusdOwnedInBAMMSPVault);\r\n\r\n        // Make sure there\u2019s enough LUSD available in B.Protocol\r\n        clampedLUSDToShift = Math.min(clampedLUSDToShift, lusdInBAMMSPVault);\r\n\r\n        // Make sure we don\u2019t make Curve bucket greater than Permanent one with the shift\r\n        // subtraction is safe per _requirePermanentGreaterThanCurve above\r\n        clampedLUSDToShift = Math.min(clampedLUSDToShift, permanentLUSD - totalLUSDInCurve);\r\n\r\n        _requireNonZeroAmount(clampedLUSDToShift);\r\n\r\n        // Get the 3CRV virtual price only once, and use it for both initial and final check.\r\n        // Adding LUSD liquidity to the meta-pool does not change 3CRV virtual price.\r\n        uint256 _3crvVirtualPrice = curveBasePool.get_virtual_price();\r\n        uint256 initialExchangeRate = _getLUSD3CRVExchangeRate(_3crvVirtualPrice);\r\n\r\n        require(\r\n            initialExchangeRate > curveDepositLUSD3CRVExchangeRateThreshold,\r\n            \"CBM: LUSD:3CRV exchange rate must be over the deposit threshold before SP->Curve shift\"\r\n        );\r\n\r\n        // Withdram LUSD from B.Protocol\r\n        _withdrawFromBAMM(clampedLUSDToShift, address(this));\r\n\r\n        // Deposit the received LUSD to Curve in return for LUSD3CRV-f tokens\r\n        uint256 lusd3CRVBalanceBefore = curvePool.balanceOf(address(this));\r\n        /* TODO: Determine if we should pass a minimum amount of LP tokens to receive here. Seems infeasible to determinine the mininum on-chain from\r\n        * Curve spot price / quantities, which are manipulable. */\r\n        curvePool.add_liquidity([clampedLUSDToShift, 0], 0);\r\n        uint256 lusd3CRVBalanceDelta = curvePool.balanceOf(address(this)) - lusd3CRVBalanceBefore;\r\n\r\n        // Deposit the received LUSD3CRV-f to Yearn Curve vault\r\n        _depositToCurve(lusd3CRVBalanceDelta);\r\n\r\n        // Do price check: ensure the SP->Curve shift has decreased the LUSD:3CRV exchange rate, but not into unprofitable territory\r\n        uint256 finalExchangeRate = _getLUSD3CRVExchangeRate(_3crvVirtualPrice);\r\n\r\n        require(\r\n            finalExchangeRate < initialExchangeRate &&\r\n            finalExchangeRate >= curveDepositLUSD3CRVExchangeRateThreshold,\r\n            \"CBM: SP->Curve shift must decrease LUSD:3CRV exchange rate to a value above the deposit threshold\"\r\n        );\r\n    }\r\n\r\n    function shiftLUSDFromCurveToSP(uint256 _maxLUSDToShift) external {\r\n        _requireShiftBootstrapPeriodEnded();\r\n        _requireMigrationNotActive();\r\n        _requireNonZeroBLUSDSupply();\r\n        _requireShiftWindowIsOpen();\r\n\r\n        // We can\u2019t shift more than what\u2019s in Curve\r\n        uint256 ownedLUSDInCurve = getTotalLUSDInCurve();\r\n        uint256 clampedLUSDToShift = Math.min(_maxLUSDToShift, ownedLUSDInCurve);\r\n        _requireNonZeroAmount(clampedLUSDToShift);\r\n\r\n        // Get the 3CRV virtual price only once, and use it for both initial and final check.\r\n        // Removing LUSD liquidity from the meta-pool does not change 3CRV virtual price.\r\n        uint256 _3crvVirtualPrice = curveBasePool.get_virtual_price();\r\n        uint256 initialExchangeRate = _get3CRVLUSDExchangeRate(_3crvVirtualPrice);\r\n\r\n        // Here we're using the 3CRV:LUSD exchange rate (with 3CRV being valued at its virtual price),\r\n        // which increases as LUSD price decreases, hence the direction of the inequality.\r\n        require(\r\n            initialExchangeRate > curveWithdrawal3CRVLUSDExchangeRateThreshold,\r\n            \"CBM: 3CRV:LUSD exchange rate must be above the withdrawal threshold before Curve->SP shift\"\r\n        );\r\n\r\n        // Convert yTokens to LUSD3CRV-f\r\n        uint256 lusd3CRVBalanceBefore = curvePool.balanceOf(address(this));\r\n\r\n        // ownedLUSDInCurve > 0 implied by _requireNonZeroAmount(clampedLUSDToShift)\r\n        uint256 yTokensToBurnFromCurveVault = yTokensHeldByCBM * clampedLUSDToShift / ownedLUSDInCurve;\r\n        _withdrawFromCurve(yTokensToBurnFromCurveVault);\r\n        uint256 lusd3CRVBalanceDelta = curvePool.balanceOf(address(this)) - lusd3CRVBalanceBefore;\r\n\r\n        // Withdraw LUSD from Curve\r\n        uint256 lusdBalanceBefore = lusdToken.balanceOf(address(this));\r\n        /* TODO: Determine if we should pass a minimum amount of LUSD to receive here. Seems infeasible to determinine the mininum on-chain from\r\n        * Curve spot price / quantities, which are manipulable. */\r\n        curvePool.remove_liquidity_one_coin(lusd3CRVBalanceDelta, INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL, 0);\r\n        uint256 lusdBalanceDelta = lusdToken.balanceOf(address(this)) - lusdBalanceBefore;\r\n\r\n        // Assertion should hold in principle. In practice, there is usually minor rounding error\r\n        // assert(lusdBalanceDelta == _lusdToShift);\r\n\r\n        // Deposit the received LUSD to B.Protocol LUSD vault\r\n        _depositToBAMM(lusdBalanceDelta);\r\n\r\n        // Ensure the Curve->SP shift has decreased the 3CRV:LUSD exchange rate, but not into unprofitable territory\r\n        uint256 finalExchangeRate = _get3CRVLUSDExchangeRate(_3crvVirtualPrice);\r\n\r\n        require(\r\n            finalExchangeRate < initialExchangeRate &&\r\n            finalExchangeRate >= curveWithdrawal3CRVLUSDExchangeRateThreshold,\r\n            \"CBM: Curve->SP shift must increase 3CRV:LUSD exchange rate to a value above the withdrawal threshold\"\r\n        );\r\n    }\r\n\r\n    // --- B.Protocol debt functions ---\r\n\r\n    // If the actual balance of B.Protocol is higher than our internal accounting,\r\n    // it means that B.Protocol has had gains (through sell of ETH or LQTY).\r\n    // We account for those gains\r\n    // If the balance was lower (which would mean losses), we expect them to be eventually recovered\r\n    function _getInternalBAMMLUSDValue() internal view returns (uint256) {\r\n        (, uint256 lusdInBAMMSPVault,) = bammSPVault.getLUSDValue();\r\n\r\n        return Math.max(bammLUSDDebt, lusdInBAMMSPVault);\r\n    }\r\n\r\n    // TODO: Should we make this one publicly callable, so that external getters can be up to date (by previously calling this)?\r\n    // Returns the value updated\r\n    function _updateBAMMDebt() internal returns (uint256, uint256) {\r\n        (, uint256 lusdInBAMMSPVault,) = bammSPVault.getLUSDValue();\r\n        uint256 bammLUSDDebtCached = bammLUSDDebt;\r\n\r\n        // If the actual balance of B.Protocol is higher than our internal accounting,\r\n        // it means that B.Protocol has had gains (through sell of ETH or LQTY).\r\n        // We account for those gains\r\n        // If the balance was lower (which would mean losses), we expect them to be eventually recovered\r\n        if (lusdInBAMMSPVault > bammLUSDDebtCached) {\r\n            bammLUSDDebt = lusdInBAMMSPVault;\r\n            return (lusdInBAMMSPVault, lusdInBAMMSPVault);\r\n        }\r\n\r\n        return (bammLUSDDebtCached, lusdInBAMMSPVault);\r\n    }\r\n\r\n    function _depositToBAMM(uint256 _lusdAmount) internal {\r\n        bammSPVault.deposit(_lusdAmount);\r\n        bammLUSDDebt += _lusdAmount;\r\n    }\r\n\r\n    function _withdrawFromBAMM(uint256 _lusdAmount, address _to) internal {\r\n        bammSPVault.withdraw(_lusdAmount, _to);\r\n        bammLUSDDebt -= _lusdAmount;\r\n    }\r\n\r\n    // @dev make sure this wrappers are always used instead of calling yearnCurveVault functions directyl,\r\n    // otherwise the internal accounting would fail\r\n    function _depositToCurve(uint256 _lusd3CRV) internal {\r\n        uint256 yTokensBalanceBefore = yearnCurveVault.balanceOf(address(this));\r\n        yearnCurveVault.deposit(_lusd3CRV);\r\n        uint256 yTokensBalanceDelta = yearnCurveVault.balanceOf(address(this)) - yTokensBalanceBefore;\r\n        yTokensHeldByCBM += yTokensBalanceDelta;\r\n    }\r\n\r\n    function _withdrawFromCurve(uint256 _yTokensToSwap) internal {\r\n        yearnCurveVault.withdraw(_yTokensToSwap);\r\n        yTokensHeldByCBM -= _yTokensToSwap;\r\n    }\r\n\r\n    function _transferFromCurve(address _to, uint256 _yTokensToTransfer) internal {\r\n        yearnCurveVault.transfer(_to, _yTokensToTransfer);\r\n        yTokensHeldByCBM -= _yTokensToTransfer;\r\n    }\r\n\r\n    // --- Migration functionality ---\r\n\r\n    /* Migration function callable one-time and only by Yearn governance.\r\n    * Moves all permanent LUSD in Curve to the Curve acquired bucket.\r\n    */\r\n    function activateMigration() external {\r\n        _requireCallerIsYearnGovernance();\r\n        _requireMigrationNotActive();\r\n\r\n        migration = true;\r\n\r\n        emit MigrationTriggered(permanentLUSD);\r\n\r\n        // Zero the permament LUSD tracker. This implicitly makes all permament liquidity acquired (and redeemable)\r\n        permanentLUSD = 0;\r\n    }\r\n\r\n    // --- Shifter countdown starter ---\r\n\r\n    function startShifterCountdown() public {\r\n        // First check that the previous delay and shifting window have passed\r\n        require(block.timestamp >= lastShifterCountdownStartTime + SHIFTER_DELAY + SHIFTER_WINDOW, \"CBM: Previous shift delay and window must have passed\");\r\n\r\n        // Begin the new countdown from now\r\n        lastShifterCountdownStartTime = block.timestamp;\r\n    }\r\n\r\n    // --- Fee share ---\r\n\r\n    function sendFeeShare(uint256 _lusdAmount) external {\r\n        _requireCallerIsYearnGovernance();\r\n        require(!migration, \"CBM: Receive fee share only in normal mode\");\r\n\r\n        // Move LUSD from caller to CBM and deposit to B.Protocol LUSD Vault\r\n        lusdToken.transferFrom(yearnGovernanceAddress, address(this), _lusdAmount);\r\n        _depositToBAMM(_lusdAmount);\r\n    }\r\n\r\n    // --- Helper functions ---\r\n\r\n    function _getLUSD3CRVExchangeRate(uint256 _3crvVirtualPrice) internal view returns (uint256) {\r\n        // Get the amount of 3CRV that would be received by swapping 1 LUSD (after deduction of fees)\r\n        // If p_{LUSD:3CRV} is the price of LUSD quoted in 3CRV, then this returns p_{LUSD:3CRV} * (1 - fee)\r\n        // as long as the pool is large enough so that 1 LUSD doesn't introduce significant slippage.\r\n        uint256 dy = curvePool.get_dy(INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL, INDEX_OF_3CRV_TOKEN_IN_CURVE_POOL, 1e18);\r\n\r\n        return dy * _3crvVirtualPrice / 1e18;\r\n    }\r\n\r\n    function _get3CRVLUSDExchangeRate(uint256 _3crvVirtualPrice) internal view returns (uint256) {\r\n        // Get the amount of LUSD that would be received by swapping 1 3CRV (after deduction of fees)\r\n        // If p_{3CRV:LUSD} is the price of 3CRV quoted in LUSD, then this returns p_{3CRV:LUSD} * (1 - fee)\r\n        // as long as the pool is large enough so that 1 3CRV doesn't introduce significant slippage.\r\n        uint256 dy = curvePool.get_dy(INDEX_OF_3CRV_TOKEN_IN_CURVE_POOL, INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL, 1e18);\r\n\r\n        return dy * 1e18 / _3crvVirtualPrice;\r\n    }\r\n\r\n    // Calc decayed redemption rate\r\n    function calcRedemptionFeePercentage(uint256 _fractionOfBLUSDToRedeem) public view returns (uint256) {\r\n        uint256 minutesPassed = _minutesPassedSinceLastRedemption();\r\n        uint256 decayFactor = decPow(MINUTE_DECAY_FACTOR, minutesPassed);\r\n\r\n        uint256 decayedBaseRedemptionRate = baseRedemptionRate * decayFactor / DECIMAL_PRECISION;\r\n\r\n        // Increase redemption base rate with the new redeemed amount\r\n        uint256 newBaseRedemptionRate = decayedBaseRedemptionRate + _fractionOfBLUSDToRedeem / BETA;\r\n        newBaseRedemptionRate = Math.min(newBaseRedemptionRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%\r\n        //assert(newBaseRedemptionRate <= DECIMAL_PRECISION); // This is already enforced in the line above\r\n\r\n        return newBaseRedemptionRate;\r\n    }\r\n\r\n    // Update the base redemption rate and the last redemption time (only if time passed >= decay interval. This prevents base rate griefing)\r\n    function _updateRedemptionFeePercentage(uint256 _fractionOfBLUSDToRedeem) internal returns (uint256) {\r\n        uint256 newBaseRedemptionRate = calcRedemptionFeePercentage(_fractionOfBLUSDToRedeem);\r\n        baseRedemptionRate = newBaseRedemptionRate;\r\n        emit BaseRedemptionRateUpdated(newBaseRedemptionRate);\r\n\r\n        uint256 timePassed = block.timestamp - lastRedemptionTime;\r\n\r\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\r\n            lastRedemptionTime = block.timestamp;\r\n            emit LastRedemptionTimeUpdated(block.timestamp);\r\n        }\r\n\r\n        return newBaseRedemptionRate;\r\n    }\r\n\r\n    function _minutesPassedSinceLastRedemption() internal view returns (uint256) {\r\n        return (block.timestamp - lastRedemptionTime) / SECONDS_IN_ONE_MINUTE;\r\n    }\r\n\r\n    function _getBondWithChickenInFeeApplied(uint256 _bondLUSDAmount) internal view returns (uint256, uint256) {\r\n        // Apply zero fee in migration mode\r\n        if (migration) {return (0, _bondLUSDAmount);}\r\n\r\n        // Otherwise, apply the constant fee rate\r\n        uint256 chickenInFeeAmount = _bondLUSDAmount * CHICKEN_IN_AMM_FEE / 1e18;\r\n        uint256 bondAmountMinusChickenInFee = _bondLUSDAmount - chickenInFeeAmount;\r\n\r\n        return (chickenInFeeAmount, bondAmountMinusChickenInFee);\r\n    }\r\n\r\n    function _getBondAmountMinusChickenInFee(uint256 _bondLUSDAmount) internal view returns (uint256) {\r\n        (, uint256 bondAmountMinusChickenInFee) = _getBondWithChickenInFeeApplied(_bondLUSDAmount);\r\n        return bondAmountMinusChickenInFee;\r\n    }\r\n\r\n    /* _calcAccruedAmount: internal getter for calculating accrued token amount for a given bond.\r\n    *\r\n    * This function is unit-agnostic. It can be used to calculate a bonder's accrrued bLUSD, or the LUSD that that the\r\n    * CB system would acquire (i.e. receive to the acquired bucket) if the bond were Chickened In now.\r\n    *\r\n    * For the bonder, _capAmount is their bLUSD cap.\r\n    * For the CB system, _capAmount is the LUSD bond amount (less the Chicken In fee).\r\n    */\r\n    function _calcAccruedAmount(uint256 _startTime, uint256 _capAmount, uint256 _accrualParameter) internal view returns (uint256) {\r\n        // All bonds have a non-zero creation timestamp, so return accrued sLQTY 0 if the startTime is 0\r\n        if (_startTime == 0) {return 0;}\r\n\r\n        // Scale `bondDuration` up to an 18 digit fixed-point number.\r\n        // This lets us add it to `accrualParameter`, which is also an 18-digit FP.\r\n        uint256 bondDuration = 1e18 * (block.timestamp - _startTime);\r\n\r\n        uint256 accruedAmount = _capAmount * bondDuration / (bondDuration + _accrualParameter);\r\n        //assert(accruedAmount < _capAmount); // we leave it as a comment so we can uncomment it for automated testing tools\r\n\r\n        return accruedAmount;\r\n    }\r\n\r\n    // Gauge the average (size-weighted) outstanding bond age and adjust accrual parameter if it's higher than our target.\r\n    // If there's been more than one adjustment period since the last adjustment, perform multiple adjustments retroactively.\r\n    function _calcUpdatedAccrualParameter(\r\n        uint256 _storedAccrualParameter,\r\n        uint256 _storedAccrualAdjustmentCount\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 updatedAccrualParameter,\r\n            uint256 updatedAccrualAdjustmentPeriodCount\r\n        )\r\n    {\r\n        updatedAccrualAdjustmentPeriodCount = (block.timestamp - deploymentTimestamp) / accrualAdjustmentPeriodSeconds;\r\n\r\n        if (\r\n            // There hasn't been enough time since the last update to warrant another update\r\n            updatedAccrualAdjustmentPeriodCount == _storedAccrualAdjustmentCount ||\r\n            // or `accrualParameter` is already bottomed-out\r\n            _storedAccrualParameter == minimumAccrualParameter ||\r\n            // or there are no outstanding bonds (avoid division by zero)\r\n            pendingLUSD == 0\r\n        ) {\r\n            return (_storedAccrualParameter, updatedAccrualAdjustmentPeriodCount);\r\n        }\r\n\r\n        uint256 averageStartTime = totalWeightedStartTimes / pendingLUSD;\r\n\r\n        // We want to calculate the period when the average age will have reached or exceeded the\r\n        // target average age, to be used later in a check against the actual current period.\r\n        //\r\n        // At any given timestamp `t`, the average age can be calculated as:\r\n        //   averageAge(t) = t - averageStartTime\r\n        //\r\n        // For any period `n`, the average age is evaluated at the following timestamp:\r\n        //   tSample(n) = deploymentTimestamp + n * accrualAdjustmentPeriodSeconds\r\n        //\r\n        // Hence we're looking for the smallest integer `n` such that:\r\n        //   averageAge(tSample(n)) >= targetAverageAgeSeconds\r\n        //\r\n        // If `n` is the smallest integer for which the above inequality stands, then:\r\n        //   averageAge(tSample(n - 1)) < targetAverageAgeSeconds\r\n        //\r\n        // Combining the two inequalities:\r\n        //   averageAge(tSample(n - 1)) < targetAverageAgeSeconds <= averageAge(tSample(n))\r\n        //\r\n        // Substituting and rearranging:\r\n        //   1.    deploymentTimestamp + (n - 1) * accrualAdjustmentPeriodSeconds - averageStartTime\r\n        //       < targetAverageAgeSeconds\r\n        //      <= deploymentTimestamp + n * accrualAdjustmentPeriodSeconds - averageStartTime\r\n        //\r\n        //   2.    (n - 1) * accrualAdjustmentPeriodSeconds\r\n        //       < averageStartTime + targetAverageAgeSeconds - deploymentTimestamp\r\n        //      <= n * accrualAdjustmentPeriodSeconds\r\n        //\r\n        //   3. n - 1 < (averageStartTime + targetAverageAgeSeconds - deploymentTimestamp) / accrualAdjustmentPeriodSeconds <= n\r\n        //\r\n        // Using equivalence `n = ceil(x) <=> n - 1 < x <= n` we arrive at:\r\n        //   n = ceil((averageStartTime + targetAverageAgeSeconds - deploymentTimestamp) / accrualAdjustmentPeriodSeconds)\r\n        //\r\n        // We can calculate `ceil(a / b)` using `Math.ceilDiv(a, b)`.\r\n        uint256 adjustmentPeriodCountWhenTargetIsExceeded = Math.ceilDiv(\r\n            averageStartTime + targetAverageAgeSeconds - deploymentTimestamp,\r\n            accrualAdjustmentPeriodSeconds\r\n        );\r\n\r\n        if (updatedAccrualAdjustmentPeriodCount < adjustmentPeriodCountWhenTargetIsExceeded) {\r\n            // No adjustment needed; target average age hasn't been exceeded yet\r\n            return (_storedAccrualParameter, updatedAccrualAdjustmentPeriodCount);\r\n        }\r\n\r\n        uint256 numberOfAdjustments = updatedAccrualAdjustmentPeriodCount - Math.max(\r\n            _storedAccrualAdjustmentCount,\r\n            adjustmentPeriodCountWhenTargetIsExceeded - 1\r\n        );\r\n\r\n        updatedAccrualParameter = Math.max(\r\n            _storedAccrualParameter * decPow(accrualAdjustmentMultiplier, numberOfAdjustments) / 1e18,\r\n            minimumAccrualParameter\r\n        );\r\n    }\r\n\r\n    function _updateAccrualParameter() internal returns (uint256) {\r\n        uint256 storedAccrualParameter = accrualParameter;\r\n        uint256 storedAccrualAdjustmentPeriodCount = accrualAdjustmentPeriodCount;\r\n\r\n        (uint256 updatedAccrualParameter, uint256 updatedAccrualAdjustmentPeriodCount) =\r\n            _calcUpdatedAccrualParameter(storedAccrualParameter, storedAccrualAdjustmentPeriodCount);\r\n\r\n        if (updatedAccrualAdjustmentPeriodCount != storedAccrualAdjustmentPeriodCount) {\r\n            accrualAdjustmentPeriodCount = updatedAccrualAdjustmentPeriodCount;\r\n\r\n            if (updatedAccrualParameter != storedAccrualParameter) {\r\n                accrualParameter = updatedAccrualParameter;\r\n                emit AccrualParameterUpdated(updatedAccrualParameter);\r\n            }\r\n        }\r\n\r\n        return updatedAccrualParameter;\r\n    }\r\n\r\n    // Internal getter for calculating the bond bLUSD cap based on bonded amount and backing ratio\r\n    function _calcBondBLUSDCap(uint256 _bondedAmount, uint256 _backingRatio) internal pure returns (uint256) {\r\n        // TODO: potentially refactor this -  i.e. have a (1 / backingRatio) function for more precision\r\n        return _bondedAmount * 1e18 / _backingRatio;\r\n    }\r\n\r\n    // --- 'require' functions\r\n\r\n    function _requireCallerOwnsBond(uint256 _bondID) internal view {\r\n        require(msg.sender == bondNFT.ownerOf(_bondID), \"CBM: Caller must own the bond\");\r\n    }\r\n\r\n    function _requireActiveStatus(BondStatus status) internal pure {\r\n        require(status == BondStatus.active, \"CBM: Bond must be active\");\r\n    }\r\n\r\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\r\n        require(_amount > 0, \"CBM: Amount must be > 0\");\r\n    }\r\n\r\n    function _requireNonZeroBLUSDSupply() internal view {\r\n        require(bLUSDToken.totalSupply() > 0, \"CBM: bLUSD Supply must be > 0 upon shifting\");\r\n    }\r\n\r\n    function _requireMinBond(uint256 _lusdAmount) internal view {\r\n        require(_lusdAmount >= MIN_BOND_AMOUNT, \"CBM: Bond minimum amount not reached\");\r\n    }\r\n\r\n    function _requireRedemptionNotDepletingbLUSD(uint256 _bLUSDToRedeem) internal view {\r\n        if (!migration) {\r\n            //require(_bLUSDToRedeem < bLUSDTotalSupply, \"CBM: Cannot redeem total supply\");\r\n            require(_bLUSDToRedeem + MIN_BLUSD_SUPPLY <= bLUSDToken.totalSupply(), \"CBM: Cannot redeem below min supply\");\r\n        }\r\n    }\r\n\r\n    function _requireMigrationNotActive() internal view {\r\n        require(!migration, \"CBM: Migration must be not be active\");\r\n    }\r\n\r\n    function _requireCallerIsYearnGovernance() internal view {\r\n        require(msg.sender == yearnGovernanceAddress, \"CBM: Only Yearn Governance can call\");\r\n    }\r\n\r\n    function _requireEnoughLUSDInBAMM(uint256 _requestedLUSD, uint256 _minLUSD) internal view returns (uint256) {\r\n        require(_requestedLUSD >= _minLUSD, \"CBM: Min value cannot be greater than nominal amount\");\r\n\r\n        (, uint256 lusdInBAMMSPVault,) = bammSPVault.getLUSDValue();\r\n        require(lusdInBAMMSPVault >= _minLUSD, \"CBM: Not enough LUSD available in B.Protocol\");\r\n\r\n        uint256 lusdToWithdraw = Math.min(_requestedLUSD, lusdInBAMMSPVault);\r\n\r\n        return lusdToWithdraw;\r\n    }\r\n\r\n    function _requireShiftBootstrapPeriodEnded() internal view {\r\n        require(block.timestamp - deploymentTimestamp >= BOOTSTRAP_PERIOD_SHIFT, \"CBM: Shifter only callable after shift bootstrap period ends\");\r\n    }\r\n\r\n    function _requireShiftWindowIsOpen() internal view {\r\n        uint256 shiftWindowStartTime = lastShifterCountdownStartTime + SHIFTER_DELAY;\r\n        uint256 shiftWindowFinishTime = shiftWindowStartTime + SHIFTER_WINDOW;\r\n\r\n        require(block.timestamp >= shiftWindowStartTime && block.timestamp < shiftWindowFinishTime, \"CBM: Shift only possible inside shifting window\");\r\n    }\r\n\r\n    function _requirePermanentGreaterThanCurve(uint256 _totalLUSDInCurve) internal view {\r\n        require(permanentLUSD >= _totalLUSDInCurve, \"CBM: The amount in Curve cannot be greater than the Permanent bucket\");\r\n    }\r\n\r\n    // --- Getter convenience functions ---\r\n\r\n    // Bond getters\r\n\r\n    function getBondData(uint256 _bondID)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 lusdAmount,\r\n            uint64 claimedBLUSD,\r\n            uint64 startTime,\r\n            uint64 endTime,\r\n            uint8 status\r\n        )\r\n    {\r\n        BondData memory bond = idToBondData[_bondID];\r\n        return (bond.lusdAmount, bond.claimedBLUSD, bond.startTime, bond.endTime, uint8(bond.status));\r\n    }\r\n\r\n    function getLUSDToAcquire(uint256 _bondID) external view returns (uint256) {\r\n        BondData memory bond = idToBondData[_bondID];\r\n\r\n        (uint256 updatedAccrualParameter, ) = _calcUpdatedAccrualParameter(accrualParameter, accrualAdjustmentPeriodCount);\r\n\r\n        return _calcAccruedAmount(bond.startTime, _getBondAmountMinusChickenInFee(bond.lusdAmount), updatedAccrualParameter);\r\n    }\r\n\r\n    function calcAccruedBLUSD(uint256 _bondID) external view returns (uint256) {\r\n        BondData memory bond = idToBondData[_bondID];\r\n\r\n        if (bond.status != BondStatus.active) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 bondBLUSDCap = _calcBondBLUSDCap(_getBondAmountMinusChickenInFee(bond.lusdAmount), calcSystemBackingRatio());\r\n\r\n        (uint256 updatedAccrualParameter, ) = _calcUpdatedAccrualParameter(accrualParameter, accrualAdjustmentPeriodCount);\r\n\r\n        return _calcAccruedAmount(bond.startTime, bondBLUSDCap, updatedAccrualParameter);\r\n    }\r\n\r\n    function calcBondBLUSDCap(uint256 _bondID) external view returns (uint256) {\r\n        uint256 backingRatio = calcSystemBackingRatio();\r\n\r\n        BondData memory bond = idToBondData[_bondID];\r\n\r\n        return _calcBondBLUSDCap(_getBondAmountMinusChickenInFee(bond.lusdAmount), backingRatio);\r\n    }\r\n\r\n    function getLUSDInBAMMSPVault() external view returns (uint256) {\r\n        (, uint256 lusdInBAMMSPVault,) = bammSPVault.getLUSDValue();\r\n\r\n        return lusdInBAMMSPVault;\r\n    }\r\n\r\n    // Native vault token value getters\r\n\r\n    // Calculates the LUSD3CRV value of LUSD Curve Vault yTokens held by the ChickenBondManager\r\n    function calcTotalYearnCurveVaultShareValue() public view returns (uint256) {\r\n        return yTokensHeldByCBM * yearnCurveVault.pricePerShare() / 1e18;\r\n    }\r\n\r\n    // Calculates the LUSD value of this contract, including B.Protocol LUSD Vault and Curve Vault\r\n    function calcTotalLUSDValue() external view returns (uint256) {\r\n        uint256 totalLUSDInCurve = getTotalLUSDInCurve();\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n\r\n        return bammLUSDValue + totalLUSDInCurve;\r\n    }\r\n\r\n    function getTotalLUSDInCurve() public view returns (uint256) {\r\n        uint256 LUSD3CRVInCurve = calcTotalYearnCurveVaultShareValue();\r\n        uint256 totalLUSDInCurve;\r\n        if (LUSD3CRVInCurve > 0) {\r\n            uint256 LUSD3CRVVirtualPrice = curvePool.get_virtual_price();\r\n            totalLUSDInCurve = LUSD3CRVInCurve * LUSD3CRVVirtualPrice / 1e18;\r\n        }\r\n\r\n        return totalLUSDInCurve;\r\n    }\r\n\r\n    // Pending getter\r\n\r\n    function getPendingLUSD() external view returns (uint256) {\r\n        return pendingLUSD;\r\n    }\r\n\r\n    // Acquired getters\r\n\r\n    function _getLUSDSplit(uint256 _bammLUSDValue)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 acquiredLUSDInSP,\r\n            uint256 acquiredLUSDInCurve,\r\n            uint256 ownedLUSDInSP,\r\n            uint256 ownedLUSDInCurve,\r\n            uint256 permanentLUSDCached\r\n        )\r\n    {\r\n        // _bammLUSDValue is guaranteed to be at least pendingLUSD due to the way we track BAMM debt\r\n        ownedLUSDInSP = _bammLUSDValue - pendingLUSD;\r\n        ownedLUSDInCurve = getTotalLUSDInCurve(); // All LUSD in Curve is owned\r\n        permanentLUSDCached = permanentLUSD;\r\n\r\n        uint256 ownedLUSD = ownedLUSDInSP + ownedLUSDInCurve;\r\n\r\n        if (ownedLUSD > permanentLUSDCached) {\r\n            // ownedLUSD > 0 implied\r\n            uint256 acquiredLUSD = ownedLUSD - permanentLUSDCached;\r\n            acquiredLUSDInSP = acquiredLUSD * ownedLUSDInSP / ownedLUSD;\r\n            acquiredLUSDInCurve = acquiredLUSD - acquiredLUSDInSP;\r\n        }\r\n    }\r\n\r\n    // Helper to avoid stack too deep in redeem() (we save one local variable)\r\n    function _getLUSDSplitAfterUpdatingBAMMDebt()\r\n        internal\r\n        returns (\r\n            uint256 acquiredLUSDInSP,\r\n            uint256 acquiredLUSDInCurve,\r\n            uint256 ownedLUSDInSP,\r\n            uint256 ownedLUSDInCurve,\r\n            uint256 permanentLUSDCached\r\n        )\r\n    {\r\n        (uint256 bammLUSDValue,) = _updateBAMMDebt();\r\n        return _getLUSDSplit(bammLUSDValue);\r\n    }\r\n\r\n    function getTotalAcquiredLUSD() public view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        (uint256 acquiredLUSDInSP, uint256 acquiredLUSDInCurve,,,) = _getLUSDSplit(bammLUSDValue);\r\n        return acquiredLUSDInSP + acquiredLUSDInCurve;\r\n    }\r\n\r\n    function getAcquiredLUSDInSP() external view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        (uint256 acquiredLUSDInSP,,,,) = _getLUSDSplit(bammLUSDValue);\r\n        return acquiredLUSDInSP;\r\n    }\r\n\r\n    function getAcquiredLUSDInCurve() external view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        (, uint256 acquiredLUSDInCurve,,,) = _getLUSDSplit(bammLUSDValue);\r\n        return acquiredLUSDInCurve;\r\n    }\r\n\r\n    // Permanent getter\r\n\r\n    function getPermanentLUSD() external view returns (uint256) {\r\n        return permanentLUSD;\r\n    }\r\n\r\n    // Owned getters\r\n\r\n    function getOwnedLUSDInSP() external view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        (,, uint256 ownedLUSDInSP,,) = _getLUSDSplit(bammLUSDValue);\r\n        return ownedLUSDInSP;\r\n    }\r\n\r\n    function getOwnedLUSDInCurve() external view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        (,,, uint256 ownedLUSDInCurve,) = _getLUSDSplit(bammLUSDValue);\r\n        return ownedLUSDInCurve;\r\n    }\r\n\r\n    // Other getters\r\n\r\n    function calcSystemBackingRatio() public view returns (uint256) {\r\n        uint256 bammLUSDValue = _getInternalBAMMLUSDValue();\r\n        return _calcSystemBackingRatioFromBAMMValue(bammLUSDValue);\r\n    }\r\n\r\n    function _calcSystemBackingRatioFromBAMMValue(uint256 _bammLUSDValue) public view returns (uint256) {\r\n        uint256 totalBLUSDSupply = bLUSDToken.totalSupply();\r\n        (uint256 acquiredLUSDInSP, uint256 acquiredLUSDInCurve,,,) = _getLUSDSplit(_bammLUSDValue);\r\n\r\n        /* TODO: Determine how to define the backing ratio when there is 0 bLUSD and 0 totalAcquiredLUSD,\r\n         * i.e. before the first chickenIn. For now, return a backing ratio of 1. Note: Both quantities would be 0\r\n         * also when the bLUSD supply is fully redeemed.\r\n         */\r\n        //if (totalBLUSDSupply == 0  && totalAcquiredLUSD == 0) {return 1e18;}\r\n        //if (totalBLUSDSupply == 0) {return MAX_UINT256;}\r\n        if (totalBLUSDSupply == 0) {return 1e18;}\r\n\r\n        return  (acquiredLUSDInSP + acquiredLUSDInCurve) * 1e18 / totalBLUSDSupply;\r\n    }\r\n\r\n    function calcUpdatedAccrualParameter() external view returns (uint256) {\r\n        (uint256 updatedAccrualParameter, ) = _calcUpdatedAccrualParameter(accrualParameter, accrualAdjustmentPeriodCount);\r\n        return updatedAccrualParameter;\r\n    }\r\n\r\n    function getBAMMLUSDDebt() external view returns (uint256) {\r\n        return bammLUSDDebt;\r\n    }\r\n\r\n    function getTreasury()\r\n        external\r\n        view\r\n        returns (\r\n            // We don't normally use leading underscores for return values,\r\n            // but we do so here in order to avoid shadowing state variables\r\n            uint256 _pendingLUSD,\r\n            uint256 _totalAcquiredLUSD,\r\n            uint256 _permanentLUSD\r\n        )\r\n    {\r\n        _pendingLUSD = pendingLUSD;\r\n        _totalAcquiredLUSD = getTotalAcquiredLUSD();\r\n        _permanentLUSD = permanentLUSD;\r\n    }\r\n\r\n    function getOpenBondCount() external view returns (uint256 openBondCount) {\r\n        return bondNFT.totalSupply() - countChickenIn - countChickenOut;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bondNFTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lusdTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curvePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveBasePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bammSPVaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yearnCurveVaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yearnRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yearnGovernanceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bLUSDTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveLiquidityGaugeAddress\",\"type\":\"address\"}],\"internalType\":\"struct ChickenBondManager.ExternalAdresses\",\"name\":\"_externalContractAddresses\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"targetAverageAgeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialAccrualParameter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumAccrualParameter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accrualAdjustmentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accrualAdjustmentPeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chickenInAMMFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveDepositDydxThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveWithdrawalDxdyThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bootstrapPeriodChickenIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bootstrapPeriodRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bootstrapPeriodShift\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shifterDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shifterWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBLUSDSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBondAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftRandomnessDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionFeeBeta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionFeeMinuteDecayFactor\",\"type\":\"uint256\"}],\"internalType\":\"struct ChickenBondManager.Params\",\"name\":\"_params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accrualParameter\",\"type\":\"uint256\"}],\"name\":\"AccrualParameterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"}],\"name\":\"BLUSDRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseRedemptionRate\",\"type\":\"uint256\"}],\"name\":\"BaseRedemptionRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bonder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principalLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"bondFinalHalfDna\",\"type\":\"uint80\"}],\"name\":\"BondCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bonder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bLusdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lusdSurplus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chickenInFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"migration\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"bondFinalHalfDna\",\"type\":\"uint80\"}],\"name\":\"BondClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bonder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"bondInitialHalfDna\",\"type\":\"uint80\"}],\"name\":\"BondCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastRedemptionFeeOpTime\",\"type\":\"uint256\"}],\"name\":\"LastRedemptionTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPermanentLUSD\",\"type\":\"uint256\"}],\"name\":\"MigrationTriggered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BETA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOTSTRAP_PERIOD_CHICKEN_IN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOTSTRAP_PERIOD_REDEEM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOTSTRAP_PERIOD_SHIFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHICKEN_IN_AMM_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINUTE_DECAY_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BLUSD_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BOND_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_RANDOMNESS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_ONE_MINUTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFTER_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHIFTER_WINDOW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bammLUSDValue\",\"type\":\"uint256\"}],\"name\":\"_calcSystemBackingRatioFromBAMMValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualAdjustmentMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualAdjustmentPeriodCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualAdjustmentPeriodSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrualParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bLUSDToken\",\"outputs\":[{\"internalType\":\"contract IBLUSDToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bammSPVault\",\"outputs\":[{\"internalType\":\"contract IBAMM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseRedemptionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondNFT\",\"outputs\":[{\"internalType\":\"contract IBondNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"}],\"name\":\"calcAccruedBLUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"}],\"name\":\"calcBondBLUSDCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fractionOfBLUSDToRedeem\",\"type\":\"uint256\"}],\"name\":\"calcRedemptionFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcSystemBackingRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcTotalLUSDValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcTotalYearnCurveVaultShareValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcUpdatedAccrualParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"}],\"name\":\"chickenIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLUSD\",\"type\":\"uint256\"}],\"name\":\"chickenOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countChickenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countChickenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lusdAmount\",\"type\":\"uint256\"}],\"name\":\"createBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createBondWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveBasePool\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveDepositLUSD3CRVExchangeRateThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveLiquidityGauge\",\"outputs\":[{\"internalType\":\"contract ICurveLiquidityGaugeV5\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveWithdrawal3CRVLUSDExchangeRateThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstChickenInTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAcquiredLUSDInCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAcquiredLUSDInSP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBAMMLUSDDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"}],\"name\":\"getBondData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lusdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"claimedBLUSD\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLUSDInBAMMSPVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondID\",\"type\":\"uint256\"}],\"name\":\"getLUSDToAcquire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOpenBondCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"openBondCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwnedLUSDInCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwnedLUSDInSP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingLUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPermanentLUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAcquiredLUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLUSDInCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingLUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAcquiredLUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_permanentLUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRedemptionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastShifterCountdownStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lusdToken\",\"outputs\":[{\"internalType\":\"contract ILUSDToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAccrualParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bLUSDToRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minLUSDFromBAMMSPVault\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lusdAmount\",\"type\":\"uint256\"}],\"name\":\"sendFeeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxLUSDToShift\",\"type\":\"uint256\"}],\"name\":\"shiftLUSDFromCurveToSP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxLUSDToShift\",\"type\":\"uint256\"}],\"name\":\"shiftLUSDFromSPToCurve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startShifterCountdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetAverageAgeSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeightedStartTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yTokensHeldByCBM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnCurveVault\",\"outputs\":[{\"internalType\":\"contract IYearnVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnGovernanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yearnRegistry\",\"outputs\":[{\"internalType\":\"contract IYearnRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ChickenBondManager", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "000000000000000000000000a8384862219188a8f03c144953cf21fc124029ee0000000000000000000000005f98805a4e8be255a32880fdec7f6728c6568ba0000000000000000000000000ed279fdd11ca84beef15af5d39bb4d4bee23f0ca000000000000000000000000bebc44782c7db0a1a60cb6fe97d0b483032ff1c7000000000000000000000000896d8a30c32ead64f2e1195c2c8e0932be7dc20b0000000000000000000000005fa5b62c8af877cb37031e0a3b2f34a78e3c56a600000000000000000000000050c1a2ea0a861a967d9d0ffe2ae4012c2e053804000000000000000000000000feb4acf3df3cdea7399794d0869ef76a6efaff52000000000000000000000000b9d7dddca9a4ac480991865efef82e01273f79c3000000000000000000000000da0dd1798be66e17d5ab1dc476302b56689c2db4000000000000000000000000000000000000000000000000000000000013c68000000000000000000000000000000000000000000000437af901e1dfac4c000000000000000000000000000000000000000000000000001146649c213f678000000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000000000000000015180000000000000000000000000000000000000000000000000006a94d74f4300000000000000000000000000000000000000000000000000000de2227fe94d00000000000000000000000000000000000000000000000000000de2227fe94d0000000000000000000000000000000000000000000000000000000000000013c680000000000000000000000000000000000000000000000000000000000013c68000000000000000000000000000000000000000000000000000000000003b53800000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000002580000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000003635c9adc5dea00000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://914c0c5509575c54b7e6b8152e0a4d87305abe88c6fd0425d04cc8d535205c59"}]}