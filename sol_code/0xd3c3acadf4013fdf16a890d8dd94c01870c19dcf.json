{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ninterface IERC721 {\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ncontract OmniStake {\r\n    // fired when NFT stake created\r\n    event StakeCreated(address staker, address asset, uint256[] tokenIds);\r\n\r\n    // fired when NFT stake cancelled\r\n    event StakeWithdrawn(address staker, address asset, uint256[] tokenIds);\r\n\r\n    // fired when NFT stake created\r\n    event MultiStakeCreated(\r\n        address staker,\r\n        address[] asset,\r\n        uint256[][] tokenIds\r\n    );\r\n\r\n    // fired when NFT stake cancelled\r\n    event MultiStakeWithdrawn(\r\n        address staker,\r\n        address[] asset,\r\n        uint256[][] tokenIds\r\n    );\r\n\r\n    /**\r\n     * NFT stakes map\r\n     * key: keccak256(abi.encodePacked(stacker,asset,tokenId))\r\n     * value: true if stake exists\r\n     */\r\n    mapping(bytes32 => bool) private Stake;\r\n\r\n    /**\r\n     * @dev calculate stakeMap key\r\n\r\n     */\r\n    function getStakeKey(\r\n        address staker,\r\n        address asset,\r\n        uint256 tokenId\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(staker, asset, tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev true if stake exists\r\n     * @param stakeKey keccak256(abi.encodePacked(stacker,asset,tokenId))\r\n     */\r\n    function StakeExists(bytes32 stakeKey) external view returns (bool) {\r\n        return Stake[stakeKey];\r\n    }\r\n\r\n    /**\r\n     * @dev create a new NFT stake\r\n     * @param asset NFT address\r\n     * @param tokenIds tokenIds of the NFT\r\n     *\r\n     * Emits a {StakeCreated} event.\r\n     */\r\n    function createStake(address asset, uint256[] calldata tokenIds) public {\r\n        require(tokenIds.length > 0, \"Stake: No tokens provided\");\r\n        address sender = msg.sender;\r\n        IERC721 ERC721 = IERC721(asset);\r\n        require(\r\n            ERC721.isApprovedForAll(sender, address(this)),\r\n            \"Stake: Not approved for all\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; ) {\r\n            uint256 tokenId = tokenIds[i];\r\n            try ERC721.transferFrom(sender, address(this), tokenId) {\r\n                Stake[getStakeKey(sender, asset, tokenId)] = true;\r\n            } catch {\r\n                revert(\"Stake: Transfer failed\");\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit StakeCreated(sender, asset, tokenIds);\r\n    }\r\n\r\n    /**\r\n     * @dev create a new NFT stake\r\n     * @param asset NFT address\r\n     * @param tokenIds tokenIds of the NFT\r\n     *\r\n     * Emits a {MultiStakeCreated} event.\r\n     */\r\n    function createMultiStake(\r\n        address[] calldata asset,\r\n        uint256[][] calldata tokenIds\r\n    ) public {\r\n        require(tokenIds.length > 0, \"Stake: No tokens provided\");\r\n        require(asset.length == tokenIds.length, \"Stake: Invalid input\");\r\n        address sender = msg.sender;\r\n        for (uint256 i = 0; i < asset.length; ) {\r\n            IERC721 ERC721 = IERC721(asset[i]);\r\n            uint256[] memory _tokenIds = tokenIds[i];\r\n            require(_tokenIds.length > 0, \"Stake: No tokens provided\");\r\n            require(\r\n                ERC721.isApprovedForAll(sender, address(this)),\r\n                \"Stake: Not approved for all\"\r\n            );\r\n            for (uint256 j = 0; j < _tokenIds.length; ) {\r\n                uint256 tokenId = _tokenIds[j];\r\n                try ERC721.transferFrom(sender, address(this), tokenId) {\r\n                    Stake[getStakeKey(sender, asset[i], tokenId)] = true;\r\n                } catch {\r\n                    revert(\"Stake: Transfer failed\");\r\n                }\r\n                unchecked {\r\n                    j++;\r\n                }\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit MultiStakeCreated(sender, asset, tokenIds);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw NFT stake\r\n     * @param asset NFT address\r\n     * @param tokenIds tokenIds of the NFT\r\n     *\r\n     * Emits a {StakeWithdrawn} event.\r\n     */\r\n    function withdrawStake(address asset, uint256[] calldata tokenIds) public {\r\n        require(tokenIds.length > 0, \"Stake: No tokens provided\");\r\n        address sender = msg.sender;\r\n        IERC721 ERC721 = IERC721(asset);\r\n        for (uint256 i = 0; i < tokenIds.length; ) {\r\n            uint256 _tokenId = tokenIds[i];\r\n            bytes32 key = getStakeKey(sender, asset, _tokenId);\r\n            require(Stake[key], \"Stake: Not staked\");\r\n\r\n            try ERC721.transferFrom(address(this), sender, _tokenId) {\r\n                delete Stake[key];\r\n            } catch {\r\n                revert(\"Stake: Transfer failed\");\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n        emit StakeWithdrawn(sender, asset, tokenIds);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraw NFT stake\r\n     * @param asset NFT address\r\n     * @param tokenIds tokenIds of the NFT\r\n     *\r\n     * Emits a {MultiStakeWithdrawn} event.\r\n     */\r\n    function withdrawMultiStake(\r\n        address[] calldata asset,\r\n        uint256[][] calldata tokenIds\r\n    ) public {\r\n        require(tokenIds.length > 0, \"Stake: No tokens provided\");\r\n        require(asset.length == tokenIds.length, \"Stake: Invalid input\");\r\n        address sender = msg.sender;\r\n        for (uint256 i = 0; i < asset.length; ) {\r\n            IERC721 ERC721 = IERC721(asset[i]);\r\n            uint256[] memory _tokenIds = tokenIds[i];\r\n            require(_tokenIds.length > 0, \"Stake: No tokens provided\");\r\n            for (uint256 j = 0; j < _tokenIds.length; ) {\r\n                uint256 _tokenId = _tokenIds[j];\r\n                bytes32 key = getStakeKey(sender, asset[i], _tokenId);\r\n                require(Stake[key], \"Stake: Not staked\");\r\n\r\n                try ERC721.transferFrom(address(this), sender, _tokenId) {\r\n                    delete Stake[key];\r\n                } catch {\r\n                    revert(\"Stake: Transfer failed\");\r\n                }\r\n                unchecked {\r\n                    j++;\r\n                }\r\n            }\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit MultiStakeWithdrawn(sender, asset, tokenIds);\r\n    }\r\n\r\n    /**\r\n     * @dev stake withdraw at the same time\r\n     * @param stakeAsset stake NFT address\r\n     * @param stakeTokenIds stake tokenIds of the NFT\r\n     * @param withdrawAsset withdraw NFT address\r\n     * @param withdrawTokenIds withdraw tokenIds of the NFT\r\n     * Emits {StakeWithdrawn} and {StakeCreated} event.\r\n     */\r\n    function createStakeAndWithdraw(\r\n        address stakeAsset,\r\n        uint256[] calldata stakeTokenIds,\r\n        address withdrawAsset,\r\n        uint256[] calldata withdrawTokenIds\r\n    ) public {\r\n        withdrawStake(withdrawAsset, withdrawTokenIds);\r\n        createStake(stakeAsset, stakeTokenIds);\r\n    }\r\n\r\n    /**\r\n     * @dev stake withdraw at the same time\r\n     * @param stakeAsset stake NFT address\r\n     * @param stakeTokenIds stake tokenIds of the NFT\r\n     * @param withdrawAsset withdraw NFT address\r\n     * @param withdrawTokenIds withdraw tokenIds of the NFT\r\n     * Emits {MultiStakeWithdrawn} and {MultiStakeCreated} event.\r\n     */\r\n    function createMultiStakeAndWithdraw(\r\n        address[] calldata stakeAsset,\r\n        uint256[][] calldata stakeTokenIds,\r\n        address[] calldata withdrawAsset,\r\n        uint256[][] calldata withdrawTokenIds\r\n    ) public {\r\n        withdrawMultiStake(withdrawAsset, withdrawTokenIds);\r\n        createMultiStake(stakeAsset, stakeTokenIds);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"asset\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"MultiStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"asset\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"MultiStakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"stakeKey\",\"type\":\"bytes32\"}],\"name\":\"StakeExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"asset\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"createMultiStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakeAsset\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"stakeTokenIds\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[]\",\"name\":\"withdrawAsset\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"withdrawTokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"createMultiStakeAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeAsset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"withdrawAsset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"createStakeAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakeKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"asset\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"withdrawMultiStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OmniStake", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e9255eba3d66d1a60c2a4682ae2999328ec1d57520c3b6add55d854496580d25"}]}