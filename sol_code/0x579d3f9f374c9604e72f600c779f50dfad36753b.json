{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n */\r\ncontract Cloneable {\r\n\r\n    /**\r\n        @dev Deploys and returns the address of a clone of address(this\r\n        Created by DeFi Mark To Allow Clone Contract To Easily Create Clones Of Itself\r\n        Without redundancy\r\n     */\r\n    function clone() external returns(address) {\r\n        return _clone(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function _clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract NFTStakingData is ReentrancyGuard {\r\n\r\n    uint256 internal constant PRECISION = 10**18;\r\n\r\n    address public NFT;\r\n    address public rewardToken;\r\n    uint256 public lockTime;\r\n\r\n    address public lockTimeSetter;\r\n\r\n    uint256 public dividendsPerNFT;\r\n    uint256 public totalDividends;\r\n    uint256 public totalStaked;\r\n\r\n    string public name;\r\n    string public symbol;\r\n\r\n    struct UserInfo {\r\n        uint256[] tokenIds;\r\n        uint256 balance;\r\n        uint256 totalExcluded;\r\n        uint256 totalRewardsClaimed;\r\n    }\r\n\r\n    struct StakedTokenId {\r\n        uint256 index;      // index in user token id array\r\n        uint256 timeLocked; // time the id was locked\r\n        address owner;\r\n    }\r\n\r\n    mapping ( address => UserInfo ) public userInfo;\r\n    mapping ( uint256 => StakedTokenId ) public tokenInfo;\r\n}\r\n\r\ncontract NFTStaking is NFTStakingData, Cloneable, IERC721, IERC721Metadata {\r\n\r\n    function __init__(\r\n        address NFT_,\r\n        address rewardToken_,\r\n        uint256 lockTime_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address lockTimeSetter_\r\n    ) external {\r\n        require(\r\n            NFT_ != address(0) &&\r\n            NFT == address(0),\r\n            'Invalid Init'\r\n        );\r\n\r\n        NFT = NFT_;\r\n        rewardToken = rewardToken_;\r\n        lockTime = lockTime_;\r\n        name = name_;\r\n        symbol = symbol_;\r\n        lockTimeSetter = lockTimeSetter_;\r\n    }\r\n\r\n    function setLockTime(uint256 newLockTime) external nonReentrant {\r\n        require(\r\n            msg.sender == lockTimeSetter,\r\n            'Only Setter Can Call'\r\n        );\r\n        require(\r\n            newLockTime <= 10**7,\r\n            'Lock Time Too Long'\r\n        );\r\n        lockTime = newLockTime;\r\n    }\r\n\r\n    function setLockTimeSetter(address newSetter) external nonReentrant {\r\n        require(\r\n            msg.sender == lockTimeSetter,\r\n            'Only Setter Can Call'\r\n        );\r\n        lockTimeSetter = newSetter;\r\n    }\r\n\r\n    function stake(uint256 tokenId) external nonReentrant {\r\n        _stake(tokenId);\r\n    }\r\n\r\n    function batchStake(uint256[] calldata tokenIds) external nonReentrant {\r\n        _batchStake(tokenIds);\r\n    }\r\n\r\n    function withdraw(uint256 tokenId) external nonReentrant {\r\n        _withdraw(tokenId);\r\n    }\r\n\r\n    function batchWithdraw(uint256[] calldata tokenIds) external nonReentrant {\r\n        _batchWithdraw(tokenIds);\r\n    }\r\n\r\n    function claimRewards() external nonReentrant {\r\n        _claimRewards(msg.sender);\r\n    }\r\n\r\n    function _stake(uint256 tokenId) internal {\r\n\r\n        // ensure message sender is owner of nft\r\n        require(\r\n            isOwner(tokenId, msg.sender),\r\n            'Sender Not NFT Owner'\r\n        );\r\n        require(\r\n            tokenInfo[tokenId].owner == address(0),\r\n            'Already Staked'\r\n        );\r\n\r\n        // claim rewards if applicable\r\n        _claimRewards(msg.sender);    \r\n\r\n        // send nft to self\r\n        IERC721(NFT).transferFrom(msg.sender, address(this), tokenId);\r\n\r\n        // ensure nft is now owned by `this`\r\n        require(\r\n            isOwner(tokenId, address(this)),\r\n            'NFT Ownership Not Transferred'\r\n        );\r\n\r\n        // increment total staked and user balance\r\n        totalStaked++;\r\n        userInfo[msg.sender].balance++;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n        \r\n        // set current tokenId index to length of user id array\r\n        tokenInfo[tokenId].index = userInfo[msg.sender].tokenIds.length;\r\n        tokenInfo[tokenId].timeLocked = block.number;\r\n        tokenInfo[tokenId].owner = msg.sender;\r\n\r\n        // push new token id to user id array\r\n        userInfo[msg.sender].tokenIds.push(tokenId);\r\n\r\n        emit Transfer(address(0), msg.sender, tokenId);\r\n    }\r\n\r\n    function _batchStake(uint256[] calldata tokenIds) internal {\r\n\r\n        // claim rewards if applicable\r\n        _claimRewards(msg.sender);   \r\n\r\n        // length of array\r\n        uint256 len = tokenIds.length; \r\n\r\n        for (uint i = 0; i < len;) {\r\n            // ensure message sender is owner of nft\r\n            require(\r\n                isOwner(tokenIds[i], msg.sender),\r\n                'Sender Not NFT Owner'\r\n            );\r\n            require(\r\n                tokenInfo[tokenIds[i]].owner == address(0),\r\n                'Already Staked'\r\n            );\r\n\r\n            // send nft to self\r\n            IERC721(NFT).transferFrom(msg.sender, address(this), tokenIds[i]);\r\n\r\n            // ensure nft is now owned by `this`\r\n            require(\r\n                isOwner(tokenIds[i], address(this)),\r\n                'NFT Ownership Not Transferred'\r\n            );\r\n\r\n            // set current tokenId index to length of user id array\r\n            tokenInfo[tokenIds[i]].index = userInfo[msg.sender].tokenIds.length;\r\n            tokenInfo[tokenIds[i]].timeLocked = block.number;\r\n            tokenInfo[tokenIds[i]].owner = msg.sender;\r\n\r\n            // push new token id to user id array\r\n            userInfo[msg.sender].tokenIds.push(tokenIds[i]);\r\n\r\n            emit Transfer(address(0), msg.sender, tokenIds[i]);\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // increment total staked and user balance\r\n        totalStaked += len;\r\n        userInfo[msg.sender].balance += len;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n    }\r\n\r\n    function _withdraw(uint256 tokenId) internal {\r\n        require(\r\n            isOwner(tokenId, address(this)),\r\n            'NFT Is Not Staked'\r\n        );\r\n        require(\r\n            tokenInfo[tokenId].owner == msg.sender,\r\n            'Only Owner Can Withdraw'\r\n        );\r\n        require(\r\n            hasStakedNFT(msg.sender, tokenId),\r\n            'User Has Not Staked tokenId'\r\n        );\r\n        require(\r\n            timeUntilUnlock(tokenId) == 0,\r\n            'Token Still Locked'\r\n        );\r\n\r\n        // claim pending rewards if any\r\n        _claimRewards(msg.sender);\r\n        \r\n        // decrement balance\r\n        userInfo[msg.sender].balance -= 1;\r\n        totalStaked -= 1;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n\r\n        // remove nft from user array\r\n        _removeNFT(msg.sender, tokenId);\r\n        \r\n        // send nft to caller\r\n        IERC721(NFT).transferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit Transfer(msg.sender, address(0), tokenId);\r\n    }\r\n\r\n    function _batchWithdraw(uint256[] calldata tokenIds) internal {\r\n\r\n        // claim pending rewards if any\r\n        _claimRewards(msg.sender);\r\n\r\n        // length of array\r\n        uint256 len = tokenIds.length;\r\n\r\n        // decrement balance\r\n        userInfo[msg.sender].balance -= len;\r\n        totalStaked -= len;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n\r\n        for (uint i = 0; i < len;) {\r\n            \r\n            require(\r\n                isOwner(tokenIds[i], address(this)),\r\n                'NFT Is Not Staked'\r\n            );\r\n            require(\r\n                hasStakedNFT(msg.sender, tokenIds[i]),\r\n                'User Has Not Staked tokenId'\r\n            );\r\n            require(\r\n                timeUntilUnlock(tokenIds[i]) == 0,\r\n                'Token Still Locked'\r\n            );\r\n\r\n            // remove nft from user array\r\n            _removeNFT(msg.sender, tokenIds[i]);\r\n\r\n            // send nft to caller\r\n            IERC721(NFT).transferFrom(address(this), msg.sender, tokenIds[i]);\r\n\r\n            // emit event\r\n            emit Transfer(msg.sender, address(0), tokenIds[i]);\r\n\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /**\r\n        Claims Reward For User\r\n     */\r\n    function _claimRewards(address user) internal {\r\n\r\n        // return if zero balance\r\n        if (userInfo[user].balance == 0) {\r\n            return;\r\n        }\r\n\r\n        // fetch pending rewards\r\n        uint pending = pendingRewards(user);\r\n        uint max = rewardBalanceOf();\r\n        if (pending > max) {\r\n            pending = max;\r\n        }\r\n        \r\n        // reset total rewards\r\n        userInfo[user].totalExcluded = getCumulativeDividends(userInfo[user].balance);\r\n\r\n        // return if no rewards\r\n        if (pending == 0) {\r\n            return;\r\n        }\r\n\r\n        // incremenet total rewards claimed\r\n        unchecked {\r\n            userInfo[user].totalRewardsClaimed += pending;\r\n        }\r\n\r\n        // transfer reward to user\r\n        require(\r\n            IERC20(rewardToken).transfer(\r\n                user,\r\n                pending\r\n            ),\r\n            'Failure Reward Transfer'\r\n        );\r\n    }\r\n\r\n    /**\r\n        Pending Token Rewards For `account`\r\n     */\r\n    function pendingRewards(address account) public view returns (uint256) {\r\n        if(userInfo[account].balance == 0){ return 0; }\r\n\r\n        uint256 accountTotalDividends = getCumulativeDividends(userInfo[account].balance);\r\n        uint256 accountTotalExcluded = userInfo[account].totalExcluded;\r\n\r\n        if(accountTotalDividends <= accountTotalExcluded){ return 0; }\r\n\r\n        return accountTotalDividends - accountTotalExcluded;\r\n    }\r\n\r\n    /**\r\n        Cumulative Dividends For A Number Of Tokens\r\n     */\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return (share * dividendsPerNFT) / PRECISION;\r\n    }\r\n\r\n    function giveRewards(uint256 amount) external {\r\n        \r\n        uint balBefore = rewardBalanceOf();\r\n        IERC20(rewardToken).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        uint balAfter = rewardBalanceOf();\r\n        require(\r\n            balAfter > balBefore,\r\n            'Zero Rewards'\r\n        );\r\n\r\n        uint received = balAfter - balBefore;\r\n\r\n        totalDividends += received;\r\n        dividendsPerNFT += ( received * PRECISION ) / totalStaked;\r\n    }\r\n\r\n    function _removeNFT(address user, uint256 tokenId) internal {\r\n        \r\n        uint lastElement = userInfo[user].tokenIds[userInfo[user].tokenIds.length - 1];\r\n        uint removeIndex = tokenInfo[tokenId].index;\r\n\r\n        userInfo[user].tokenIds[removeIndex] = lastElement;\r\n        tokenInfo[lastElement].index = removeIndex;\r\n        userInfo[user].tokenIds.pop();\r\n\r\n        delete tokenInfo[tokenId];\r\n    }\r\n\r\n    function timeUntilUnlock(uint256 tokenId) public view returns (uint256) {\r\n        uint unlockTime = tokenInfo[tokenId].timeLocked + lockTime;\r\n        return unlockTime <= block.number ? 0 : unlockTime - block.number;\r\n    }\r\n\r\n    function isOwner(uint256 tokenId, address user) public view returns (bool) {\r\n        return IERC721(NFT).ownerOf(tokenId) == user;\r\n    }\r\n\r\n    function listUserStakedNFTs(address user) public view returns (uint256[] memory) {\r\n        return userInfo[user].tokenIds;\r\n    }\r\n\r\n    function fetchBalancePendingAndTotalRewards(address user) public view returns (uint256, uint256, uint256) {\r\n        return (userInfo[user].balance, pendingRewards(user), userInfo[user].totalRewardsClaimed);\r\n    }\r\n    \r\n    function listUserStakedNFTsAndURIs(address user) public view returns (uint256[] memory, string[] memory) {\r\n        \r\n        uint len = userInfo[user].tokenIds.length;\r\n        string[] memory uris = new string[](len);\r\n        for (uint i = 0; i < len;) {\r\n            uris[i] = IERC721Metadata(NFT).tokenURI(userInfo[user].tokenIds[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return (userInfo[user].tokenIds, uris);\r\n    }\r\n\r\n    function listUserStakedNFTsURIsAndRemainingLockTimes(address user) public view returns (\r\n        uint256[] memory, \r\n        string[] memory,\r\n        uint256[] memory\r\n    ) {\r\n        \r\n        uint len = userInfo[user].tokenIds.length;\r\n        string[] memory uris = new string[](len);\r\n        uint256[] memory remainingLocks = new uint256[](len);\r\n        for (uint i = 0; i < len;) {\r\n            uris[i] = IERC721Metadata(NFT).tokenURI(userInfo[user].tokenIds[i]);\r\n            remainingLocks[i] = timeUntilUnlock(userInfo[user].tokenIds[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return (userInfo[user].tokenIds, uris, remainingLocks);\r\n    }\r\n\r\n    function listUserTotalNFTs(address user, uint min, uint max) public view returns (uint256[] memory) {\r\n        \r\n        IERC721 NFT_ = IERC721(NFT);\r\n        uint len = NFT_.balanceOf(user);\r\n\r\n        uint256[] memory ids = new uint256[](len);\r\n        uint count = 0;\r\n\r\n        for (uint i = min; i < max;) {\r\n\r\n            if (NFT_.ownerOf(i) == user) {\r\n                ids[count] = i;\r\n                count++;\r\n            }\r\n            \r\n            unchecked {++i;}\r\n        }\r\n        return (ids);\r\n    }\r\n\r\n    function listUserTotalNFTsAndUris(address user, uint min, uint max) public view returns (uint256[] memory, string[] memory) {\r\n        \r\n        IERC721 NFT_ = IERC721(NFT);\r\n        uint len = NFT_.balanceOf(user);\r\n\r\n        uint256[] memory ids = new uint256[](len);\r\n        string[] memory uris = new string[](len);\r\n        uint count = 0;\r\n\r\n        for (uint i = min; i < max;) {\r\n\r\n            if (NFT_.ownerOf(i) == user) {\r\n                ids[count] = i;\r\n                uris[count] = IERC721Metadata(NFT).tokenURI(i);\r\n                count++;\r\n            }\r\n            \r\n            unchecked {++i;}\r\n        }\r\n        return (ids, uris);\r\n    }\r\n\r\n    function hasStakedNFT(address user, uint256 tokenId) public view returns (bool) {\r\n        if (userInfo[user].tokenIds.length <= tokenInfo[tokenId].index || tokenInfo[tokenId].owner != user) {\r\n            return false;\r\n        }\r\n        return userInfo[user].tokenIds[tokenInfo[tokenId].index] == tokenId;\r\n    }\r\n\r\n    function hasStakedNFTs(address user, uint256[] calldata tokenId) public view returns (bool[] memory) {\r\n        uint len = tokenId.length;\r\n        bool[] memory hasStaked = new bool[](len);\r\n        for (uint i = 0; i < len;) {\r\n            hasStaked[i] = userInfo[user].tokenIds[tokenInfo[tokenId[i]].index] == tokenId[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return hasStaked;\r\n    }\r\n\r\n    function rewardBalanceOf() public view returns (uint256) {\r\n        return IERC20(rewardToken).balanceOf(address(this));\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return IERC721(NFT).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view override returns (uint256 balance) {\r\n        return userInfo[owner].balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view override returns (address owner) {\r\n        return tokenInfo[tokenId].owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external override {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external override {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address, uint256) external override {\r\n        emit Approval(address(0), address(0), 0);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 a) external view override returns (address operator) {\r\n        return a == uint(uint160(msg.sender)) ? address(0) : msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address, bool) external override {\r\n        emit Approval(address(0), address(0), 0);\r\n        return;\r\n    }\r\n\r\n    function isApprovedForAll(address a, address b) external view override returns (bool) {\r\n        return a == b && a == NFT;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external override {\r\n\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) external view override returns (string memory) {\r\n        return IERC721Metadata(NFT).tokenURI(tokenId);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NFT_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTime_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"lockTimeSetter_\",\"type\":\"address\"}],\"name\":\"__init__\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchBalancePendingAndTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"giveRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasStakedNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"}],\"name\":\"hasStakedNFTs\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"b\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserStakedNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserStakedNFTsAndURIs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserStakedNFTsURIsAndRemainingLockTimes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"listUserTotalNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"listUserTotalNFTsAndUris\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTimeSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSetter\",\"type\":\"address\"}],\"name\":\"setLockTimeSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"timeUntilUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTStaking", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2324acf90b01b6bfea466f37070847a7e65798a72ff1bafdf46eac3b00eaddda"}]}