{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BlockHistory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./lib/CoreTypes.sol\\\";\\nimport \\\"./lib/MerkleTree.sol\\\";\\nimport \\\"./interfaces/IBlockHistory.sol\\\";\\nimport \\\"./interfaces/IRecursiveVerifier.sol\\\";\\n\\nimport {\\n    RecursiveProof,\\n    SignedRecursiveProof,\\n    getProofSigner,\\n    readHashWords\\n} from \\\"./lib/Proofs.sol\\\";\\n\\n/**\\n * @title BlockHistory\\n * @author Theori, Inc.\\n * @notice BlockHistory allows trustless and cheap verification of any\\n *         historical block hash. Historical blocks are divided into chunks of\\n *         fixed size, and each chunk's merkle root is stored on-chain. The\\n *         merkle roots are validated on chain using aggregated SNARK proofs,\\n *         enabling both trustlessness and scalability.\\n *\\n * @dev Each SNARK proof validates some contiguous block headers and has\\n *      public inputs (parentHash, lastHash, merkleRoot). Here the merkleRoot\\n *      is the merkleRoot of all block hashes contained in the proof, which may\\n *      commit to many merkle roots which to commit on chain. If the last block\\n *      is recent enough (<= 256 blocks old), the lastHash can be confirmed in\\n *      the EVM, verifying that all blocks of the proof belong to this chain.\\n *      Due to this, the historical blocks' merkle roots are imported in reverse\\n *      order.\\n */\\ncontract BlockHistory is Ownable, IBlockHistory {\\n    // depth of the merkle trees whose roots we store in storage\\n    uint256 private constant MERKLE_TREE_DEPTH = 13;\\n    uint256 private constant BLOCKS_PER_CHUNK = 1 << MERKLE_TREE_DEPTH;\\n\\n    /// @dev address of the reliquary, immutable\\n    address public immutable reliquary;\\n\\n    /// @dev the expected signer of the SNARK proofs - if 0, then no signatures\\n    address public signer;\\n\\n    /// @dev maps numBlocks => SNARK verifier (with VK embedded), only assigned\\n    ///      to in the constructor\\n    mapping(uint256 => IRecursiveVerifier) public verifiers;\\n\\n    /// @dev parent hash of oldest block in current merkle trees\\n    ///      (0 once backlog fully imported)\\n    bytes32 public parentHash;\\n\\n    /// @dev the earliest merkle root that has been imported\\n    uint256 public earliestRoot;\\n\\n    /// @dev hash of most recent block in merkle trees\\n    bytes32 public lastHash;\\n\\n    /// @dev merkle roots of block chunks between parentHash and lastHash\\n    mapping(uint256 => bytes32) private merkleRoots;\\n\\n    event ImportMerkleRoot(uint256 indexed index, bytes32 merkleRoot);\\n    event NewSigner(address newSigner);\\n\\n    enum ProofType {\\n        Merkle,\\n        SNARK\\n    }\\n\\n    /// @dev A SNARK + Merkle proof used to prove validity of a block\\n    struct ValidBlockSNARK {\\n        uint256 numBlocks;\\n        uint256 endBlock;\\n        SignedRecursiveProof snark;\\n        bytes32[] merkleProof;\\n    }\\n\\n    constructor(\\n        uint256[] memory sizes,\\n        IRecursiveVerifier[] memory _verifiers,\\n        address _reliquary\\n    ) Ownable() {\\n        reliquary = _reliquary;\\n\\n        require(sizes.length == _verifiers.length);\\n        for (uint256 i = 0; i < sizes.length; i++) {\\n            require(address(verifiers[sizes[i]]) == address(0));\\n            verifiers[sizes[i]] = _verifiers[i];\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a SNARK is valid and signed as expected.\\n     *         Signatures checks are disabled if stored signer == address(0)\\n     *         Properties proven by the SNARK:\\n     *         - (parent ... last) form a valid block chain of length numBlocks\\n     *         - root is the merkle root of all contained blocks\\n     *\\n     * @param proof the aggregated proof\\n     * @param numBlocks the number of blocks contained in the proof\\n     * @return the validity\\n     */\\n    function validSNARK(SignedRecursiveProof calldata proof, uint256 numBlocks)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        address expected = signer;\\n        if (expected != address(0) && getProofSigner(proof) != expected) {\\n            return false;\\n        }\\n        IRecursiveVerifier verifier = verifiers[numBlocks];\\n        require(address(verifier) != address(0), \\\"invalid numBlocks\\\");\\n        return verifier.verify(proof.inner);\\n    }\\n\\n    /**\\n     * @notice Asserts that the provided SNARK proof is valid and contains\\n     *         the provied merkle roots.\\n     *\\n     * @param proof the aggregated proof\\n     * @param roots the merkle roots\\n     * @return parent the parentHash of the proof blocks\\n     * @return last the lastHash of the proof blocks\\n     */\\n    function assertValidSNARKWithRoots(\\n        SignedRecursiveProof calldata proof,\\n        bytes32[] calldata roots\\n    ) internal view returns (bytes32 parent, bytes32 last) {\\n        require(roots.length & (roots.length - 1) == 0, \\\"roots length must be a power of 2\\\");\\n\\n        // extract the inputs from the proof\\n        bytes32 proofRoot;\\n        (parent, last, proofRoot) = parseProofInputs(proof);\\n\\n        // ensure the merkle roots are valid\\n        require(proofRoot == MerkleTree.computeRoot(roots), \\\"invalid roots\\\");\\n\\n        // assert the SNARK proof is valid\\n        require(validSNARK(proof, BLOCKS_PER_CHUNK * roots.length), \\\"invalid SNARK\\\");\\n    }\\n\\n    /**\\n     * @notice Checks if the given block number/hash connects to the current\\n     *         block using a SNARK.\\n     *\\n     * @param num the block number to check\\n     * @param hash the block hash to check\\n     * @param encodedProof the encoded ValidBlockSNARK\\n     * @return the validity\\n     */\\n    function validBlockHashWithSNARK(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata encodedProof\\n    ) internal view returns (bool) {\\n        ValidBlockSNARK calldata proof = parseValidBlockSNARK(encodedProof);\\n\\n        (bytes32 proofParent, bytes32 proofLast, bytes32 proofRoot) = parseProofInputs(proof.snark);\\n\\n        // check that the proof ends with a current block\\n        if (!validCurrentBlock(proofLast, proof.endBlock)) {\\n            return false;\\n        }\\n\\n        if (!validSNARK(proof.snark, proof.numBlocks)) {\\n            return false;\\n        }\\n\\n        // compute the first block number in the proof\\n        uint256 startBlock = proof.endBlock + 1 - proof.numBlocks;\\n\\n        // check if the target block is the parent of the proven blocks\\n        if (num == startBlock - 1 && hash == proofParent) {\\n            // merkle proof not needed in this case\\n            return true;\\n        }\\n\\n        // check if the target block is in the proven merkle root\\n        uint256 index = num - startBlock;\\n        return MerkleTree.validProof(proofRoot, index, hash, proof.merkleProof);\\n    }\\n\\n    /**\\n     * @notice Checks if the given block number + hash exists in a commited\\n     *         merkle tree.\\n     *\\n     * @param num the block number to check\\n     * @param hash the block hash to check\\n     * @param encodedProof the encoded merkle proof\\n     * @return the validity\\n     */\\n    function validBlockHashWithMerkle(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata encodedProof\\n    ) internal view returns (bool) {\\n        bytes32 merkleRoot = merkleRoots[num / BLOCKS_PER_CHUNK];\\n        if (merkleRoot == 0) {\\n            return false;\\n        }\\n        bytes32[] calldata proofHashes = parseMerkleProof(encodedProof);\\n        if (proofHashes.length != MERKLE_TREE_DEPTH) {\\n            return false;\\n        }\\n        return MerkleTree.validProof(merkleRoot, num % BLOCKS_PER_CHUNK, hash, proofHashes);\\n    }\\n\\n    /**\\n     * @notice Checks if the block is a current block (defined as being\\n     *         accessible in the EVM, i.e. <= 256 blocks old) and that the hash\\n     *         is correct.\\n     *\\n     * @param hash the alleged block hash\\n     * @param num the block number\\n     * @return the validity\\n     */\\n    function validCurrentBlock(bytes32 hash, uint256 num) internal view returns (bool) {\\n        // the block hash must be accessible in the EVM and match\\n        return (block.number - num <= 256) && (blockhash(num) == hash);\\n    }\\n\\n    /**\\n     * @notice Stores the merkle roots starting at the index\\n     *\\n     * @param index the index for the first merkle root\\n     * @param roots the merkle roots\\n     */\\n    function storeMerkleRoots(uint256 index, bytes32[] calldata roots) internal {\\n        for (uint256 i = 0; i < roots.length; i++) {\\n            merkleRoots[index + i] = roots[i];\\n            emit ImportMerkleRoot(index + i, roots[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Imports new chunks of blocks before the current parentHash\\n     *\\n     * @param proof the aggregated proof for these chunks\\n     * @param roots the merkle roots for the chunks\\n     */\\n    function importParent(SignedRecursiveProof calldata proof, bytes32[] calldata roots) external {\\n        require(parentHash != 0 && earliestRoot != 0, \\\"import not started or already completed\\\");\\n\\n        (bytes32 proofParent, bytes32 proofLast) = assertValidSNARKWithRoots(proof, roots);\\n\\n        // assert the last hash in the proof is our current parent hash\\n        require(parentHash == proofLast, \\\"proof doesn't connect with parentHash\\\");\\n\\n        // store the merkle roots\\n        uint256 index = earliestRoot - roots.length;\\n        storeMerkleRoots(index, roots);\\n\\n        // store the new parentHash and earliestRoot\\n        parentHash = proofParent;\\n        earliestRoot = index;\\n    }\\n\\n    /**\\n     * @notice Imports new chunks of blocks after the current lastHash\\n     *\\n     * @param endBlock the last block number in the chunks\\n     * @param proof the aggregated proof for these chunks\\n     * @param roots the merkle roots for the chunks\\n     * @param connectProof an optional SNARK proof connecting the proof to\\n     *                     a current block\\n     */\\n    function importLast(\\n        uint256 endBlock,\\n        SignedRecursiveProof calldata proof,\\n        bytes32[] calldata roots,\\n        bytes calldata connectProof\\n    ) external {\\n        require((endBlock + 1) % BLOCKS_PER_CHUNK == 0, \\\"endBlock must end at a chunk boundary\\\");\\n\\n        (bytes32 proofParent, bytes32 proofLast) = assertValidSNARKWithRoots(proof, roots);\\n\\n        if (!validCurrentBlock(proofLast, endBlock)) {\\n            // if the proof doesn't connect our lastHash with a current block,\\n            // then the connectProof must fill the gap\\n            require(\\n                validBlockHashWithSNARK(proofLast, endBlock, connectProof),\\n                \\\"connectProof invalid\\\"\\n            );\\n        }\\n\\n        uint256 index = (endBlock + 1) / BLOCKS_PER_CHUNK - roots.length;\\n        if (lastHash == 0) {\\n            // if we're importing for the first time, set parentHash and earliestRoot\\n            require(parentHash == 0);\\n            parentHash = proofParent;\\n            earliestRoot = index;\\n        } else {\\n            require(proofParent == lastHash, \\\"proof doesn't connect with lastHash\\\");\\n        }\\n\\n        // store the new lastHash\\n        lastHash = proofLast;\\n\\n        // store the merkle roots\\n        storeMerkleRoots(index, roots);\\n    }\\n\\n    /**\\n     * @notice Checks if a block hash is valid. A proof is required unless the\\n     *         block is current (accesible in the EVM). If the target block has\\n     *         no commited merkle root, the proof must contain a SNARK proof.\\n     *\\n     * @param hash the hash to check\\n     * @param num the block number for the alleged hash\\n     * @param proof the merkle witness or SNARK proof (if needed)\\n     * @return the validity\\n     */\\n    function _validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) internal view returns (bool) {\\n        if (validCurrentBlock(hash, num)) {\\n            return true;\\n        }\\n\\n        ProofType typ;\\n        (typ, proof) = parseProofType(proof);\\n        if (typ == ProofType.Merkle) {\\n            return validBlockHashWithMerkle(hash, num, proof);\\n        } else if (typ == ProofType.SNARK) {\\n            return validBlockHashWithSNARK(hash, num, proof);\\n        } else {\\n            revert(\\\"invalid proof type\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if a block hash is correct. A proof is required unless the\\n     *         block is current (accesible in the EVM). If the target block has\\n     *         no commited merkle root, the proof must contain a SNARK proof.\\n     *         Reverts if block hash or proof is invalid.\\n     *\\n     * @param hash the hash to check\\n     * @param num the block number for the alleged hash\\n     * @param proof the merkle witness or SNARK proof (if needed)\\n     */\\n    function validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) external view returns (bool) {\\n        require(msg.sender == reliquary || msg.sender == owner());\\n        require(num < block.number);\\n        return _validBlockHash(hash, num, proof);\\n    }\\n\\n    /**\\n     * @notice Parses a proof type and proof from the encoded proof\\n     *\\n     * @param proof the encoded proof\\n     * @return typ the proof type (SNARK or Merkle)\\n     * @return proof the remaining encoded proof\\n     */\\n    function parseProofType(bytes calldata encodedProof)\\n        internal\\n        pure\\n        returns (ProofType typ, bytes calldata proof)\\n    {\\n        require(encodedProof.length > 0, \\\"cannot parse proof type\\\");\\n        typ = ProofType(uint8(encodedProof[0]));\\n        proof = encodedProof[1:];\\n    }\\n\\n    /**\\n     * @notice Parses a ValidBlockSNARK from calldata bytes\\n     *\\n     * @param proof the encoded proof\\n     * @return result a ValidBlockSNARK\\n     */\\n    function parseValidBlockSNARK(bytes calldata proof)\\n        internal\\n        pure\\n        returns (ValidBlockSNARK calldata result)\\n    {\\n        // solidity doesn't support getting calldata outputs from abi.decode\\n        // but we can decode it; calldata structs are just offsets\\n        assembly {\\n            result := proof.offset\\n        }\\n    }\\n\\n    /**\\n     * @notice Parses a merkle inclusion proof from the bytes\\n     *\\n     * @param proof the encoded merkle inclusion proof\\n     * @return result the array of proof hashes\\n     */\\n    function parseMerkleProof(bytes calldata proof)\\n        internal\\n        pure\\n        returns (bytes32[] calldata result)\\n    {\\n        require(proof.length % 32 == 0);\\n        require(proof.length >= 32);\\n\\n        // solidity doesn't support getting calldata outputs from abi.decode\\n        // but we can decode it; calldata arrays are just (offset,length)\\n        assembly {\\n            result.offset := add(proof.offset, 0x20)\\n            result.length := calldataload(proof.offset)\\n        }\\n    }\\n\\n    /**\\n     * @notice Parses the proof inputs for block history snark proofs\\n     *\\n     * @param proof the snark proof\\n     * @return proofParent the parentHash of the proof blocks\\n     * @return proofLast the lastHash of the proof blocks\\n     * @return proofRoot the merkle root of the proof blocks\\n     */\\n    function parseProofInputs(SignedRecursiveProof calldata proof)\\n        internal\\n        pure\\n        returns (\\n            bytes32 proofParent,\\n            bytes32 proofLast,\\n            bytes32 proofRoot\\n        )\\n    {\\n        uint256[] calldata inputs = proof.inner.inputs;\\n        require(inputs.length == 12);\\n        proofParent = readHashWords(inputs[0:4]);\\n        proofLast = readHashWords(inputs[4:8]);\\n        proofRoot = readHashWords(inputs[8:12]);\\n    }\\n\\n    /**\\n     * @notice sets the expected signer of the SNARK proofs, only callable by\\n     *         the contract owner\\n     *\\n     * @param _signer the new signer; if 0, disables signature checks\\n     */\\n    function setSigner(address _signer) external onlyOwner {\\n        require(signer != _signer);\\n        signer = _signer;\\n        emit NewSigner(_signer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBlockHistory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Block history provider\\n * @author Theori, Inc.\\n * @notice IBlockHistory provides a way to verify a blockhash\\n */\\n\\ninterface IBlockHistory {\\n    /**\\n     * @notice Determine if the given hash corresponds to the given block\\n     * @param hash the hash if the block in question\\n     * @param num the number of the block in question\\n     * @param proof any witness data required to prove the block hash is\\n     *        correct (such as a Merkle or SNARK proof)\\n     * @return boolean indicating if the block hash can be verified correct\\n     */\\n    function validBlockHash(\\n        bytes32 hash,\\n        uint256 num,\\n        bytes calldata proof\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRecursiveVerifier.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport {RecursiveProof} from \\\"../lib/Proofs.sol\\\";\\n\\n/**\\n * @title Verifier of zk-SNARK proofs\\n * @author Theori, Inc.\\n * @notice Provider of validity checking of zk-SNARKs\\n */\\ninterface IRecursiveVerifier {\\n    /**\\n     * @notice Checks the validity of SNARK data\\n     * @param proof the proof to verify\\n     * @return the validity of the proof\\n     */\\n    function verify(RecursiveProof calldata proof) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/CoreTypes.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./RLP.sol\\\";\\n\\n/**\\n * @title CoreTypes\\n * @author Theori, Inc.\\n * @notice Data types and parsing functions for core types, including block headers\\n *         and account data.\\n */\\nlibrary CoreTypes {\\n    struct BlockHeaderData {\\n        bytes32 ParentHash;\\n        bytes32 Root;\\n        bytes32 TxHash;\\n        bytes32 ReceiptHash;\\n        uint256 Number;\\n        uint256 Time;\\n        uint256 BaseFee;\\n    }\\n\\n    struct AccountData {\\n        uint256 Nonce;\\n        uint256 Balance;\\n        bytes32 StorageRoot;\\n        bytes32 CodeHash;\\n    }\\n\\n    function parseHash(bytes calldata buf) internal pure returns (bytes32 result, uint256 offset) {\\n        uint256 value;\\n        (value, offset) = RLP.parseUint(buf);\\n        result = bytes32(value);\\n    }\\n\\n    function parseBlockHeader(bytes calldata header)\\n        internal\\n        pure\\n        returns (BlockHeaderData memory data)\\n    {\\n        (uint256 listSize, uint256 offset) = RLP.parseList(header);\\n        header = header[offset:offset + listSize];\\n\\n        (data.ParentHash, offset) = parseHash(header); // ParentHash\\n        header = header[offset:];\\n        offset = RLP.skip(header); // UncleHash\\n        header = header[offset:];\\n        offset = RLP.skip(header); // Coinbase\\n        header = header[offset:];\\n        (data.Root, offset) = parseHash(header); // Root\\n        header = header[offset:];\\n        (data.TxHash, offset) = parseHash(header); // TxHash\\n        header = header[offset:];\\n        (data.ReceiptHash, offset) = parseHash(header); // ReceiptHash\\n        header = header[offset:];\\n        offset = RLP.skip(header); // Bloom\\n        header = header[offset:];\\n        offset = RLP.skip(header); // Difficulty\\n        header = header[offset:];\\n        (data.Number, offset) = RLP.parseUint(header); // Number\\n        header = header[offset:];\\n        offset = RLP.skip(header); // GasLimit\\n        header = header[offset:];\\n        offset = RLP.skip(header); // GasUsed\\n        header = header[offset:];\\n        (data.Time, offset) = RLP.parseUint(header); // Time\\n        header = header[offset:];\\n        offset = RLP.skip(header); // Extra\\n        header = header[offset:];\\n        offset = RLP.skip(header); // MixDigest\\n        header = header[offset:];\\n        offset = RLP.skip(header); // Nonce\\n        header = header[offset:];\\n\\n        if (header.length > 0) {\\n            (data.BaseFee, offset) = RLP.parseUint(header); // BaseFee\\n            header = header[offset:];\\n        }\\n    }\\n\\n    function getBlockHeaderHashAndSize(bytes calldata header)\\n        internal\\n        pure\\n        returns (bytes32 blockHash, uint256 headerSize)\\n    {\\n        (uint256 listSize, uint256 offset) = RLP.parseList(header);\\n        headerSize = offset + listSize;\\n        blockHash = keccak256(header[0:headerSize]);\\n    }\\n\\n    function parseAccount(bytes calldata account) internal pure returns (AccountData memory data) {\\n        (, uint256 offset) = RLP.parseList(account);\\n        account = account[offset:];\\n\\n        (data.Nonce, offset) = RLP.parseUint(account); // Nonce\\n        account = account[offset:];\\n        (data.Balance, offset) = RLP.parseUint(account); // Balance\\n        account = account[offset:];\\n        (data.StorageRoot, offset) = parseHash(account); // StorageRoot\\n        account = account[offset:];\\n        (data.CodeHash, offset) = parseHash(account); // CodeHash\\n        account = account[offset:];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MerkleTree.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Merkle Tree\\n * @author Theori, Inc.\\n * @notice Gas optimized SHA256 Merkle tree code.\\n */\\nlibrary MerkleTree {\\n    /**\\n     * @notice computes a SHA256 merkle root of the provided hashes, in place\\n     * @param temp the mutable array of hashes\\n     * @return the merkle root hash\\n     */\\n    function computeRoot(bytes32[] memory temp) internal view returns (bytes32) {\\n        uint256 count = temp.length;\\n        assembly {\\n            // repeat until we arrive at one root hash\\n            for {\\n\\n            } gt(count, 1) {\\n\\n            } {\\n                let dataElementLocation := add(temp, 0x20)\\n                let hashElementLocation := add(temp, 0x20)\\n                for {\\n                    let i := 0\\n                } lt(i, count) {\\n                    i := add(i, 2)\\n                } {\\n                    if iszero(\\n                        staticcall(gas(), 0x2, hashElementLocation, 0x40, dataElementLocation, 0x20)\\n                    ) {\\n                        revert(0, 0)\\n                    }\\n                    dataElementLocation := add(dataElementLocation, 0x20)\\n                    hashElementLocation := add(hashElementLocation, 0x40)\\n                }\\n                count := shr(1, count)\\n            }\\n        }\\n        return temp[0];\\n    }\\n\\n    /**\\n     * @notice check if a hash is in the merkle tree for rootHash\\n     * @param rootHash the merkle root\\n     * @param index the index of the node to check\\n     * @param hash the hash to check\\n     * @param proofHashes the proof, i.e. the sequence of siblings from the\\n     *        node to root\\n     */\\n    function validProof(\\n        bytes32 rootHash,\\n        uint256 index,\\n        bytes32 hash,\\n        bytes32[] memory proofHashes\\n    ) internal view returns (bool result) {\\n        assembly {\\n            let constructedHash := hash\\n            let length := mload(proofHashes)\\n            let start := add(proofHashes, 0x20)\\n            let end := add(start, mul(length, 0x20))\\n            for {\\n                let ptr := start\\n            } lt(ptr, end) {\\n                ptr := add(ptr, 0x20)\\n            } {\\n                let proofHash := mload(ptr)\\n\\n                // use scratch space (0x0 - 0x40) for hash input\\n                switch and(index, 1)\\n                case 0 {\\n                    mstore(0x0, constructedHash)\\n                    mstore(0x20, proofHash)\\n                }\\n                case 1 {\\n                    mstore(0x0, proofHash)\\n                    mstore(0x20, constructedHash)\\n                }\\n\\n                // compute sha256\\n                if iszero(staticcall(gas(), 0x2, 0x0, 0x40, 0x0, 0x20)) {\\n                    revert(0, 0)\\n                }\\n                constructedHash := mload(0x0)\\n\\n                index := shr(1, index)\\n            }\\n            result := eq(constructedHash, rootHash)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Proofs.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\n/*\\n * @author Theori, Inc.\\n */\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nuint256 constant BASE_PROOF_SIZE = 34;\\nuint256 constant SUBPROOF_LIMBS_SIZE = 16;\\n\\nstruct RecursiveProof {\\n    uint256[BASE_PROOF_SIZE] base;\\n    uint256[SUBPROOF_LIMBS_SIZE] subproofLimbs;\\n    uint256[] inputs;\\n}\\n\\nstruct SignedRecursiveProof {\\n    RecursiveProof inner;\\n    bytes signature;\\n}\\n\\n/**\\n * @notice recover the signer of the proof\\n * @param proof the SignedRecursiveProof\\n * @return the address of the signer\\n */\\nfunction getProofSigner(SignedRecursiveProof calldata proof) pure returns (address) {\\n    bytes32 msgHash = keccak256(\\n        abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", \\\"32\\\", hashProof(proof.inner))\\n    );\\n    return ECDSA.recover(msgHash, proof.signature);\\n}\\n\\n/**\\n * @notice hash the contents of a RecursiveProof\\n * @param proof the RecursiveProof\\n * @return result a 32-byte digest of the proof\\n */\\nfunction hashProof(RecursiveProof calldata proof) pure returns (bytes32 result) {\\n    uint256[] calldata inputs = proof.inputs;\\n    assembly {\\n        let ptr := mload(0x40)\\n        let contigLen := mul(0x20, add(BASE_PROOF_SIZE, SUBPROOF_LIMBS_SIZE))\\n        let inputsLen := mul(0x20, inputs.length)\\n        calldatacopy(ptr, proof, contigLen)\\n        calldatacopy(add(ptr, contigLen), inputs.offset, inputsLen)\\n        result := keccak256(ptr, add(contigLen, inputsLen))\\n    }\\n}\\n\\n/**\\n * @notice reverse the byte order of a uint256\\n * @param input the input value\\n * @return v the byte-order reversed value\\n */\\nfunction byteReverse(uint256 input) pure returns (uint256 v) {\\n    v = input;\\n\\n    uint256 MASK08 = 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\\n    uint256 MASK16 = 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000;\\n    uint256 MASK32 = 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000;\\n    uint256 MASK64 = 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000;\\n\\n    // swap bytes\\n    v = ((v & MASK08) >> 8) | ((v & (~MASK08)) << 8);\\n\\n    // swap 2-byte long pairs\\n    v = ((v & MASK16) >> 16) | ((v & (~MASK16)) << 16);\\n\\n    // swap 4-byte long pairs\\n    v = ((v & MASK32) >> 32) | ((v & (~MASK32)) << 32);\\n\\n    // swap 8-byte long pairs\\n    v = ((v & MASK64) >> 64) | ((v & (~MASK64)) << 64);\\n\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n}\\n\\n/**\\n * @notice reads a 32-byte hash from its little-endian word-encoded form\\n * @param words the hash words\\n * @return the hash\\n */\\nfunction readHashWords(uint256[] calldata words) pure returns (bytes32) {\\n    uint256 mask = 0xffffffffffffffff;\\n    uint256 result = (words[0] & mask);\\n    result |= (words[1] & mask) << 0x40;\\n    result |= (words[2] & mask) << 0x80;\\n    result |= (words[3] & mask) << 0xc0;\\n    return bytes32(byteReverse(result));\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RLP.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n/// (c) Theori, Inc. 2022\\n/// All rights reserved\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title RLP\\n * @author Theori, Inc.\\n * @notice Gas optimized RLP parsing code. Note that some parsing logic is\\n *         duplicated because helper functions are oddly expensive.\\n */\\nlibrary RLP {\\n    function parseUint(bytes calldata buf) internal pure returns (uint256 result, uint256 size) {\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a not a long string or list (> 0xB7)\\n            // also ensure it's not a short string longer than 32 bytes (> 0xA0)\\n            if gt(kind, 0xA0) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                result := kind\\n                size := 1\\n            }\\n            case false {\\n                // short string\\n                size := sub(kind, 0x80)\\n\\n                // ensure it's not reading out of bounds\\n                if lt(buf.length, size) {\\n                    revert(0, 0)\\n                }\\n\\n                switch eq(size, 32)\\n                case true {\\n                    // if it's exactly 32 bytes, read it from calldata\\n                    result := calldataload(add(buf.offset, 1))\\n                }\\n                case false {\\n                    // if it's < 32 bytes, we've already read it from calldata\\n                    result := shr(shl(3, sub(32, size)), shl(8, first32))\\n                }\\n                size := add(size, 1)\\n            }\\n        }\\n    }\\n\\n    function skip(bytes calldata buf) internal pure returns (uint256 size) {\\n        assembly {\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                size := 1\\n            }\\n            case false {\\n                switch lt(kind, 0xB8)\\n                case true {\\n                    // short string\\n                    size := add(1, sub(kind, 0x80))\\n                }\\n                case false {\\n                    switch lt(kind, 0xC0)\\n                    case true {\\n                        // long string\\n                        let lengthSize := sub(kind, 0xB7)\\n\\n                        // ensure that we don't overflow\\n                        if gt(lengthSize, 31) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // ensure that we don't read out of bounds\\n                        if lt(buf.length, lengthSize) {\\n                            revert(0, 0)\\n                        }\\n                        size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                        size := add(size, add(1, lengthSize))\\n                    }\\n                    case false {\\n                        switch lt(kind, 0xF8)\\n                        case true {\\n                            // short list\\n                            size := add(1, sub(kind, 0xC0))\\n                        }\\n                        case false {\\n                            let lengthSize := sub(kind, 0xB7)\\n\\n                            // ensure that we don't overflow\\n                            if gt(lengthSize, 31) {\\n                                revert(0, 0)\\n                            }\\n                            // ensure that we don't read out of bounds\\n                            if lt(buf.length, lengthSize) {\\n                                revert(0, 0)\\n                            }\\n                            size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                            size := add(size, add(1, lengthSize))\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function parseList(bytes calldata buf)\\n        internal\\n        pure\\n        returns (uint256 listSize, uint256 offset)\\n    {\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a list\\n            if lt(kind, 0xC0) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0xF8)\\n            case true {\\n                // short list\\n                listSize := sub(kind, 0xC0)\\n                offset := 1\\n            }\\n            case false {\\n                // long list\\n                let lengthSize := sub(kind, 0xF7)\\n\\n                // ensure that we don't overflow\\n                if gt(lengthSize, 31) {\\n                    revert(0, 0)\\n                }\\n                // ensure that we don't read out of bounds\\n                if lt(buf.length, lengthSize) {\\n                    revert(0, 0)\\n                }\\n                listSize := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                offset := add(lengthSize, 1)\\n            }\\n        }\\n    }\\n\\n    function splitBytes(bytes calldata buf)\\n        internal\\n        pure\\n        returns (bytes calldata result, bytes calldata rest)\\n    {\\n        uint256 offset;\\n        uint256 size;\\n        assembly {\\n            // check that we have at least one byte of input\\n            if iszero(buf.length) {\\n                revert(0, 0)\\n            }\\n            let first32 := calldataload(buf.offset)\\n            let kind := shr(248, first32)\\n\\n            // ensure it's a not list\\n            if gt(kind, 0xBF) {\\n                revert(0, 0)\\n            }\\n\\n            switch lt(kind, 0x80)\\n            case true {\\n                // small single byte\\n                offset := 0\\n                size := 1\\n            }\\n            case false {\\n                switch lt(kind, 0xB8)\\n                case true {\\n                    // short string\\n                    offset := 1\\n                    size := sub(kind, 0x80)\\n                }\\n                case false {\\n                    // long string\\n                    let lengthSize := sub(kind, 0xB7)\\n\\n                    // ensure that we don't overflow\\n                    if gt(lengthSize, 31) {\\n                        revert(0, 0)\\n                    }\\n                    // ensure we don't read out of bounds\\n                    if lt(buf.length, lengthSize) {\\n                        revert(0, 0)\\n                    }\\n                    size := shr(mul(8, sub(32, lengthSize)), shl(8, first32))\\n                    offset := add(lengthSize, 1)\\n                }\\n            }\\n        }\\n        unchecked {\\n            result = buf[offset:offset + size];\\n            rest = buf[offset + size:];\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sizes\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IRecursiveVerifier[]\",\"name\":\"_verifiers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_reliquary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"ImportMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"NewSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"earliestRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256[34]\",\"name\":\"base\",\"type\":\"uint256[34]\"},{\"internalType\":\"uint256[16]\",\"name\":\"subproofLimbs\",\"type\":\"uint256[16]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct RecursiveProof\",\"name\":\"inner\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedRecursiveProof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"roots\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"connectProof\",\"type\":\"bytes\"}],\"name\":\"importLast\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256[34]\",\"name\":\"base\",\"type\":\"uint256[34]\"},{\"internalType\":\"uint256[16]\",\"name\":\"subproofLimbs\",\"type\":\"uint256[16]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"internalType\":\"struct RecursiveProof\",\"name\":\"inner\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedRecursiveProof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"roots\",\"type\":\"bytes32[]\"}],\"name\":\"importParent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reliquary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"validBlockHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"verifiers\",\"outputs\":[{\"internalType\":\"contract IRecursiveVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BlockHistory", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002600000000000000000000000005e4de6bb8c6824f29c44bd3473d44da120387d08000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000ddfe1c162c5e507d43ebbd33aa73d4816452cb630000000000000000000000000658fa86719296ebd99fce1c4b452fbe1893ebe800000000000000000000000050a182d5d035f38ff221cd91e08c35c076af3b98000000000000000000000000ca99e631fda41e410b501e476a0b6987951f833d000000000000000000000000d010389898a11d116fab497891a5d4a5d7a76d4c0000000000000000000000002af85a39f7dcf94e5d4b597d4cd197901883f98f00000000000000000000000044395a78883b431053b444643f360efce9a464cc000000000000000000000000a8d216ada8446554b50b8e85ae6f4fe38f54366a0000000000000000000000005f6ea631725280c662d2aa2c9b39d9855aaffa98000000000000000000000000ebe3397bd9fc488d8d1b03d550a23a855debd84800000000000000000000000086fa21ad0b1beb70b5e3a65d928ec959aeab9a99000000000000000000000000463ebd89bb1f76a6296235c3e3e103528ef75425000000000000000000000000c0a9cd8725ae983d9303bf6b50821cbc2244fb90000000000000000000000000f73d4688120ba536ce7b6324b4fa1c79f140b634000000000000000000000000d1d80460cd6aa1fa674ea549f27fbb50b1dba9d4", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}