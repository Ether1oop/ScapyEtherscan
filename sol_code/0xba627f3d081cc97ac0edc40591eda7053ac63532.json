{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BoredAndDangerous.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {ERC2981} from \\\"openzeppelin-contracts/contracts/token/common/ERC2981.sol\\\";\\nimport {MerkleProof} from \\\"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport {Strings} from \\\"openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\n\\n\\ninterface IERC721 {\\n    function ownerOf(uint tokenId) external view returns (address);\\n}\\n\\n\\ncontract BoredAndDangerous is ERC721, ERC2981 {\\n    /// @notice The original writer's room contract\\n    address public constant WRITERS_ROOM = 0x880644ddF208E471C6f2230d31f9027578FA6FcC;\\n\\n    /// @notice The grace period for refund claiming\\n    uint public constant DUTCH_AUCTION_GRACE_PERIOD = 12 hours;\\n    /// @notice The mint cap in the dutch auction\\n    uint public constant DUTCH_AUCTION_MINT_CAP = 2;\\n    /// @notice The first token id that dutch auction minters will receive, inclusive\\n    uint public immutable DUTCH_AUCTION_START_ID;\\n    /// @notice The last token id that dutch auction minters will receive, inclusive\\n    uint public immutable DUTCH_AUCTION_END_ID;\\n\\n    /// @notice The price for writelist mints\\n    uint public writelistPrice;\\n\\n    /// @notice The address which can admin mint for free, set merkle roots, and set auction params\\n    address public mintingOwner;\\n    /// @notice The address which can update the metadata uri\\n    address public metadataOwner;\\n    /// @notice The address which will be returned for the ERC721 owner() standard for setting royalties\\n    address public royaltyOwner;\\n\\n    /// @notice Records the price and time when the final dutch auction token sells out\\n    struct DutchAuctionFinalization {\\n        uint128 price;\\n        uint128 time;\\n    }\\n    /// @notice The instantiation of the dutch auction finalization struct\\n    DutchAuctionFinalization public dutchEnd;\\n\\n    /// @notice The token id which will be minted next in the dutch auction\\n    uint public dutchAuctionNextId;\\n    /// @notice The token id which will be minted next in the writelist mint\\n    uint public writelistMintNextId;\\n\\n    /// @notice Records whether a whitelist allocation has been started, and how many are remaining to claim\\n    struct Writelist {\\n        uint128 remaining;\\n        bool used;\\n    }\\n\\n    /// @notice Whether free mints for writers' room holders are open\\n    bool public writelistMintWritersRoomFreeOpen;\\n\\n    /// @notice Whether paid mints for writers' room holders are open\\n    bool public writelistMintWritersRoomOpen;\\n\\n    /// @notice Construct this from (address, amount) tuple elements\\n    bytes32 public giveawayMerkleRoot;\\n    /// @notice Caches writelist allocations once they've been used\\n    mapping(address => Writelist) public giveawayWritelist;\\n\\n    /// @notice Construct this from (address, tokenId) tuple elements\\n    bytes32 public apeMerkleRoot;\\n    /// @notice Maps (address, tokenId) hash to bool, true if token has minted\\n    mapping(bytes32 => bool) public apeWritelistUsed;\\n\\n    /// @notice Maps tokenId to bool, true if token has minted\\n    mapping(uint => bool) public writersroomWritelistUsed;\\n\\n    /// @notice Total number of tokens which have minted\\n    uint public totalSupply = 0;\\n\\n    /// @notice The prefix to attach to the tokenId to get the metadata uri\\n    string public baseTokenURI;\\n\\n    /// @notice Struct is packed to fit within a single 256-bit slot\\n    struct DutchAuctionMintHistory {\\n        uint128 amount;\\n        uint128 price;\\n    }\\n    /// @notice Store the mint history for an individual address. Used to issue refunds\\n    mapping(address => DutchAuctionMintHistory) public mintHistory;\\n\\n    /// @notice Struct is packed to fit within a single 256-bit slot\\n    /// @dev uint64 has max value 1.8e19, or 18 ether\\n    /// @dev uint32 has max value 4.2e9, which corresponds to max timestamp of year 2106\\n    struct DutchAuctionParams {\\n        uint64 startPrice;\\n        uint64 endPrice;\\n        uint64 priceIncrement;\\n        uint32 startTime;\\n        uint32 timeIncrement;\\n    }\\n    /// @notice The instantiation of dutch auction parameters\\n    DutchAuctionParams public params;\\n\\n    /// @notice Emitted when a token is minted\\n    event Mint(address indexed owner, uint indexed tokenId);\\n    /// @notice Emitted when an accounts receives its dutch auction refund\\n    event DutchAuctionRefund(address indexed account);\\n\\n    /// @notice Raised when an unauthorized user calls a gated function\\n    error AccessControl();\\n    /// @notice Raised when a non-EOA account calls a gated function\\n    error OnlyEOA(address msgSender);\\n    /// @notice Raised when a user exceeds their mint cap\\n    error ExceededUserMintCap();\\n    /// @notice Raised when the mint has not reached the required timestamp\\n    error MintNotOpen();\\n    /// @notice Raised when the user attempts to writelist mint on behalf of a token they do not own\\n    error DoesNotOwnToken(uint tokenId);\\n    /// @notice Raised when the user attempts to mint after the dutch auction finishes\\n    error DutchAuctionOver();\\n    /// @notice Raised when the admin attempts to withdraw funds before the dutch auction grace period has ended\\n    error DutchAuctionGracePeriod(uint endPrice, uint endTime);\\n    /// @notice Raised when a user attempts to claim their dutch auction refund before the dutch auction ends\\n    error DutchAuctionNotOver();\\n    /// @notice Raised when the admin attempts to mint within the dutch auction range while the auction is still ongoing\\n    error DutchAuctionNotOverAdmin();\\n    /// @notice Raised when the admin attempts to set dutch auction parameters that don't make sense\\n    error DutchAuctionBadParamsAdmin();\\n    /// @notice Raised when `sender` does not pass the proper ether amount to `recipient`\\n    error FailedToSendEther(address sender, address recipient);\\n    /// @notice Raised when a user tries to writelist mint twice\\n    error WritelistUsed();\\n    /// @notice Raised when two calldata arrays do not have the same length\\n    error MismatchedArrays();\\n    /// @notice Raised when the user attempts to mint zero items\\n    error MintZero();\\n\\n    constructor(uint _DUTCH_AUCTION_START_ID, uint _DUTCH_AUCTION_END_ID) ERC721(\\\"Bored & Dangerous\\\", \\\"BOOK\\\") {\\n        DUTCH_AUCTION_START_ID = _DUTCH_AUCTION_START_ID;\\n        DUTCH_AUCTION_END_ID = _DUTCH_AUCTION_END_ID;\\n        dutchAuctionNextId = _DUTCH_AUCTION_START_ID;\\n        writelistMintNextId = _DUTCH_AUCTION_END_ID + 1;\\n        mintingOwner = msg.sender;\\n        metadataOwner = msg.sender;\\n        royaltyOwner = msg.sender;\\n    }\\n\\n    /// @notice Admin mint a token\\n    function ownerMint(address recipient, uint tokenId) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n\\n        if (DUTCH_AUCTION_START_ID <= tokenId && tokenId <= DUTCH_AUCTION_END_ID) {\\n            revert DutchAuctionNotOverAdmin();\\n        }\\n\\n        unchecked {\\n            ++totalSupply;\\n        }\\n        _mint(recipient, tokenId);\\n    }\\n\\n    /// @notice Admin mint a batch of tokens\\n    function ownerMintBatch(address[] calldata recipients, uint[] calldata tokenIds) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        \\n        if (recipients.length != tokenIds.length) {\\n            revert MismatchedArrays();\\n        }\\n\\n        unchecked {\\n            totalSupply += tokenIds.length;\\n            for (uint i = 0; i < tokenIds.length; ++i) {\\n                if (DUTCH_AUCTION_START_ID <= tokenIds[i] && tokenIds[i] <= DUTCH_AUCTION_END_ID) {\\n                    revert DutchAuctionNotOverAdmin();\\n                }\\n                _mint(recipients[i], tokenIds[i]);\\n            }\\n        }\\n    }\\n    \\n    ///////////////////\\n    // DUTCH AUCTION //\\n    ///////////////////\\n\\n    /// @notice The current dutch auction price\\n    /// @dev Reverts if dutch auction has not started yet\\n    /// @dev Returns the end price even if the dutch auction has sold out\\n    function dutchAuctionPrice() public view returns (uint) {\\n        DutchAuctionParams memory _params = params;\\n        uint numIncrements = (block.timestamp - _params.startTime) / _params.timeIncrement;\\n        uint price = _params.startPrice - numIncrements * _params.priceIncrement;\\n        if (price < _params.endPrice) {\\n            price = _params.endPrice;\\n        }\\n        return price;\\n    }\\n\\n    /// @notice Dutch auction with refunds\\n    /// @param amount The number of NFTs to mint, either 1 or 2\\n    function dutchAuctionMint(uint amount) external payable {\\n        // Enforce EOA mints\\n        _onlyEOA(msg.sender);\\n\\n        if (amount == 0) {\\n            revert MintZero();\\n        }\\n\\n        DutchAuctionMintHistory memory userMintHistory = mintHistory[msg.sender];\\n\\n        // Enforce per-account mint cap\\n        if (userMintHistory.amount + amount > DUTCH_AUCTION_MINT_CAP) {\\n            revert ExceededUserMintCap();\\n        }\\n\\n\\t    uint256 _dutchAuctionNextId = dutchAuctionNextId;\\n        // Enforce global mint cap\\n        if (_dutchAuctionNextId + amount > DUTCH_AUCTION_END_ID + 1) {\\n            revert DutchAuctionOver();\\n        }\\n\\n        DutchAuctionParams memory _params = params;\\n\\n        // Enforce timing\\n        if (block.timestamp < _params.startTime || _params.startPrice == 0) {\\n            revert MintNotOpen();\\n        }\\n        \\n        // Calculate dutch auction price\\n        uint numIncrements = (block.timestamp - _params.startTime) / _params.timeIncrement;\\n        uint price = _params.startPrice - numIncrements * _params.priceIncrement;\\n        if (price < _params.endPrice) {\\n            price = _params.endPrice;\\n        }\\n\\n        // Check mint price\\n        if (msg.value != amount * price) {\\n            revert FailedToSendEther(msg.sender, address(this));\\n        }\\n        unchecked {\\n            uint128 newPrice = (userMintHistory.amount * userMintHistory.price + uint128(amount * price)) / uint128(userMintHistory.amount + amount);\\n            mintHistory[msg.sender] = DutchAuctionMintHistory({\\n                amount: userMintHistory.amount + uint128(amount),\\n                price: newPrice\\n            });\\n            for (uint i = 0; i < amount; ++i) {\\n                _mint(msg.sender, _dutchAuctionNextId++);\\n            }\\n            totalSupply += amount;\\n            if (_dutchAuctionNextId > DUTCH_AUCTION_END_ID) {\\n                dutchEnd = DutchAuctionFinalization({\\n                    price: uint128(price),\\n                    time: uint128(block.timestamp)\\n                });\\n            }\\n\\t        dutchAuctionNextId = _dutchAuctionNextId;\\n        }\\n    }\\n\\n    /// @notice Provide dutch auction refunds to people who minted early\\n    /// @dev Deliberately left unguarded so users can either claim their own, or batch refund others\\n    function claimDutchAuctionRefund(address[] calldata accounts) external {\\n        // Check if dutch auction over\\n        if (dutchEnd.price == 0) {\\n            revert DutchAuctionNotOver();\\n        }\\n        for (uint i = 0; i < accounts.length; ++i) {\\n            address account = accounts[i];\\n            DutchAuctionMintHistory memory mint = mintHistory[account];\\n            // If an account has already been refunded, skip instead of reverting\\n            // This prevents griefing attacks when performing batch refunds\\n            if (mint.price > 0) {\\n                uint refundAmount = mint.amount * (mint.price - dutchEnd.price);\\n                delete mintHistory[account];\\n                (bool sent,) = account.call{value: refundAmount}(\\\"\\\");\\n                // Revert if the address has a malicious receive function\\n                // This is not a griefing vector because the function can be retried\\n                // without the failing recipient\\n                if (!sent) {\\n                    revert FailedToSendEther(address(this), account);\\n                }\\n            }\\n        }\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\\n    // WRITELIST MINTS (free writer's room, paid writer's room, paid bored/mutant ape, paid giveaway) //\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Free mint from writelist ticket allocation\\n    function writelistMintWritersRoomFree(uint[] calldata tokenIds) external {\\n        if (!writelistMintWritersRoomFreeOpen) {\\n            revert MintNotOpen();\\n        }\\n        for (uint i = 0; i < tokenIds.length; ++i) {\\n            address tokenOwner = IERC721(WRITERS_ROOM).ownerOf(tokenIds[i]);\\n            // This will revert is specific tokenId already minted\\n            _mint(tokenOwner, tokenIds[i]);\\n        }\\n        totalSupply += tokenIds.length;\\n    }\\n\\n    /// @notice Paid mint for a writer's room NFT\\n    function writelistMintWritersRoom(uint[] calldata tokenIds) external payable {\\n        if (!writelistMintWritersRoomOpen) {\\n            revert MintNotOpen();\\n        }\\n        // Check payment\\n        if (msg.value != tokenIds.length * writelistPrice) {\\n            revert FailedToSendEther(msg.sender, address(this));\\n        }\\n\\n        for (uint i = 0; i < tokenIds.length; ++i) {\\n            if (writersroomWritelistUsed[tokenIds[i]]) {\\n                revert WritelistUsed();\\n            }\\n            writersroomWritelistUsed[tokenIds[i]] = true;\\n            address tokenOwner = IERC721(WRITERS_ROOM).ownerOf(tokenIds[i]);\\n            _mint(tokenOwner, writelistMintNextId++);\\n        }\\n        totalSupply += tokenIds.length;\\n    }\\n\\n    /// @notice Mint for a licensed bored ape or mutant ape\\n    function writelistMintApes(address tokenContract, uint tokenId, bytes32 leaf, bytes32[] calldata proof) external payable {\\n        // Check payment\\n        if (msg.value != writelistPrice) {\\n            revert FailedToSendEther(msg.sender, address(this));\\n        }\\n        \\n        bytes32 tokenHash = keccak256(abi.encodePacked(tokenContract, tokenId));\\n        \\n        // Create storage element tracking user mints if this is the first mint for them\\n        if (apeWritelistUsed[tokenHash]) {\\n            revert WritelistUsed();\\n        }\\n        // Verify that (tokenContract, tokenId) correspond to Merkle leaf\\n        require(tokenHash == leaf, \\\"Token contract and id don't match Merkle leaf\\\");\\n\\n        // Verify that (leaf, proof) matches the Merkle root\\n        require(verify(apeMerkleRoot, leaf, proof), \\\"Not a valid leaf in the Merkle tree\\\");\\n\\n        // Get the current tokenOwner and mint to them\\n        address tokenOwner = IERC721(tokenContract).ownerOf(tokenId);\\n\\n        apeWritelistUsed[tokenHash] = true;\\n        ++totalSupply;\\n\\n        _mint(tokenOwner, writelistMintNextId++);\\n    }\\n\\n    /// @notice Mint from writelist allocation\\n    function writelistMintGiveaway(address tokenOwner, uint8 amount, uint8 totalAllocation, bytes32 leaf, bytes32[] memory proof) external payable {\\n        // Check payment\\n        if (msg.value != amount * writelistPrice) {\\n            revert FailedToSendEther(msg.sender, address(this));\\n        }\\n\\n        Writelist memory writelist = giveawayWritelist[tokenOwner];\\n        \\n        // Create storage element tracking user mints if this is the first mint for them\\n        if (!writelist.used) {    \\n            // Verify that (tokenOwner, amount) correspond to Merkle leaf\\n            require(keccak256(abi.encodePacked(tokenOwner, totalAllocation)) == leaf, \\\"Sender and amount don't match Merkle leaf\\\");\\n\\n            // Verify that (leaf, proof) matches the Merkle root\\n            require(verify(giveawayMerkleRoot, leaf, proof), \\\"Not a valid leaf in the Merkle tree\\\");\\n\\n            writelist.used = true;\\n            // Save some gas by never writing to this slot if it will be reset to zero at method end\\n            if (amount != totalAllocation) {\\n                writelist.remaining = totalAllocation - amount;\\n            }\\n        }\\n        else {\\n            writelist.remaining -= amount;\\n        }\\n\\n        giveawayWritelist[tokenOwner] = writelist;\\n        totalSupply += amount;\\n        for (uint i = 0; i < amount; ++i) {\\n            _mint(tokenOwner, writelistMintNextId++);\\n        }\\n    }\\n\\n    /// @notice Ensure the proof and leaf match the merkle root\\n    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\\n        return MerkleProof.verify(proof, root, leaf);\\n    }\\n\\n    /////////////////////////\\n    // ADMIN FUNCTIONALITY //\\n    /////////////////////////\\n\\n    /// @notice Set metadata\\n    function setBaseTokenURI(string memory _baseTokenURI) external {\\n        if (msg.sender != metadataOwner) {\\n            revert AccessControl();\\n        }\\n        baseTokenURI = _baseTokenURI;\\n    }\\n\\n    /// @notice Set merkle root\\n    function setGiveawayMerkleRoot(bytes32 _giveawayMerkleRoot) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        giveawayMerkleRoot = _giveawayMerkleRoot;\\n    }\\n\\n    /// @notice Set merkle root\\n    function setApeMerkleRoot(bytes32 _apeMerkleRoot) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        apeMerkleRoot = _apeMerkleRoot;\\n    }\\n\\n    /// @notice Set parameters\\n    function setDutchAuctionStruct(DutchAuctionParams calldata _params) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        if (!(_params.startPrice >= _params.endPrice && _params.endPrice > 0 && _params.startTime > 0 && _params.timeIncrement > 0)) {\\n            revert DutchAuctionBadParamsAdmin();\\n        }\\n        params = DutchAuctionParams({\\n            startPrice: _params.startPrice,\\n            endPrice: _params.endPrice,\\n            priceIncrement: _params.priceIncrement,\\n            startTime: _params.startTime,\\n            timeIncrement: _params.timeIncrement\\n        });\\n    }\\n\\n    /// @notice Set writelistMintNextId\\n    /// @dev Should not be used, but failsafe in case the admin accidentally mints a token id in the writelist range too early\\n    function setWritelistMintNextId(uint _writelistMintNextId) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        writelistMintNextId = _writelistMintNextId;\\n    }\\n\\n    /// @notice Set writelistMintWritersRoomFreeOpen\\n    function setWritelistMintWritersRoomFreeOpen(bool _value) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        writelistMintWritersRoomFreeOpen = _value;\\n    }\\n\\n    /// @notice Set writelistMintWritersRoomOpen\\n    function setWritelistMintWritersRoomOpen(bool _value) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        writelistMintWritersRoomOpen = _value;\\n    }\\n\\n    /// @notice Set writelistPrice\\n    function setWritelistPrice(uint _price) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        writelistPrice = _price;\\n    }\\n\\n    /// @notice Claim funds\\n    function claimFunds(address payable recipient) external {\\n        if (!(msg.sender == mintingOwner || msg.sender == metadataOwner || msg.sender == royaltyOwner)) {\\n            revert AccessControl();\\n        }\\n\\n        // Wait for the grace period after scheduled end to allow claiming of dutch auction refunds\\n        if (!(dutchEnd.price > 0 && block.timestamp >= dutchEnd.time + DUTCH_AUCTION_GRACE_PERIOD)) {\\n            revert DutchAuctionGracePeriod(dutchEnd.price, dutchEnd.time);\\n        }\\n\\n        (bool sent,) = recipient.call{value: address(this).balance}(\\\"\\\");\\n        if (!sent) {\\n            revert FailedToSendEther(address(this), recipient);\\n        }\\n    }\\n\\n    ////////////////////////////////////\\n    // ACCESS CONTROL ADDRESS UPDATES //\\n    ////////////////////////////////////\\n\\n    /// @notice Update the mintingOwner\\n    /// @dev Can also be used to revoke this power by setting to 0x0\\n    function setMintingOwner(address _mintingOwner) external {\\n        if (msg.sender != mintingOwner) {\\n            revert AccessControl();\\n        }\\n        mintingOwner = _mintingOwner;\\n    }\\n\\n    /// @notice Update the metadataOwner\\n    /// @dev Can also be used to revoke this power by setting to 0x0\\n    /// @dev Should only be revoked after setting an IPFS url so others can pin\\n    function setMetadataOwner(address _metadataOwner) external {\\n        if (msg.sender != metadataOwner) {\\n            revert AccessControl();\\n        }\\n        metadataOwner = _metadataOwner;\\n    }\\n\\n    /// @notice Update the royaltyOwner\\n    /// @dev Can also be used to revoke this power by setting to 0x0\\n    function setRoyaltyOwner(address _royaltyOwner) external {\\n        if (msg.sender != royaltyOwner) {\\n            revert AccessControl();\\n        }\\n        royaltyOwner = _royaltyOwner;\\n    }\\n\\n    /// @notice The address which can set royalties\\n    function owner() external view returns (address) {\\n        return royaltyOwner;\\n    }\\n\\n    // ROYALTY FUNCTIONALITY\\n\\n    /// @dev See {IERC165-supportsInterface}.\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC2981) returns (bool) {\\n        return\\n            interfaceId == 0x2a55205a || // ERC165 Interface ID for ERC2981\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /// @dev See {ERC2981-_setDefaultRoyalty}.\\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external {\\n        if (msg.sender != royaltyOwner) {\\n            revert AccessControl();\\n        }\\n        _setDefaultRoyalty(receiver, feeNumerator);\\n    }\\n\\n    /// @dev See {ERC2981-_deleteDefaultRoyalty}.\\n    function deleteDefaultRoyalty() external {\\n        if (msg.sender != royaltyOwner) {\\n            revert AccessControl();\\n        }\\n        _deleteDefaultRoyalty();\\n    }\\n\\n    /// @dev See {ERC2981-_setTokenRoyalty}.\\n    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external {\\n        if (msg.sender != royaltyOwner) {\\n            revert AccessControl();\\n        }\\n        _setTokenRoyalty(tokenId, receiver, feeNumerator);\\n    }\\n\\n    /// @dev See {ERC2981-_resetTokenRoyalty}.\\n    function resetTokenRoyalty(uint256 tokenId) external {\\n        if (msg.sender != royaltyOwner) {\\n            revert AccessControl();\\n        }\\n        _resetTokenRoyalty(tokenId);\\n    }\\n\\n    // METADATA FUNCTIONALITY\\n\\n    /// @notice Returns the metadata URI for a given token\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        return string(abi.encodePacked(baseTokenURI, Strings.toString(tokenId)));\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    /// @dev Revert if the account is a smart contract. Does not protect against calls from the constructor.\\n    /// @param account The account to check\\n    function _onlyEOA(address account) internal view {\\n        if (msg.sender != tx.origin || account.code.length > 0) {\\n            revert OnlyEOA(account);\\n        }\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"contracts/=contracts/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_DUTCH_AUCTION_START_ID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DUTCH_AUCTION_END_ID\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControl\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DoesNotOwnToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DutchAuctionBadParamsAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"DutchAuctionGracePeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DutchAuctionNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DutchAuctionNotOverAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DutchAuctionOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceededUserMintCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FailedToSendEther\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedArrays\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"OnlyEOA\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WritelistUsed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"DutchAuctionRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DUTCH_AUCTION_END_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DUTCH_AUCTION_GRACE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DUTCH_AUCTION_MINT_CAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DUTCH_AUCTION_START_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WRITERS_ROOM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apeMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"apeWritelistUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"claimDutchAuctionRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deleteDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"dutchAuctionMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dutchAuctionNextId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dutchAuctionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dutchEnd\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"time\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveawayMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"giveawayWritelist\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"remaining\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"used\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintHistory\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"ownerMintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"params\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"startPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"priceIncrement\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeIncrement\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"resetTokenRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_apeMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setApeMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseTokenURI\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endPrice\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"priceIncrement\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeIncrement\",\"type\":\"uint32\"}],\"internalType\":\"struct BoredAndDangerous.DutchAuctionParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"setDutchAuctionStruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_giveawayMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setGiveawayMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metadataOwner\",\"type\":\"address\"}],\"name\":\"setMetadataOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintingOwner\",\"type\":\"address\"}],\"name\":\"setMintingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyOwner\",\"type\":\"address\"}],\"name\":\"setRoyaltyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setTokenRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_writelistMintNextId\",\"type\":\"uint256\"}],\"name\":\"setWritelistMintNextId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setWritelistMintWritersRoomFreeOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setWritelistMintWritersRoomOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setWritelistPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"writelistMintApes\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalAllocation\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"writelistMintGiveaway\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writelistMintNextId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"writelistMintWritersRoom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"writelistMintWritersRoomFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writelistMintWritersRoomFreeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writelistMintWritersRoomOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"writelistPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"writersroomWritelistUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BoredAndDangerous", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000001b1f000000000000000000000000000000000000000000000000000000000000245d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}