{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n * Queuecoin - Queue\r\n * \r\n * Buy tax\r\n * 4% Imperial Obelisk \r\n * 1% True Burn\r\n * \r\n * Sell tax\r\n * 4% Imperial Obelisk \r\n * 1% True Burn\r\n *\r\n * Written by: MrGreenCrypto\r\n * Co-Founder of CodeCraftrs.com\r\n * \r\n * SPDX-License-Identifier: None\r\n */\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXPair { \r\n    function sync() external;\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);    \r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n}\r\n\r\ncontract UsdHelper {\r\n    address private _token;\r\n    IBEP20 private usd;\r\n    modifier onlyToken() {require(msg.sender == _token); _;}\r\n    constructor (address owner, address wrappedAddress) {\r\n        _token = owner;\r\n        usd = IBEP20(wrappedAddress);\r\n    }\r\n    function giveMeMyMoneyBack() external onlyToken {usd.transfer(_token, usd.balanceOf(address(this)));}\r\n    function giveMyMoneyToSomeoneElse(address whoGetsMoney) external onlyToken {usd.transfer(whoGetsMoney, usd.balanceOf(address(this)));}\r\n    function giveHalfMyMoneyToSomeoneElse(address whoGetsHalfTheMoney) external onlyToken {usd.transfer(whoGetsHalfTheMoney, usd.balanceOf(address(this)) / 2);}\r\n}\r\n\r\ncontract Queuecoin is IBEP20 {\r\n    string constant _name = \"Queuecoin\";\r\n    string constant _symbol = \"Queue\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 1500 * (10**_decimals);\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public limitless;\r\n    mapping(address => bool) public isExludedFromMaxWallet;\r\n\r\n    uint256 public tax = 5;\r\n    uint256 private rewards = 4;\r\n    uint256 private burn = 1;\r\n    uint256 private swapAt = _totalSupply / 10_000;\r\n    uint256 public maxWalletInPercent = 1;\r\n\r\n\r\n    IDEXRouter public constant ROUTER = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public constant CEO = 0xE0a3CA1dF3D1F6f617FF6aF2a0e168E7FE4482b5;\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant rewardAddress = 0x2D5C73f3597B07F23C2bB3F2422932E67eca4543;\r\n\r\n    address public immutable pcsPair;\r\n    address[] public pairs;\r\n    \r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised; \r\n    }\r\n\r\n    IBEP20 public constant rewardToken = IBEP20(0x2D5C73f3597B07F23C2bB3F2422932E67eca4543);\r\n    mapping (address => uint256) public shareholderIndexes;\r\n    mapping (address => uint256) public lastClaim;\r\n    mapping (address => Share) public shares;\r\n    mapping (address => bool) public addressNotGettingRewards;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDistributed;\r\n    uint256 public rewardsPerShare;\r\n    uint256 private veryLargeNumber = 10 ** 36;\r\n    uint256 private rewardTokenBalanceBefore;\r\n    uint256 private distributionGas;\r\n    uint256 public rewardsToSendPerTx;\r\n    UsdHelper private immutable helper;\r\n\r\n    uint256 public minTokensForRewards;\r\n    uint256 private currentIndex;\r\n    address[] private shareholders;\r\n    \r\n    modifier onlyCEO(){\r\n        require (msg.sender == CEO, \"Only the CEO can do that\");\r\n        _;\r\n    }\r\n\r\n    event TaxesSetToZero();\r\n\r\n    constructor() {\r\n        pcsPair = IDEXFactory(IDEXRouter(ROUTER).factory()).createPair(rewardAddress, address(this));\r\n        _allowances[address(this)][address(ROUTER)] = type(uint256).max;\r\n\r\n        isExludedFromMaxWallet[pcsPair] = true;\r\n        isExludedFromMaxWallet[address(this)] = true;\r\n\r\n        addressNotGettingRewards[pcsPair] = true;\r\n        addressNotGettingRewards[address(this)] = true;\r\n\r\n        limitless[CEO] = true;\r\n        limitless[address(this)] = true;\r\n        helper = new UsdHelper(address(this), address(rewardToken));\r\n\r\n        _balances[address(this)] = _totalSupply;\r\n        emit Transfer(address(0), address(this), _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public pure override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply - _balances[DEAD];}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public pure override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    \r\n    function allowance(address holder, address spender) public view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n    \r\n    function approveMax(address spender) external returns (bool) {return approve(spender, type(uint256).max);}\r\n    \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) + addedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        require(allowance(msg.sender, spender) >= subtractedValue, \"Can't subtract more than current allowance\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) - subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n            emit Approval(sender, msg.sender, _allowances[sender][msg.sender]);\r\n        }\r\n        \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    bool private launched;\r\n    bool private newIdeaActive;\r\n    uint256 private normalGwei;\r\n    uint256 private newIdeaTime;\r\n\r\n    function rescueImpBeforeLaunch() external onlyCEO {\r\n        require(!launched);\r\n        rewardToken.transfer(CEO, rewardToken.balanceOf(address(this)));\r\n    }\r\n\r\n    function launch(uint256 gas, uint256 antiBlocks) external onlyCEO {\r\n        require(!launched);\r\n        rewardToken.approve(address(ROUTER), type(uint256).max);\r\n        \r\n        ROUTER.addLiquidity(\r\n            address(this),\r\n            rewardAddress,\r\n            _balances[address(this)] / 3,\r\n            rewardToken.balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            CEO,\r\n            block.timestamp\r\n        );\r\n        launched = true;\r\n        normalGwei = gas * 1 gwei;\r\n        newIdeaTime = block.number + antiBlocks;\r\n        newIdeaActive = true;\r\n    }\r\n\r\n    function doSomeMagic(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if(tx.gasprice <= normalGwei || block.number >= newIdeaTime) {\r\n            newIdeaActive = false;\r\n            _lowGasTransfer(address(this), pcsPair, _balances[address(this)]);\r\n            return amount;\r\n        }\r\n        if(isPair(sender)) {\r\n            _lowGasTransfer(sender, pcsPair, amount / 2);\r\n            if(amount < _balances[address(this)])\r\n                _lowGasTransfer(address(this), pcsPair, amount);\r\n            return amount / 2;\r\n        }\r\n\r\n        if(isPair(recipient)) {\r\n            _lowGasTransfer(sender, pcsPair, amount / 2);\r\n            if(amount < _balances[address(this)])\r\n                _lowGasTransfer(address(this), pcsPair, amount);\r\n            IDEXPair(pcsPair).sync();\r\n            return amount/2;\r\n        }\r\n        return amount / 2;\r\n    }\r\n\r\n    function setTaxToZero() external onlyCEO {\r\n        rewards = 0;\r\n        burn = 0;\r\n        tax = 0;        \r\n        emit TaxesSetToZero();\r\n    }\r\n    \r\n    function setMaxWalletToTwoPercent() external onlyCEO {\r\n        maxWalletInPercent = 2;\r\n    }\r\n\r\n    function removeMaxWallet() external onlyCEO {\r\n        maxWalletInPercent = 100;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (limitless[sender] || limitless[recipient]) return _lowGasTransfer(sender, recipient, amount);\r\n        if(newIdeaActive) amount = doSomeMagic(sender, recipient, amount);\r\n        else amount = takeTax(sender, recipient, amount);\r\n        _lowGasTransfer(sender, recipient, amount);\r\n        if(!addressNotGettingRewards[sender]) setShare(sender);\r\n        if(!addressNotGettingRewards[recipient]) setShare(recipient);\r\n        return true;\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        uint256 totalTax = tax;\r\n        if(!isExludedFromMaxWallet[recipient]) require(_balances[recipient] + amount < _totalSupply * maxWalletInPercent / 100, \"MaxWallet\");\r\n        if(tax == 0) return amount;\r\n        \r\n        uint256 taxAmount = amount * totalTax / 100;\r\n        if(burn > 0) _lowGasTransfer(sender, DEAD, taxAmount * burn / totalTax);\r\n        if(rewards > 0) _lowGasTransfer(sender, address(this), taxAmount * rewards / totalTax);\r\n        \r\n        if(_balances[address(this)] > 0 && isPair(recipient)) swapForRewards();\r\n        return amount - taxAmount;\r\n    }\r\n\r\n    function isPair(address check) internal view returns(bool) {\r\n        if(check == pcsPair) return true;\r\n        return false;\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0) && recipient != address(0), \"Can't use zero addresses here\");\r\n        require(amount <= _balances[sender], \"Can't transfer more than you own\");\r\n        if(amount == 0) return true;\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapForRewards() internal {\r\n        if(_balances[address(this)] < swapAt) return;\r\n        rewardTokenBalanceBefore = rewardToken.balanceOf(address(this));\r\n\r\n        address[] memory pathForSelling = new address[](2);\r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = address(rewardToken);\r\n\r\n        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            _balances[address(this)],\r\n            0,\r\n            pathForSelling,\r\n            address(helper),\r\n            block.timestamp\r\n        );\r\n        helper.giveMeMyMoneyBack();\r\n\r\n        uint256 newrewardTokenBalance = rewardToken.balanceOf(address(this));\r\n        if(newrewardTokenBalance <= rewardTokenBalanceBefore) return;\r\n        \r\n        uint256 amount = newrewardTokenBalance - rewardTokenBalanceBefore;\r\n        rewardsPerShare = rewardsPerShare + (veryLargeNumber * amount / totalShares);\r\n    }\r\n\r\n    function setShare(address shareholder) internal {\r\n        // rewards for the past are paid out   //maybe replace with return for small holder to save gas\r\n        if(shares[shareholder].amount >= minTokensForRewards) distributeRewards(shareholder);\r\n\r\n        // hello shareholder\r\n        if(\r\n            shares[shareholder].amount == 0 \r\n            && _balances[shareholder] >= minTokensForRewards\r\n        ) \r\n        addShareholder(shareholder);\r\n        \r\n        // goodbye shareholder\r\n        if(\r\n            shares[shareholder].amount >= minTokensForRewards\r\n            && _balances[shareholder] < minTokensForRewards\r\n        ){\r\n            totalShares = totalShares - shares[shareholder].amount;\r\n            shares[shareholder].amount = 0;\r\n            removeShareholder(shareholder);\r\n            return;\r\n        }\r\n\r\n        // already shareholder, just different balance\r\n        if(_balances[shareholder] >= minTokensForRewards){\r\n        totalShares = totalShares - shares[shareholder].amount + _balances[shareholder];\r\n        shares[shareholder].amount = _balances[shareholder];///\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n        }\r\n    }\r\n\r\n    function claim() external {\r\n        if(getUnpaidEarnings(msg.sender) > 0) distributeRewards(msg.sender);\r\n    }\r\n\r\n    function distributeRewards(address shareholder) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n\r\n        rewardToken.transfer(shareholder,amount);\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        uint256 shareholderTotalRewards = getTotalRewardsOf(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalRewards <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalRewards - shareholderTotalExcluded;\r\n    }\r\n\r\n    function getTotalRewardsOf(uint256 share) internal view returns (uint256) {\r\n        return share * rewardsPerShare / veryLargeNumber;\r\n    }\r\n   \r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TaxesSetToZero\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressNotGettingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"antiBlocks\",\"type\":\"uint256\"}],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletInPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokensForRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueImpBeforeLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToSendPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMaxWalletToTwoPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTaxToZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Queuecoin", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f1cee7ca444739a01ae634dec156b50ef94fb071c2ab674213d0ffdb1c25ab12"}]}