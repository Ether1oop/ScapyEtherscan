{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lib/AppProxyUpgradeable.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/AppProxyBase.sol\\\";\\n\\ncontract AppProxyUpgradeable is AppProxyBase {\\n    /**\\n     * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\\n     * @param _kernel Reference to organization kernel for the app\\n     * @param _appId Identifier for app\\n     * @param _initializePayload Payload for call to be made after setup to initialize\\n     */\\n    constructor(\\n        IKernel _kernel,\\n        bytes32 _appId,\\n        bytes _initializePayload // solium-disable-line visibility-first\\n    ) public AppProxyBase(_kernel, _appId, _initializePayload) {\\n        // solium-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev ERC897, the address the proxy would delegate calls to\\n     */\\n    function implementation() public view returns (address) {\\n        return getAppBase(appId());\\n    }\\n\\n    /**\\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\\n     */\\n    function proxyType() public pure returns (uint256 proxyTypeId) {\\n        return UPGRADEABLE;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AppProxyBase.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/AppStorage.sol\\\";\\nimport \\\"contracts/lib/DepositableDelegateProxy.sol\\\";\\nimport \\\"contracts/lib/KernelNamespaceConstants.sol\\\";\\n\\ncontract AppProxyBase is\\n    AppStorage,\\n    DepositableDelegateProxy,\\n    KernelNamespaceConstants\\n{\\n    /**\\n     * @dev Initialize AppProxy\\n     * @param _kernel Reference to organization kernel for the app\\n     * @param _appId Identifier for app\\n     * @param _initializePayload Payload for call to be made after setup to initialize\\n     */\\n    constructor(\\n        IKernel _kernel,\\n        bytes32 _appId,\\n        bytes _initializePayload\\n    ) public {\\n        setKernel(_kernel);\\n        setAppId(_appId);\\n\\n        // Implicit check that kernel is actually a Kernel\\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\\n        // it.\\n        address appCode = getAppBase(_appId);\\n\\n        // If initialize payload is provided, it will be executed\\n        if (_initializePayload.length > 0) {\\n            require(isContract(appCode));\\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\\n            // returns ending execution context and halts contract deployment\\n            require(appCode.delegatecall(_initializePayload));\\n        }\\n    }\\n\\n    function getAppBase(bytes32 _appId) internal view returns (address) {\\n        return kernel().getApp(KERNEL_APP_BASES_NAMESPACE, _appId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/AppStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/IKernel.sol\\\";\\nimport \\\"contracts/lib/UnstructuredStorage.sol\\\";\\n\\ncontract AppStorage {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_POSITION = keccak256(\\\"aragonOS.appStorage.kernel\\\");\\n    bytes32 internal constant APP_ID_POSITION = keccak256(\\\"aragonOS.appStorage.appId\\\");\\n    */\\n    bytes32 internal constant KERNEL_POSITION =\\n        0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\\n    bytes32 internal constant APP_ID_POSITION =\\n        0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\\n\\n    function kernel() public view returns (IKernel) {\\n        return IKernel(KERNEL_POSITION.getStorageAddress());\\n    }\\n\\n    function appId() public view returns (bytes32) {\\n        return APP_ID_POSITION.getStorageBytes32();\\n    }\\n\\n    function setKernel(IKernel _kernel) internal {\\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\\n    }\\n\\n    function setAppId(bytes32 _appId) internal {\\n        APP_ID_POSITION.setStorageBytes32(_appId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DepositableDelegateProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/DelegateProxy.sol\\\";\\nimport \\\"contracts/lib/DepositableStorage.sol\\\";\\n\\ncontract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\\n    event ProxyDeposit(address sender, uint256 value);\\n\\n    function() external payable {\\n        uint256 forwardGasThreshold = FWD_GAS_LIMIT;\\n        bytes32 isDepositablePosition = DEPOSITABLE_POSITION;\\n\\n        // Optimized assembly implementation to prevent EIP-1884 from breaking deposits, reference code in Solidity:\\n        // https://github.com/aragon/aragonOS/blob/v4.2.1/contracts/common/DepositableDelegateProxy.sol#L10-L20\\n        assembly {\\n            // Continue only if the gas left is lower than the threshold for forwarding to the implementation code,\\n            // otherwise continue outside of the assembly block.\\n            if lt(gas, forwardGasThreshold) {\\n                // Only accept the deposit and emit an event if all of the following are true:\\n                // the proxy accepts deposits (isDepositable), msg.data.length == 0, and msg.value > 0\\n                if and(\\n                    and(sload(isDepositablePosition), iszero(calldatasize)),\\n                    gt(callvalue, 0)\\n                ) {\\n                    // Equivalent Solidity code for emitting the event:\\n                    // emit ProxyDeposit(msg.sender, msg.value);\\n\\n                    let logData := mload(0x40) // free memory pointer\\n                    mstore(logData, caller) // add 'msg.sender' to the log data (first event param)\\n                    mstore(add(logData, 0x20), callvalue) // add 'msg.value' to the log data (second event param)\\n\\n                    // Emit an event with one topic to identify the event: keccak256('ProxyDeposit(address,uint256)') = 0x15ee...dee1\\n                    log1(\\n                        logData,\\n                        0x40,\\n                        0x15eeaa57c7bd188c1388020bcadc2c436ec60d647d36ef5b9eb3c742217ddee1\\n                    )\\n\\n                    stop() // Stop. Exits execution context\\n                }\\n\\n                // If any of above checks failed, revert the execution (if ETH was sent, it is returned to the sender)\\n                revert(0, 0)\\n            }\\n        }\\n\\n        address target = implementation();\\n        delegatedFwd(target, msg.data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/KernelNamespaceConstants.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ncontract KernelNamespaceConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\\\"core\\\");\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\\\"base\\\");\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\\\"app\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE =\\n        0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE =\\n        0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE =\\n        0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IKernel.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/IACL.sol\\\";\\nimport \\\"contracts/lib/IKernelEvents.sol\\\";\\nimport \\\"contracts/lib/IVaultRecoverable.sol\\\";\\n\\n// This should be an interface, but interfaces can't inherit yet :(\\ncontract IKernel is IKernelEvents, IVaultRecoverable {\\n    function acl() public view returns (IACL);\\n\\n    function hasPermission(\\n        address who,\\n        address where,\\n        bytes32 what,\\n        bytes how\\n    ) public view returns (bool);\\n\\n    function setApp(\\n        bytes32 namespace,\\n        bytes32 appId,\\n        address app\\n    ) public;\\n\\n    function getApp(bytes32 namespace, bytes32 appId)\\n        public\\n        view\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/UnstructuredStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nlibrary UnstructuredStorage {\\n    function getStorageBool(bytes32 position)\\n        internal\\n        view\\n        returns (bool data)\\n    {\\n        assembly {\\n            data := sload(position)\\n        }\\n    }\\n\\n    function getStorageAddress(bytes32 position)\\n        internal\\n        view\\n        returns (address data)\\n    {\\n        assembly {\\n            data := sload(position)\\n        }\\n    }\\n\\n    function getStorageBytes32(bytes32 position)\\n        internal\\n        view\\n        returns (bytes32 data)\\n    {\\n        assembly {\\n            data := sload(position)\\n        }\\n    }\\n\\n    function getStorageUint256(bytes32 position)\\n        internal\\n        view\\n        returns (uint256 data)\\n    {\\n        assembly {\\n            data := sload(position)\\n        }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly {\\n            sstore(position, data)\\n        }\\n    }\\n\\n    function setStorageAddress(bytes32 position, address data) internal {\\n        assembly {\\n            sstore(position, data)\\n        }\\n    }\\n\\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\\n        assembly {\\n            sstore(position, data)\\n        }\\n    }\\n\\n    function setStorageUint256(bytes32 position, uint256 data) internal {\\n        assembly {\\n            sstore(position, data)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DelegateProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/ERCProxy.sol\\\";\\nimport \\\"contracts/lib/IsContract.sol\\\";\\n\\ncontract DelegateProxy is ERCProxy, IsContract {\\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\\n\\n    /**\\n     * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\\n     * @param _dst Destination address to perform the delegatecall\\n     * @param _calldata Calldata for the delegatecall\\n     */\\n    function delegatedFwd(address _dst, bytes _calldata) internal {\\n        require(isContract(_dst));\\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\\n\\n        assembly {\\n            let result := delegatecall(\\n                sub(gas, fwdGasLimit),\\n                _dst,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            let size := returndatasize\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/DepositableStorage.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\nimport \\\"contracts/lib/UnstructuredStorage.sol\\\";\\n\\ncontract DepositableStorage {\\n    using UnstructuredStorage for bytes32;\\n\\n    // keccak256(\\\"aragonOS.depositableStorage.depositable\\\")\\n    bytes32 internal constant DEPOSITABLE_POSITION =\\n        0x665fd576fbbe6f247aff98f5c94a561e3f71ec2d3c988d56f12d342396c50cea;\\n\\n    function isDepositable() public view returns (bool) {\\n        return DEPOSITABLE_POSITION.getStorageBool();\\n    }\\n\\n    function setDepositable(bool _depositable) internal {\\n        DEPOSITABLE_POSITION.setStorageBool(_depositable);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IACL.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ninterface IACL {\\n    function initialize(address permissionsCreator) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function hasPermission(\\n        address who,\\n        address where,\\n        bytes32 what,\\n        bytes how\\n    ) public view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IKernelEvents.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ninterface IKernelEvents {\\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IVaultRecoverable.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ninterface IVaultRecoverable {\\n    event RecoverToVault(\\n        address indexed vault,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    function transferToVault(address token) external;\\n\\n    function allowRecoverability(address token) external view returns (bool);\\n\\n    function getRecoveryVault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERCProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ncontract ERCProxy {\\n    uint256 internal constant FORWARDING = 1;\\n    uint256 internal constant UPGRADEABLE = 2;\\n\\n    function proxyType() public pure returns (uint256 proxyTypeId);\\n\\n    function implementation() public view returns (address codeAddr);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IsContract.sol\": {\r\n      \"content\": \"pragma solidity 0.4.24;\\n\\ncontract IsContract {\\n    /*\\n     * NOTE: this should NEVER be used for authentication\\n     * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\\n     *\\n     * This is only intended to be used as a sanity check that an address is actually a contract,\\n     * RATHER THAN an address not being a contract.\\n     */\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_target)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"contracts/=contracts/\",\r\n      \"foundry/=tests/foundry/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"name\":\"proxyTypeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDepositable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kernel\",\"type\":\"address\"},{\"name\":\"_appId\",\"type\":\"bytes32\"},{\"name\":\"_initializePayload\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ProxyDeposit\",\"type\":\"event\"}]", "ContractName": "AppProxyUpgradeable", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0d63d9aacb5f3fde493ac7665d8545d836921dc4711f9e52189cf11477e908217649fa1d2919cd848b3aa95e591daf1523d4fa000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "constantinople", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xc55a3957476cc1e7fef40856802edd150c3a3dcd", "SwarmSource": ""}]}