{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ncontract Staking is Ownable {\\n    // maximum upper limit of the cooldown period\\n    uint256 public constant COOLDOWN_UPPER_LIMIT = 365 days;\\n\\n    // token used for staking\\n    IERC20Upgradeable public immutable token;\\n\\n    // amounts staked, address to value staked mapping\\n    mapping(address => uint256) public staked;\\n\\n    // timestamps timers until which the penalty is applied, 0 means it is cleared\\n    mapping(address => uint256) public timers;\\n\\n    // amounts set for the cooldown period\\n    mapping(address => uint256) public amounts;\\n\\n    // snapshotted penalties, address to penalty mapping\\n    mapping(address => uint16) public penalties;\\n\\n    // cooldown period\\n    uint256 public cooldown = 14 days;\\n\\n    // penalty for unstaking, divided by 100 to get the total percentages\\n    uint16 public penalty = 1000;\\n\\n    // wallet to which the tokens go for penalties\\n    address public treasury;\\n\\n    error CooldownOverflow();\\n    error NotEnoughBalance();\\n    error NotEnoughStakedBalance();\\n    error PenaltyOverflow();\\n    error UnstakingDifferentAmount();\\n    error ZeroAmount();\\n    error ZeroAddress();\\n\\n    event Staked(address indexed account, uint256 amount);\\n    event Unstaked(address indexed account, uint256 amount);\\n    event CooldownChanged(uint256 newCooldown);\\n    event PenaltyChanged(uint16 newPenalty);\\n    event SetCooldownTimer(address indexed account, uint256 amount);\\n    event TreasuryChanged(address newTreasury);\\n\\n    /**\\n     * @param token_ staking token address\\n     * @param treasury_ address for the treasury wallet\\n     */\\n    constructor(IERC20Upgradeable token_, address treasury_) {\\n        if (address(token_) == address(0) || address(treasury_) == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        token = token_;\\n        treasury = treasury_;\\n    }\\n\\n    /**\\n     * @notice Allows any wallet to stake available tokens.\\n     *         The penalty for unstaking is updated to the current global one when a wallet stakes more tokens.\\n     * @param amount amount of tokens to stake\\n     */\\n    function stake(uint256 amount) external {\\n        if (amount == 0) {\\n            revert ZeroAmount();\\n        }\\n        if (amount > token.balanceOf(msg.sender)) {\\n            revert NotEnoughBalance();\\n        }\\n        staked[msg.sender] += amount;\\n        penalties[msg.sender] = penalty;\\n        require(token.transferFrom(msg.sender, address(this), amount), \\\"transfer failed\\\");\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Allows any wallet to unstake staked tokens.\\n     *         There is a penalty for unstaking the tokens during or without the cooldown period.\\n     *         The cooldown period is set via setCooldownTimer(amount) method.\\n     * @param amount amount of tokens to unstake\\n     */\\n    function unstake(uint256 amount) external {\\n        if (amount == 0) {\\n            revert ZeroAmount();\\n        }\\n        if (amount > staked[msg.sender]) {\\n            revert NotEnoughStakedBalance();\\n        }\\n        if (amount != amounts[msg.sender] && amounts[msg.sender] != 0) {\\n            revert UnstakingDifferentAmount();\\n        }\\n        uint256 penaltyAmount = calculatePenalty(amount);\\n        staked[msg.sender] -= amount;\\n        setCooldownTimer(0);\\n        if (penaltyAmount > 0) {\\n            require(token.transfer(treasury, penaltyAmount), \\\"penalty transfer failed\\\");\\n        }\\n        if (amount != penaltyAmount) {\\n            require(token.transfer(msg.sender, amount - penaltyAmount), \\\"transfer failed\\\");\\n        }\\n        emit Unstaked(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Sets the cooldown timer for passed amount.\\n     * @param amount amount of set for the cooldown period\\n     */\\n    function setCooldownTimer(uint256 amount) public {\\n        if (amount > staked[msg.sender]) {\\n            revert NotEnoughStakedBalance();\\n        }\\n        timers[msg.sender] = amount == 0 ? 0 : block.timestamp + cooldown;\\n        amounts[msg.sender] = amount;\\n        penalties[msg.sender] = amount == 0 ? 0 : penalty;\\n        emit SetCooldownTimer(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to set the cooldown period (maximum of 365 days).\\n     * @param newCooldown new cooldown period\\n     */\\n    function setCooldown(uint256 newCooldown) external onlyOwner {\\n        if (newCooldown > COOLDOWN_UPPER_LIMIT) {\\n            revert CooldownOverflow();\\n        }\\n        cooldown = newCooldown;\\n        emit CooldownChanged(newCooldown);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to set the penalty (maximum of 10000 = 100%).\\n     * @param newPenalty new penalty\\n     */\\n    function setPenalty(uint16 newPenalty) external onlyOwner {\\n        if (newPenalty > 10000) {\\n            revert PenaltyOverflow();\\n        }\\n        penalty = newPenalty;\\n        emit PenaltyChanged(newPenalty);\\n    }\\n\\n    /**\\n     * @notice Allows the owner to set the treasury address.\\n     * @param newTreasury new treasury address\\n     */\\n    function setTreasury(address newTreasury) external onlyOwner {\\n        if (newTreasury == address(0)) {\\n            revert ZeroAddress();\\n        }\\n        treasury = newTreasury;\\n        emit TreasuryChanged(newTreasury);\\n    }\\n\\n    /**\\n     * @notice Calculates a penalty based on the given sender and amount.\\n     *         Can be used to return the penalty amount without actually unstaking.\\n     * @param amount amount on which the penalty is calculated\\n     * @return amount amount of penalty\\n     */\\n    function calculatePenalty(uint256 amount) public view returns (uint256) {\\n        if (amounts[msg.sender] == 0) {\\n            return (amount * penalty / 100) / 100;\\n        } else if (timers[msg.sender] > block.timestamp) {\\n            return (amount * penalties[msg.sender] / 100) / 100;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CooldownOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughStakedBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PenaltyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnstakingDifferentAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCooldown\",\"type\":\"uint256\"}],\"name\":\"CooldownChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newPenalty\",\"type\":\"uint16\"}],\"name\":\"PenaltyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetCooldownTimer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COOLDOWN_UPPER_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculatePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"penalties\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penalty\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCooldown\",\"type\":\"uint256\"}],\"name\":\"setCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCooldownTimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newPenalty\",\"type\":\"uint16\"}],\"name\":\"setPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a62cc35625b0c8dc1faea39d33625bb4c15bd71c0000000000000000000000005ed7edca7cea9522c0305f6eac7b63efa778fc78", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}