{"status": "1", "message": "OK", "result": [{"SourceCode": "# @version 0.3.4\r\n\"\"\"\r\n@title Zap for Curve Factory\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Zap for fraxbp metapools created via crypto factory\r\n\"\"\"\r\n\r\n\r\ninterface ERC20:  # Custom ERC20 which works for Curve LP Tokens\r\n    def transfer(_receiver: address, _amount: uint256): nonpayable\r\n    def transferFrom(_sender: address, _receiver: address, _amount: uint256): nonpayable\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\n\r\ninterface wETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\n\r\n# CurveCryptoSwap2ETH from Crypto Factory\r\ninterface CurveMeta:\r\n    def coins(i: uint256) -> address: view\r\n    def token() -> address: view\r\n    def lp_price() -> uint256: view\r\n    def price_scale() -> uint256: view\r\n    def price_oracle() -> uint256: view\r\n    def virtual_price() -> uint256: view\r\n    def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS]) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256: view\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool = False, receiver: address = msg.sender) -> uint256: payable\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256, use_eth: bool = False, receiver: address = msg.sender) -> uint256: payable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[2], use_eth: bool = False, receiver: address = msg.sender): nonpayable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256, use_eth: bool = False, receiver: address = msg.sender) -> uint256: nonpayable\r\n\r\n\r\n# FraxBP\r\ninterface CurveBase:\r\n    def coins(i: uint256) -> address: view\r\n    def lp_token() -> address: view\r\n    def get_dy(i: int128, j: int128, dx: uint256) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], is_deposit: bool) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): nonpayable\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def remove_liquidity(amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\r\n    def get_virtual_price() -> uint256: view\r\n\r\n\r\nN_COINS: constant(uint256) = 2\r\nMAX_COIN: constant(uint256) = N_COINS - 1\r\nBASE_N_COINS: constant(uint256) = 2\r\nN_ALL_COINS: constant(uint256) = N_COINS + BASE_N_COINS - 1\r\n\r\nWETH: immutable(wETH)\r\n\r\nBASE_POOL: immutable(CurveBase)\r\nBASE_LP_TOKEN: immutable(address)\r\nBASE_COINS: immutable(address[BASE_N_COINS])\r\n# coin -> pool -> is approved to transfer?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\n\r\n@external\r\ndef __init__(_base_pool: address, _weth: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    \"\"\"\r\n    BASE_POOL = CurveBase(_base_pool)\r\n    BASE_LP_TOKEN = BASE_POOL.lp_token()\r\n    base_coins: address[BASE_N_COINS] = empty(address[BASE_N_COINS])\r\n    for i in range(BASE_N_COINS):\r\n        base_coins[i] = BASE_POOL.coins(i)\r\n    BASE_COINS = base_coins\r\n    WETH = wETH(_weth)\r\n\r\n    for coin in base_coins:\r\n        ERC20(coin).approve(_base_pool, max_value(uint256))\r\n        self.is_approved[coin][_base_pool] = True\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    assert msg.sender.is_contract  # dev: receive only from pools and WETH\r\n\r\n\r\n@pure\r\n@external\r\ndef base_pool() -> address:\r\n    return BASE_POOL.address\r\n\r\n\r\n@pure\r\n@external\r\ndef base_token() -> address:\r\n    return BASE_LP_TOKEN\r\n\r\n\r\n@external\r\n@view\r\ndef price_oracle(_pool: address) -> uint256:\r\n    usd_tkn: uint256 = CurveMeta(_pool).price_oracle()\r\n    vprice: uint256 = BASE_POOL.get_virtual_price()\r\n    return vprice * 10**18 / usd_tkn\r\n\r\n\r\n@external\r\n@view\r\ndef price_scale(_pool: address) -> uint256:\r\n    usd_tkn: uint256 = CurveMeta(_pool).price_scale()\r\n    vprice: uint256 = BASE_POOL.get_virtual_price()\r\n    return vprice * 10**18 / usd_tkn\r\n\r\n\r\n@external\r\n@view\r\ndef lp_price(_pool: address) -> uint256:\r\n    p: uint256 = CurveMeta(_pool).lp_price()  # price in tkn\r\n    usd_tkn: uint256 = CurveMeta(_pool).price_oracle()\r\n    vprice: uint256 = BASE_POOL.get_virtual_price()\r\n    return p * vprice / usd_tkn\r\n\r\n\r\n@internal\r\ndef _receive(_coin: address, _amount: uint256, _from: address,\r\n             _eth_value: uint256, _use_eth: bool, _wrap_eth: bool=False) -> uint256:\r\n    \"\"\"\r\n    Transfer coin to zap\r\n    @param _coin Address of the coin\r\n    @param _amount Amount of coin\r\n    @param _from Sender of the coin\r\n    @param _eth_value Eth value sent\r\n    @param _use_eth Use raw ETH\r\n    @param _wrap_eth Wrap raw ETH\r\n    @return Received ETH amount\r\n    \"\"\"\r\n    if _use_eth and _coin == WETH.address:\r\n        assert _eth_value == _amount  # dev: incorrect ETH amount\r\n        if _wrap_eth:\r\n            WETH.deposit(value=_amount)\r\n        else:\r\n            return _amount\r\n    else:\r\n        response: Bytes[32] = raw_call(\r\n            _coin,\r\n            _abi_encode(\r\n                _from,\r\n                self,\r\n                _amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)  # dev: failed transfer\r\n    return 0\r\n\r\n\r\n@internal\r\ndef _send(_coin: address, _to: address, _use_eth: bool, _withdraw_eth: bool=False) -> uint256:\r\n    \"\"\"\r\n    Send coin from zap\r\n    @dev Sends all available amount\r\n    @param _coin Address of the coin\r\n    @param _to Sender of the coin\r\n    @param _use_eth Use raw ETH\r\n    @param _withdraw_eth Withdraw raw ETH from wETH\r\n    @return Amount of coin sent\r\n    \"\"\"\r\n    amount: uint256 = 0\r\n    if _use_eth and _coin == WETH.address:\r\n        if _withdraw_eth:\r\n            amount = ERC20(_coin).balanceOf(self)\r\n            WETH.withdraw(amount)\r\n        amount = self.balance\r\n        raw_call(_to, b\"\", value=amount)\r\n    else:\r\n        amount = ERC20(_coin).balanceOf(self)\r\n        response: Bytes[32] = raw_call(\r\n            _coin,\r\n            _abi_encode(_to, amount, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)  # dev: failed transfer\r\n    return amount\r\n\r\n\r\n@payable\r\n@external\r\ndef exchange(_pool: address, i: uint256, j: uint256, _dx: uint256, _min_dy: uint256,\r\n             _use_eth: bool = False, _receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange using wETH by default\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param _pool Address of the pool for the exchange\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @param _min_dy Minimum amount of `j` to receive\r\n    @param _use_eth Use raw ETH\r\n    @param _receiver Address that will receive `j`\r\n    @return Actual amount of `j` received\r\n    \"\"\"\r\n    assert i != j  # dev: indexes are similar\r\n    if not _use_eth:\r\n        assert msg.value == 0  # dev: nonzero ETH amount\r\n\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    if i < MAX_COIN:  # Swap to LP token and remove from base\r\n        # Receive and swap to LP Token\r\n        coin: address = CurveMeta(_pool).coins(i)\r\n        eth_amount: uint256 = self._receive(coin, _dx, msg.sender, msg.value, _use_eth)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, max_value(uint256))\r\n            self.is_approved[coin][_pool] = True\r\n        lp_amount: uint256 = CurveMeta(_pool).exchange(i, MAX_COIN, _dx, 0, _use_eth, value=eth_amount)\r\n\r\n        # Remove and send to _receiver\r\n        BASE_POOL.remove_liquidity_one_coin(lp_amount, convert(j - MAX_COIN, int128), _min_dy)\r\n\r\n        coin = base_coins[j - MAX_COIN]\r\n        return self._send(coin, _receiver, _use_eth, True)\r\n\r\n    # Receive coin i\r\n    base_i: int128 = convert(i - MAX_COIN, int128)\r\n    self._receive(base_coins[base_i], _dx, msg.sender, msg.value, _use_eth, True)\r\n\r\n    # Add in base and exchange LP token\r\n    if j < MAX_COIN:\r\n        amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n        amounts[base_i] = _dx\r\n\r\n        BASE_POOL.add_liquidity(amounts, 0)\r\n\r\n        if not self.is_approved[BASE_LP_TOKEN][_pool]:\r\n            ERC20(BASE_LP_TOKEN).approve(_pool, max_value(uint256))\r\n            self.is_approved[BASE_LP_TOKEN][_pool] = True\r\n\r\n        lp_amount: uint256 = ERC20(BASE_LP_TOKEN).balanceOf(self)\r\n        return CurveMeta(_pool).exchange(MAX_COIN, j, lp_amount, _min_dy, _use_eth, _receiver)\r\n\r\n    base_j: int128 = convert(j - MAX_COIN, int128)\r\n\r\n    BASE_POOL.exchange(base_i, base_j, _dx, _min_dy)\r\n\r\n    coin: address = base_coins[base_j]\r\n    return self._send(coin, _receiver, _use_eth, True)\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy(_pool: address, i: uint256, j: uint256, _dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received in exchange\r\n    @dev Index values can be found via the `coins` public getter method\r\n    @param _pool Address of the pool for the exchange\r\n    @param i Index value for the coin to send\r\n    @param j Index value of the coin to receive\r\n    @param _dx Amount of `i` being exchanged\r\n    @return Expected amount of `j` to receive\r\n    \"\"\"\r\n    assert i != j  # dev: indexes are similar\r\n\r\n    if i < MAX_COIN:  # Swap to LP token and remove from base\r\n        lp_amount: uint256 = CurveMeta(_pool).get_dy(i, MAX_COIN, _dx)\r\n\r\n        return BASE_POOL.calc_withdraw_one_coin(lp_amount, convert(j - MAX_COIN, int128))\r\n\r\n    # Add in base and exchange LP token\r\n    if j < MAX_COIN:\r\n        amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n        amounts[i - MAX_COIN] = _dx\r\n        lp_amount: uint256 = BASE_POOL.calc_token_amount(amounts, True)\r\n\r\n        return CurveMeta(_pool).get_dy(MAX_COIN, j, lp_amount)\r\n\r\n    # Exchange in base\r\n    return BASE_POOL.get_dy(convert(i - MAX_COIN, int128), convert(j - MAX_COIN, int128), _dx)\r\n\r\n\r\n@payable\r\n@external\r\ndef add_liquidity(\r\n    _pool: address,\r\n    _deposit_amounts: uint256[N_ALL_COINS],\r\n    _min_mint_amount: uint256,\r\n    _use_eth: bool = False,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit tokens to base and meta pools\r\n    @param _pool Address of the metapool to deposit into\r\n    @param _deposit_amounts List of amounts of underlying coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _use_eth Use raw ETH\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    if not _use_eth:\r\n        assert msg.value == 0  # dev: nonzero ETH amount\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    eth_amount: uint256 = 0\r\n\r\n    if _deposit_amounts[0] != 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        eth_amount = self._receive(coin, _deposit_amounts[0], msg.sender, msg.value, _use_eth)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, max_value(uint256))\r\n            self.is_approved[coin][_pool] = True\r\n        meta_amounts[0] = _deposit_amounts[0]\r\n\r\n    for i in range(MAX_COIN, N_ALL_COINS):\r\n        amount: uint256 = _deposit_amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        deposit_base = True\r\n\r\n        base_idx: uint256 = i - MAX_COIN\r\n\r\n        coin: address = base_coins[base_idx]\r\n        self._receive(coin, amount, msg.sender, msg.value, _use_eth, True)\r\n        base_amounts[base_idx] = amount\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        BASE_POOL.add_liquidity(base_amounts, 0)\r\n        meta_amounts[MAX_COIN] = ERC20(BASE_LP_TOKEN).balanceOf(self)\r\n        if not self.is_approved[BASE_LP_TOKEN][_pool]:\r\n            ERC20(BASE_LP_TOKEN).approve(_pool, max_value(uint256))\r\n            self.is_approved[BASE_LP_TOKEN][_pool] = True\r\n\r\n    # Deposit to the meta pool\r\n    return CurveMeta(_pool).add_liquidity(meta_amounts, _min_mint_amount, _use_eth, _receiver, value=eth_amount)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_pool: address, _amounts: uint256[N_ALL_COINS]) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts Amount of each underlying coin being deposited\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n\r\n    meta_amounts[0] = _amounts[0]\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = _amounts[i + MAX_COIN]\r\n        if base_amounts[i] > 0:\r\n            deposit_base = True\r\n\r\n    if deposit_base:\r\n        base_tokens: uint256 = BASE_POOL.calc_token_amount(base_amounts, True)\r\n        meta_amounts[MAX_COIN] = base_tokens\r\n\r\n    return CurveMeta(_pool).calc_token_amount(meta_amounts)\r\n\r\n\r\n@external\r\ndef remove_liquidity(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    _min_amounts: uint256[N_ALL_COINS],\r\n    _use_eth: bool = False,\r\n    _receiver: address = msg.sender,\r\n) -> uint256[N_ALL_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _pool Address of the pool to withdraw from\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _use_eth Use raw ETH\r\n    @param _receiver Address that receives the LP tokens\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    lp_token: address = CurveMeta(_pool).token()\r\n    ERC20(lp_token).transferFrom(msg.sender, self, _burn_amount)\r\n\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    CurveMeta(_pool).remove_liquidity(\r\n        _burn_amount,\r\n        [_min_amounts[0], 0],\r\n        _use_eth,\r\n    )\r\n    lp_amount: uint256 = ERC20(BASE_LP_TOKEN).balanceOf(self)\r\n\r\n    # Withdraw from base\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = _min_amounts[MAX_COIN + i]\r\n    BASE_POOL.remove_liquidity(lp_amount, min_amounts_base)\r\n\r\n    # Transfer all coins out\r\n    coin: address = CurveMeta(_pool).coins(0)\r\n    amounts[0] = self._send(coin, _receiver, _use_eth)\r\n\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    for i in range(MAX_COIN, N_ALL_COINS):\r\n        coin = base_coins[i - MAX_COIN]\r\n        amounts[i] = self._send(coin, _receiver, _use_eth, True)\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    i: uint256,\r\n    _min_amount: uint256,\r\n    _use_eth: bool = False,\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _pool Address of the pool to withdraw from\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of underlying coin to receive\r\n    @param _use_eth Use raw ETH\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    lp_token: address = CurveMeta(_pool).token()\r\n    ERC20(lp_token).transferFrom(msg.sender, self, _burn_amount)\r\n\r\n    if i < MAX_COIN:\r\n        return CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, i, _min_amount, _use_eth, _receiver)\r\n\r\n    # Withdraw a base pool coin\r\n    coin_amount: uint256 = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, MAX_COIN, 0)\r\n\r\n    BASE_POOL.remove_liquidity_one_coin(coin_amount, convert(i - MAX_COIN, int128), _min_amount)\r\n\r\n    coin: address = BASE_COINS[i - MAX_COIN]\r\n    return self._send(coin, _receiver, _use_eth, True)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_pool: address, _token_amount: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing and unwrapping a single coin\r\n    @param _pool Address of the pool to withdraw from\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the underlying coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    if i < MAX_COIN:\r\n        return CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, i)\r\n\r\n    _base_tokens: uint256 = CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n    return BASE_POOL.calc_withdraw_one_coin(_base_tokens, convert(i - MAX_COIN, int128))", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"base_pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"base_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_price\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"},{\"name\":\"_min_dy\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"_dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"_use_eth\",\"type\":\"bool\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_use_eth\",\"type\":\"bool\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.4", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000dcef968d416a41cdac0ed8702fac8128a64241a2000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}