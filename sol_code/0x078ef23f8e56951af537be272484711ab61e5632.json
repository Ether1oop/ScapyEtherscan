{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './access/Ownable2Step.sol';\\n\\nerror TokenVesting_AddressIsZero();\\nerror TokenVesting_AmountExcessive(uint256 amount, uint256 limit);\\nerror TokenVesting_AmountZero();\\nerror TokenVesting_BeneficiaryNoneActiveVestings();\\nerror TokenVesting_ContractIsPaused(bool isPaused);\\nerror TokenVesting_Error(string msg);\\n\\n/**\\n * @title Token Vesting Contract\\n */\\ncontract TokenVesting is Ownable2Step {\\n    using SafeERC20 for IERC20;\\n    /**\\n     * @dev Event is triggered when vesting schedule is changed\\n     * @param _name string vesting schedule name\\n     * @param _amount uint256 vesting schedule amount\\n     */\\n    event VestingScheduleCreated(string _name, uint256 _amount);\\n\\n    /**\\n     * @dev Event is triggered when vesting schedule is revoked\\n     * @param _name string vesting schedule name\\n     */\\n    event VestingScheduleRevoked(string _name);\\n\\n    /**\\n     * @dev Event is triggered when allocation added\\n     * @param _beneficiary address of beneficiary\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     * @param _currentAllocation uint256 current allocation for vesting schedule\\n     */\\n    event AllocationAdded(\\n        address _beneficiary,\\n        string _vestingScheduleName,\\n        uint256 _amount,\\n        uint256 _currentAllocation\\n    );\\n\\n    /**\\n     * @dev Event is triggered when allocation removed\\n     * @param _beneficiary address of beneficiary\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     * @param _currentAllocation uint256 current allocation for vesting schedule\\n     */\\n    event AllocationRemoved(\\n        address _beneficiary,\\n        string _vestingScheduleName,\\n        uint256 _amount,\\n        uint256 _currentAllocation\\n    );\\n\\n    /**\\n     * @dev Event is triggered when contract paused or unpaused\\n     * @param _paused bool is paused\\n     */\\n    event ContractPaused(bool _paused);\\n\\n    /**\\n     * @dev Event is triggered when beneficiary deleted\\n     * @param _beneficiary address of beneficiary\\n     */\\n    event BeneficiaryDeleted(address _beneficiary);\\n\\n    /**\\n     * @dev Event is triggered when tokens claimed\\n     * @param _beneficiary address of beneficiary\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     * @param _releasedAmount uint256 released amount of beneficiary tokens for current vesting schedule\\n     */\\n    event TokensClaimed(address _beneficiary, string _vestingScheduleName, uint256 _amount, uint256 _releasedAmount);\\n\\n    struct VestingSchedule {\\n        string name;\\n        uint256 terms;\\n        uint256 cliff;\\n        uint256 duration;\\n        uint256 totalAmount;\\n        uint256 allocatedAmount;\\n        uint256 releasedAmount;\\n        bool initialized;\\n        bool revoked;\\n    }\\n\\n    struct Vesting {\\n        string name;\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct VestingExpectation {\\n        Vesting vesting;\\n        uint256 beneficiaryAmount;\\n    }\\n\\n    struct BeneficiaryOverview {\\n        string name;\\n        uint256 terms;\\n        uint256 cliff;\\n        uint256 duration;\\n        uint256 allocatedAmount;\\n        uint256 withdrawnAmount;\\n    }\\n\\n    struct Beneficiary {\\n        uint256 allocatedAmount;\\n        uint256 withdrawnAmount;\\n    }\\n\\n    IERC20 private immutable token;\\n    string[] private vestingSchedulesNames;\\n    uint256 private vestingSchedulesTotalReservedAmount;\\n    uint256 private validVestingSchedulesCount;\\n    uint256 public tgeTimestamp;\\n    address public treasuryAddress;\\n    bool public paused;\\n    mapping(string => VestingSchedule) private vestingSchedules;\\n    mapping(address => mapping(string => Beneficiary)) private beneficiaries;\\n\\n    constructor(\\n        address _tokenContractAddress,\\n        uint256 _tgeTimestamp,\\n        address _treasuryAddress\\n    ) {\\n        if (_tokenContractAddress == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        if (_tgeTimestamp == 0) {\\n            revert TokenVesting_Error('The TGE Timestamp is zero!');\\n        }\\n        if (_treasuryAddress == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        token = IERC20(_tokenContractAddress);\\n        tgeTimestamp = _tgeTimestamp;\\n        treasuryAddress = _treasuryAddress;\\n    }\\n\\n    /**\\n     * @dev Revokes all schedules and sends tokens to a set address\\n     */\\n    function emergencyWithdrawal() external onlyOwner {\\n        if (token.balanceOf(address(this)) == 0) {\\n            revert TokenVesting_Error('Nothing to withdraw!');\\n        }\\n        string[] memory vestingScheduleNames = getValidVestingScheduleNames();\\n        uint256 scheduleNamesLength = vestingScheduleNames.length;\\n        for (uint256 i = 0; i < scheduleNamesLength; i++) {\\n            _revokeVestingSchedule(vestingScheduleNames[i]);\\n        }\\n        token.safeTransfer(treasuryAddress, token.balanceOf(address(this)));\\n    }\\n\\n    /**\\n     * @dev Pauses contract\\n     */\\n    function pauseContract() external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        paused = true;\\n        emit ContractPaused(paused);\\n    }\\n\\n    /**\\n     * @dev Unpauses contract\\n     */\\n    function unpauseContract() external onlyOwner {\\n        if (!paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        paused = false;\\n        emit ContractPaused(paused);\\n    }\\n\\n    /**\\n     * @dev Gets ERC20 token address\\n     * @return address of token\\n     */\\n    function getToken() external view returns (address) {\\n        return address(token);\\n    }\\n\\n    /**\\n     * @dev Creates a new vesting schedule\\n     * @param _name string vesting schedule name\\n     * @param _terms vesting schedule terms in seconds\\n     * @param _cliff cliff in seconds after which tokens will begin to vest\\n     * @param _duration the number of terms during which the tokens will be vested\\n     * @param _amount total amount of tokens to be released at the end of the vesting\\n     */\\n    function createVestingSchedule(\\n        string calldata _name,\\n        uint256 _terms,\\n        uint256 _cliff,\\n        uint256 _duration,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        uint256 unusedAmount = getUnusedAmount();\\n\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (bytes(_name).length == 0) {\\n            revert TokenVesting_Error('The name is empty!');\\n        }\\n        if (!isNameUnique(_name)) {\\n            revert TokenVesting_Error('The name is duplicated!');\\n        }\\n        if (unusedAmount < _amount) {\\n            revert TokenVesting_AmountExcessive(_amount, unusedAmount);\\n        }\\n        if (_duration == 0) {\\n            revert TokenVesting_Error('The duration is zero!');\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (_terms == 0) {\\n            revert TokenVesting_Error('The terms are zero!');\\n        }\\n        vestingSchedules[_name] = VestingSchedule({\\n            name: _name,\\n            terms: _terms,\\n            cliff: _cliff,\\n            duration: _duration,\\n            totalAmount: _amount,\\n            allocatedAmount: 0,\\n            releasedAmount: 0,\\n            initialized: true,\\n            revoked: false\\n        });\\n        vestingSchedulesTotalReservedAmount += _amount;\\n        vestingSchedulesNames.push(_name);\\n        validVestingSchedulesCount++;\\n        emit VestingScheduleCreated(_name, _amount);\\n    }\\n\\n    /**\\n     * @dev Revokes vesting schedule\\n     * @param _name string schedule name\\n     */\\n    function revokeVestingSchedule(string memory _name) external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        _revokeVestingSchedule(_name);\\n    }\\n\\n    /**\\n     * @dev Gets the vesting schedule information\\n     * @param _name string vesting schedule name\\n     * @return VestingSchedule structure information\\n     */\\n    function getVestingSchedule(string calldata _name) external view returns (VestingSchedule memory) {\\n        return vestingSchedules[_name];\\n    }\\n\\n    /**\\n     * @dev Gets all vesting schedules\\n     * @return VestingSchedule structure list of all vesting schedules\\n     */\\n    function getAllVestingSchedules() external view returns (VestingSchedule[] memory) {\\n        uint256 scheduleNamesLength = vestingSchedulesNames.length;\\n        if (scheduleNamesLength == 0) {\\n            revert TokenVesting_Error('No vesting schedules!');\\n        }\\n        VestingSchedule[] memory allVestingSchedules = new VestingSchedule[](scheduleNamesLength);\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            allVestingSchedules[i] = vestingSchedules[vestingSchedulesNames[i]];\\n        }\\n        return allVestingSchedules;\\n    }\\n\\n    /**\\n     * @dev Gets all valid vesting schedules\\n     * @return VestingSchedule structure list of all active vesting schedules\\n     */\\n    function getValidVestingSchedules() external view returns (VestingSchedule[] memory) {\\n        if (validVestingSchedulesCount == 0) {\\n            revert TokenVesting_Error('No valid vesting schedules!');\\n        }\\n        VestingSchedule[] memory validVestingSchedules = new VestingSchedule[](validVestingSchedulesCount);\\n        uint32 j;\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (isVestingScheduleValid(vestingSchedulesNames[i])) {\\n                validVestingSchedules[j] = vestingSchedules[vestingSchedulesNames[i]];\\n                j++;\\n            }\\n        }\\n        return validVestingSchedules;\\n    }\\n\\n    /**\\n     * INDECISIVE do we need it?\\n     * @dev Gets vesting schedules count\\n     * @return uint256 number of vesting schedules\\n     */\\n    function getVestingSchedulesCount() external view returns (uint256) {\\n        return vestingSchedulesNames.length;\\n    }\\n\\n    /**\\n     * INDECISIVE do we need it?\\n     * @dev Gets valid vesting schedules count\\n     * @return uint256 number of vesting schedules\\n     */\\n    function getValidVestingSchedulesCount() external view returns (uint256) {\\n        return validVestingSchedulesCount;\\n    }\\n\\n    /**\\n     * @dev Increases vesting schedule total amount\\n     * @param _name string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function increaseVestingScheduleTotalAmount(uint256 _amount, string calldata _name) external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (isNameUnique(_name)) {\\n            revert TokenVesting_Error('The name doesnt exist!');\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (getUnusedAmount() < _amount) {\\n            revert TokenVesting_AmountExcessive(_amount, getUnusedAmount());\\n        }\\n        vestingSchedules[_name].totalAmount += _amount;\\n        vestingSchedulesTotalReservedAmount += _amount;\\n    }\\n\\n    /**\\n     * @dev Decreases vesting schedule total amount\\n     * @param _name string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function decreaseVestingScheduleTotalAmount(uint256 _amount, string calldata _name) external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (isNameUnique(_name)) {\\n            revert TokenVesting_Error('The name doesnt exist!');\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (getScheduleUnallocatedAmount(_name) < _amount) {\\n            revert TokenVesting_AmountExcessive(_amount, getScheduleUnallocatedAmount(_name));\\n        }\\n        vestingSchedules[_name].totalAmount -= _amount;\\n        vestingSchedulesTotalReservedAmount -= _amount;\\n    }\\n\\n    /**\\n     * @dev Adds beneficiary allocation\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function addBeneficiaryAllocation(\\n        address _beneficiary,\\n        string memory _vestingScheduleName,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (_beneficiary == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        if (bytes(_vestingScheduleName).length == 0) {\\n            revert TokenVesting_Error('The name is empty!');\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (!isVestingScheduleValid(_vestingScheduleName)) {\\n            revert TokenVesting_Error('The schedule is invalid!');\\n        }\\n        if (getScheduleUnallocatedAmount(_vestingScheduleName) < _amount) {\\n            revert TokenVesting_AmountExcessive(_amount, getScheduleUnallocatedAmount(_vestingScheduleName));\\n        }\\n\\n        beneficiaries[_beneficiary][_vestingScheduleName].allocatedAmount += _amount;\\n        vestingSchedules[_vestingScheduleName].allocatedAmount += _amount;\\n\\n        emit AllocationAdded(\\n            _beneficiary,\\n            _vestingScheduleName,\\n            _amount,\\n            beneficiaries[_beneficiary][_vestingScheduleName].allocatedAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Removes beneficiary allocation\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function removeBeneficiaryAllocation(\\n        address _beneficiary,\\n        string calldata _vestingScheduleName,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (_beneficiary == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (bytes(_vestingScheduleName).length == 0) {\\n            revert TokenVesting_Error('The name is empty!');\\n        }\\n        if (!isVestingScheduleValid(_vestingScheduleName)) {\\n            revert TokenVesting_Error('The name is invalid!');\\n        }\\n        if (getBeneficiaryUnreleasedAmount(_beneficiary, _vestingScheduleName) < _amount) {\\n            revert TokenVesting_AmountExcessive(\\n                _amount,\\n                getBeneficiaryUnreleasedAmount(_beneficiary, _vestingScheduleName)\\n            );\\n        }\\n        beneficiaries[_beneficiary][_vestingScheduleName].allocatedAmount -= _amount;\\n        vestingSchedules[_vestingScheduleName].allocatedAmount -= _amount;\\n\\n        emit AllocationRemoved(\\n            _beneficiary,\\n            _vestingScheduleName,\\n            _amount,\\n            beneficiaries[_beneficiary][_vestingScheduleName].allocatedAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return Beneficiary struct\\n     */\\n    function getBeneficiary(address _beneficiary, string calldata _vestingScheduleName)\\n        external\\n        view\\n        returns (Beneficiary memory)\\n    {\\n        return beneficiaries[_beneficiary][_vestingScheduleName];\\n    }\\n\\n    /**\\n     * @dev Deletes beneficiary\\n     * @param _beneficiary address of user\\n     */\\n    function deleteBeneficiary(address _beneficiary) external onlyOwner {\\n        if (_beneficiary == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        string[] memory scheduleNames = getBeneficiaryActiveScheduleNames(_beneficiary);\\n        uint256 scheduleNamesLength = scheduleNames.length;\\n        if (scheduleNamesLength == 0) {\\n            revert TokenVesting_BeneficiaryNoneActiveVestings();\\n        }\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            uint256 unreleasedAmount = getBeneficiaryUnreleasedAmount(_beneficiary, scheduleNames[i]);\\n            beneficiaries[_beneficiary][scheduleNames[i]].allocatedAmount -= unreleasedAmount;\\n            vestingSchedules[scheduleNames[i]].allocatedAmount -= unreleasedAmount;\\n        }\\n        emit BeneficiaryDeleted(_beneficiary);\\n    }\\n\\n    /**\\n     * @dev Gets the beneficiary's next vestings\\n     * @param _beneficiary address of user\\n     * @return VestingExpectations[] structure\\n     */\\n    function getBeneficiaryNextVestings(address _beneficiary) external view returns (VestingExpectation[] memory) {\\n        string[] memory scheduleNames = getBeneficiaryActiveScheduleNames(_beneficiary);\\n        uint256 scheduleNamesLength = scheduleNames.length;\\n        if (scheduleNamesLength == 0) {\\n            revert TokenVesting_BeneficiaryNoneActiveVestings();\\n        }\\n        VestingExpectation[] memory vestingExpectations = new VestingExpectation[](scheduleNamesLength);\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            VestingExpectation memory vestingExpectation = VestingExpectation({\\n                vesting: getNextVesting(scheduleNames[i]),\\n                beneficiaryAmount: getNextUnlockAmount(_beneficiary, scheduleNames[i])\\n            });\\n            vestingExpectations[i] = vestingExpectation;\\n        }\\n        return vestingExpectations;\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary overview\\n     * @param _beneficiary address of user\\n     * @return BeneficiaryOverview[] structure\\n     */\\n    function getBeneficiaryOverview(address _beneficiary) external view returns (BeneficiaryOverview[] memory) {\\n        string[] memory scheduleNames = getBeneficiaryScheduleNames(_beneficiary);\\n        uint256 scheduleNamesLength = scheduleNames.length;\\n        if (scheduleNamesLength == 0) {\\n            revert TokenVesting_BeneficiaryNoneActiveVestings();\\n        }\\n        BeneficiaryOverview[] memory beneficiaryOverview = new BeneficiaryOverview[](scheduleNamesLength);\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            BeneficiaryOverview memory overview = BeneficiaryOverview({\\n                name: scheduleNames[i],\\n                terms: vestingSchedules[scheduleNames[i]].terms,\\n                cliff: vestingSchedules[scheduleNames[i]].cliff,\\n                duration: vestingSchedules[scheduleNames[i]].duration,\\n                allocatedAmount: beneficiaries[_beneficiary][scheduleNames[i]].allocatedAmount,\\n                withdrawnAmount: beneficiaries[_beneficiary][scheduleNames[i]].withdrawnAmount\\n            });\\n            beneficiaryOverview[i] = overview;\\n        }\\n        return beneficiaryOverview;\\n    }\\n\\n    /**\\n     * @dev Gets the next vesting\\n     * @param _vestingScheduleName string\\n     * @return Vesting structure\\n     */\\n    function getNextVesting(string memory _vestingScheduleName) public view returns (Vesting memory) {\\n        if (isVestingScheduleFinished(_vestingScheduleName)) {\\n            revert TokenVesting_Error('The schedule is finished!');\\n        }\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        uint256 passedVestings = getPassedVestings(_vestingScheduleName);\\n        Vesting memory vesting;\\n        vesting.name = _vestingScheduleName;\\n        vesting.timestamp = tgeTimestamp + vestingSchedule.cliff + vestingSchedule.terms * (passedVestings + 1);\\n        vesting.amount = vestingSchedule.totalAmount / vestingSchedule.duration;\\n        return vesting;\\n    }\\n\\n    /**\\n     * INDECISIVE public/internal\\n     * @dev Gets the amount of tokens locked for all schedules\\n     * @return uint256 unreleased amount of tokens\\n     */\\n    function getTotalLockedAmount() public view returns (uint256) {\\n        uint256 lockedAmount;\\n        string[] memory vestingScheduleNames = getAllVestingScheduleNames();\\n        uint256 scheduleNamesLength = vestingScheduleNames.length;\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            lockedAmount += getScheduleLockedAmount(vestingScheduleNames[i]);\\n        }\\n        return lockedAmount;\\n    }\\n\\n    /**\\n     * @dev Claims caller's tokens\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function claimTokens(string memory _vestingScheduleName, uint256 _amount) public {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        if (bytes(_vestingScheduleName).length == 0) {\\n            revert TokenVesting_Error('The name is empty!');\\n        }\\n        if (!isVestingScheduleValid(_vestingScheduleName)) {\\n            revert TokenVesting_Error('The name is invalid!');\\n        }\\n        if (_amount == 0) {\\n            revert TokenVesting_AmountZero();\\n        }\\n        if (getScheduleLockedAmount(_vestingScheduleName) < _amount) {\\n            revert TokenVesting_AmountExcessive(_amount, getScheduleLockedAmount(_vestingScheduleName));\\n        }\\n        if (getBeneficiaryUnclaimedAmount(_msgSender(), _vestingScheduleName) < _amount) {\\n            revert TokenVesting_AmountExcessive(\\n                _amount,\\n                getBeneficiaryUnclaimedAmount(_msgSender(), _vestingScheduleName)\\n            );\\n        }\\n        sendTokens(_msgSender(), _amount);\\n        vestingSchedulesTotalReservedAmount -= _amount;\\n        vestingSchedules[_vestingScheduleName].releasedAmount += _amount;\\n        beneficiaries[_msgSender()][_vestingScheduleName].withdrawnAmount += _amount;\\n        emit TokensClaimed(\\n            _msgSender(),\\n            _vestingScheduleName,\\n            _amount,\\n            beneficiaries[_msgSender()][_vestingScheduleName].withdrawnAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims all caller's tokens for selected vesting schedule\\n     * @param _vestingScheduleName string vesting schedule name\\n     */\\n    function claimAllTokensForVestingSchedule(string memory _vestingScheduleName) public {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        uint256 amount = getBeneficiaryUnclaimedAmount(_msgSender(), _vestingScheduleName);\\n        claimTokens(_vestingScheduleName, amount);\\n    }\\n\\n    /**\\n     * @dev Claims all caller's tokens\\n     */\\n    function claimAllTokens() public {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        string[] memory unclaimedVestingScheduleNames = getBeneficiaryUnclaimedScheduleNames(_msgSender());\\n        uint256 scheduleNamesLength = unclaimedVestingScheduleNames.length;\\n        if (scheduleNamesLength == 0) {\\n            revert TokenVesting_Error('There are no unclaimed tokens!');\\n        }\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            claimAllTokensForVestingSchedule(unclaimedVestingScheduleNames[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens not involved in vesting schedules\\n     * @return uint256 amount of tokens\\n     */\\n    function getUnusedAmount() public view returns (uint256) {\\n        return token.balanceOf(address(this)) - vestingSchedulesTotalReservedAmount;\\n    }\\n\\n    /**\\n     * @dev Returns current timestamp\\n     * @return uint256 timestamp\\n     */\\n    function getCurrentTimestamp() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Checks is vesting schedule name unique\\n     * @param _name string vesting schedule name\\n     */\\n    function isNameUnique(string memory _name) internal view returns (bool) {\\n        uint256 scheduleNamesLength = vestingSchedulesNames.length;\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            if (keccak256(bytes(vestingSchedulesNames[i])) == keccak256(bytes(_name))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Checks is vesting schedule valid\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return bool true if active\\n     */\\n    function isVestingScheduleValid(string memory _vestingScheduleName) internal view returns (bool) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return vestingSchedule.initialized && !vestingSchedule.revoked;\\n    }\\n\\n    /**\\n     * @dev Gets all vesting schedule names\\n     * @return string list of schedule names\\n     */\\n    function getAllVestingScheduleNames() internal view virtual returns (string[] memory) {\\n        return vestingSchedulesNames;\\n    }\\n\\n    /**\\n     * @dev Gets all valid vesting schedule names\\n     * @return string list of schedule names\\n     */\\n    function getValidVestingScheduleNames() internal view returns (string[] memory) {\\n        string[] memory validVestingSchedulesNames = new string[](validVestingSchedulesCount);\\n        uint256 scheduleNamesLength = vestingSchedulesNames.length;\\n        uint32 j;\\n        for (uint32 i = 0; i < scheduleNamesLength; i++) {\\n            if (isVestingScheduleValid(vestingSchedulesNames[i])) {\\n                validVestingSchedulesNames[j] = vestingSchedulesNames[i];\\n                j++;\\n            }\\n        }\\n        return validVestingSchedulesNames;\\n    }\\n\\n    /**\\n     * @dev Revokes vesting schedule\\n     * @param _name string schedule name\\n     */\\n    function _revokeVestingSchedule(string memory _name) internal {\\n        if (isNameUnique(_name)) {\\n            revert TokenVesting_Error('The name doesnt exist!');\\n        }\\n        if (vestingSchedules[_name].revoked == true) {\\n            revert TokenVesting_Error('The schedule is revoked!');\\n        }\\n        vestingSchedules[_name].revoked = true;\\n        vestingSchedulesTotalReservedAmount -= getScheduleUnreleasedAmount(_name);\\n        validVestingSchedulesCount--;\\n        emit VestingScheduleRevoked(_name);\\n    }\\n\\n    /**\\n     * @dev Checks is vesting schedule started\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return bool true if started\\n     */\\n    function isVestingScheduleStarted(string memory _vestingScheduleName) internal view returns (bool) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return getCurrentTimestamp() >= tgeTimestamp + vestingSchedule.cliff;\\n    }\\n\\n    /**\\n     * @dev Checks is vesting schedule finished\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return bool true if finished\\n     */\\n    function isVestingScheduleFinished(string memory _vestingScheduleName) internal view returns (bool) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return\\n            getCurrentTimestamp() >\\n            tgeTimestamp + vestingSchedule.cliff + vestingSchedule.duration * vestingSchedule.terms;\\n    }\\n\\n    /**\\n     * @dev Gets the vesting schedule passed duration\\n     * @param _vestingScheduleName string\\n     * @return uint256 number of passed vesting\\n     */\\n    function getPassedVestings(string memory _vestingScheduleName) internal view returns (uint256) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        if (isVestingScheduleStarted(_vestingScheduleName)) {\\n            return (getCurrentTimestamp() - tgeTimestamp - vestingSchedule.cliff) / vestingSchedule.terms;\\n        }\\n        if (isVestingScheduleFinished(_vestingScheduleName)) {\\n            return vestingSchedule.duration;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens that can be released from vesting schedule\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 unreleased amount of tokens\\n     */\\n    function getScheduleUnreleasedAmount(string memory _vestingScheduleName) internal view returns (uint256) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return vestingSchedule.totalAmount - vestingSchedule.releasedAmount;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of locked tokens\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 locked amount of tokens\\n     */\\n    function getScheduleLockedAmount(string memory _vestingScheduleName) internal view returns (uint256) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return vestingSchedule.allocatedAmount - vestingSchedule.releasedAmount;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens that can be allocated from vesting schedule\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 unallocated amount of tokens\\n     */\\n    function getScheduleUnallocatedAmount(string memory _vestingScheduleName) internal view returns (uint256) {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return vestingSchedule.totalAmount - vestingSchedule.allocatedAmount;\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary schedule names\\n     * @param _beneficiary address of user\\n     * @return string[] array schedule names assigned to beneficiary\\n     */\\n    function getBeneficiaryScheduleNames(address _beneficiary) internal view returns (string[] memory) {\\n        uint256 beneficiaryScheduleNamesCount;\\n        string[] memory vestingScheduleNames = getValidVestingScheduleNames();\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (beneficiaries[_beneficiary][vestingScheduleNames[i]].allocatedAmount > 0) {\\n                beneficiaryScheduleNamesCount++;\\n            }\\n        }\\n\\n        string[] memory beneficiaryScheduleNames = new string[](beneficiaryScheduleNamesCount);\\n        uint256 j;\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (beneficiaries[_beneficiary][vestingScheduleNames[i]].allocatedAmount > 0) {\\n                beneficiaryScheduleNames[j] = vestingScheduleNames[i];\\n                j++;\\n            }\\n        }\\n        return beneficiaryScheduleNames;\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary unclaimed schedule names\\n     * @param _beneficiary address of user\\n     * @return string[] array schedule names assigned to beneficiary\\n     */\\n    function getBeneficiaryUnclaimedScheduleNames(address _beneficiary) internal view returns (string[] memory) {\\n        uint256 beneficiaryScheduleNamesCount;\\n        string[] memory vestingScheduleNames = getValidVestingScheduleNames();\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (getBeneficiaryUnclaimedAmount(_beneficiary, vestingScheduleNames[i]) > 0) {\\n                beneficiaryScheduleNamesCount++;\\n            }\\n        }\\n\\n        string[] memory beneficiaryScheduleNames = new string[](beneficiaryScheduleNamesCount);\\n        uint256 j;\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (getBeneficiaryUnclaimedAmount(_beneficiary, vestingScheduleNames[i]) > 0) {\\n                beneficiaryScheduleNames[j] = vestingScheduleNames[i];\\n                j++;\\n            }\\n        }\\n        return beneficiaryScheduleNames;\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary active schedule names\\n     * @param _beneficiary address of user\\n     * @return string[] array schedule names assigned to beneficiary\\n     */\\n    function getBeneficiaryActiveScheduleNames(address _beneficiary) internal view returns (string[] memory) {\\n        uint256 beneficiaryActiveScheduleNamesCount;\\n        string[] memory vestingScheduleNames = getValidVestingScheduleNames();\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (\\n                beneficiaries[_beneficiary][vestingScheduleNames[i]].allocatedAmount > 0 &&\\n                !isVestingScheduleFinished(vestingScheduleNames[i])\\n            ) {\\n                beneficiaryActiveScheduleNamesCount++;\\n            }\\n        }\\n\\n        string[] memory beneficiaryActiveScheduleNames = new string[](beneficiaryActiveScheduleNamesCount);\\n        uint256 j;\\n        for (uint32 i = 0; i < validVestingSchedulesCount; i++) {\\n            if (\\n                beneficiaries[_beneficiary][vestingScheduleNames[i]].allocatedAmount > 0 &&\\n                !isVestingScheduleFinished(vestingScheduleNames[i])\\n            ) {\\n                beneficiaryActiveScheduleNames[j] = vestingScheduleNames[i];\\n                j++;\\n            }\\n        }\\n        return beneficiaryActiveScheduleNames;\\n    }\\n\\n    /**\\n     * @dev Gets beneficiary next unlocked amount\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string\\n     * @return uint256 allocation\\n     */\\n    function getNextUnlockAmount(address _beneficiary, string memory _vestingScheduleName)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        return beneficiaries[_beneficiary][_vestingScheduleName].allocatedAmount / vestingSchedule.duration;\\n    }\\n\\n    /**\\n     * @dev Returns the unlocked amount of tokens for selected beneficiary and vesting schedule\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 unlocked amount of tokens\\n     */\\n    function getBeneficiaryUnlockedAmount(address _beneficiary, string memory _vestingScheduleName)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        VestingSchedule memory vestingSchedule = vestingSchedules[_vestingScheduleName];\\n        Beneficiary memory beneficiary = beneficiaries[_beneficiary][_vestingScheduleName];\\n        if (isVestingScheduleFinished(_vestingScheduleName)) {\\n            return beneficiary.allocatedAmount;\\n        }\\n        return (getPassedVestings(_vestingScheduleName) * beneficiary.allocatedAmount) / vestingSchedule.duration;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens that can be claimed by beneficiary\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 unclaimed amount of tokens\\n     */\\n    function getBeneficiaryUnclaimedAmount(address _beneficiary, string memory _vestingScheduleName)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 unlockedAmount = getBeneficiaryUnlockedAmount(_beneficiary, _vestingScheduleName);\\n        return unlockedAmount - beneficiaries[_beneficiary][_vestingScheduleName].withdrawnAmount;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens that unreleased by beneficiary\\n     * @param _beneficiary address of user\\n     * @param _vestingScheduleName string vesting schedule name\\n     * @return uint256 unclaimed amount of tokens\\n     */\\n    function getBeneficiaryUnreleasedAmount(address _beneficiary, string memory _vestingScheduleName)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Beneficiary memory beneficiary = beneficiaries[_beneficiary][_vestingScheduleName];\\n        return beneficiary.allocatedAmount - beneficiary.withdrawnAmount;\\n    }\\n\\n    /**\\n     * @dev Sends tokens to selected address\\n     * @param _to address of account\\n     * @param _amount uint256 amount of tokens\\n     */\\n    function sendTokens(address _to, uint256 _amount) internal {\\n        if (_to == address(0x0)) {\\n            revert TokenVesting_AddressIsZero();\\n        }\\n        if (_amount > getTotalLockedAmount()) {\\n            revert TokenVesting_AmountExcessive(_amount, getTotalLockedAmount());\\n        }\\n        token.safeTransfer(_to, _amount);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        if (paused) {\\n            revert TokenVesting_ContractIsPaused(paused);\\n        }\\n        super.transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.9;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\nerror Ownable_Error(string msg);\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert Ownable_Error('Caller is not the owner!');\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert Ownable_Error('New owner is a zero address!');\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity 0.8.9;\\n\\nimport './Ownable.sol';\\n\\nerror Ownable2Step_Error(string msg);\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert Ownable2Step_Error('New owner is a zero address!');\\n        }\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert Ownable2Step_Error('Caller is not the new owner!');\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tgeTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"Ownable2Step_Error\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"Ownable_Error\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenVesting_AddressIsZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"TokenVesting_AmountExcessive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenVesting_AmountZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenVesting_BeneficiaryNoneActiveVestings\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"TokenVesting_ContractIsPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"TokenVesting_Error\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentAllocation\",\"type\":\"uint256\"}],\"name\":\"AllocationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentAllocation\",\"type\":\"uint256\"}],\"name\":\"AllocationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_releasedAmount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"VestingScheduleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"VestingScheduleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBeneficiaryAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"}],\"name\":\"claimAllTokensForVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_terms\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"decreaseVestingScheduleTotalAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"deleteBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVestingSchedules\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"terms\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"allocatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenVesting.Beneficiary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getBeneficiaryNextVestings\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenVesting.Vesting\",\"name\":\"vesting\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"beneficiaryAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenVesting.VestingExpectation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getBeneficiaryOverview\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"terms\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenVesting.BeneficiaryOverview[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"}],\"name\":\"getNextVesting\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenVesting.Vesting\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnusedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidVestingSchedules\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"terms\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidVestingSchedulesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getVestingSchedule\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"terms\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocatedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"}],\"internalType\":\"struct TokenVesting.VestingSchedule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingSchedulesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"increaseVestingScheduleTotalAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_vestingScheduleName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeBeneficiaryAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"revokeVestingSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tgeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenVesting", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000f9ca9523e5b5a42c3018c62b084db8543478c40000000000000000000000000000000000000000000000000000000000638fd780000000000000000000000000d62ba193d0c0c556d4d37dbbc5e431330471a557", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}