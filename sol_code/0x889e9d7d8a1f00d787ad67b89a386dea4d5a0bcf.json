{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Tomie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\nM#..MMMMMp` .(+MM9!..gMMMM9\\\"74T\\\"\\\"MaggqHmo ?MN.d!dF.M<CdndNYGJ@^  ..J\\\"1(+g#BMNHgggJgNNHHmJmJ..dHMMMMMMMMMMMMMMMMM\\\\ ({{._.>.(YWMMN#9!(#MMMMt .(gMM@1aJJJ._ZMMN(mMMMN@?MMMaM#^.MMMNdMM]\\nMNmgMM@.MF.(MF! ..MM#9>! ..JdMMHMNe(TNg?TNa,MMM Mbd#J.NMB\\\\d=.J!.kY1JMMM5(MMMMMM9YWQHMMNNMm+gMMNHHMNHMMMMMMMMMMM#~.(` (?jWa.!:?TMMNYHM# ._~ .,T\\\"! .(\\\"TMMMM@^?MMMBYNe.gMMMMNxJMMYTMMM]\\nMM\\\"\\\"\\\"HMHMNdM) .+MM5~` ..W\\\"!..JNMMMMMMMMMMMMMMMM&d#M#PJM@xujMD.M#<d#QB'(QgMM8~.JMagNNMMMMMMMMMMaJ/TMNMNNMMNMMMMM%?(P(!-.   .TJ!.!Te  dM<~!`  ..(&J(J<7<<<_(Ng=! .,,MMMM#\\\"= .dM\\\\ .MMM]\\nMMggMMMN, ?9!.MM=!  .J\\\"`..MMMMMMMMMMMMMMMMMMMMMMMNMMNMM#~dMEGM@(M5dhJHMMMHSkggMMMMTHMMakWMMNgVMMNm+,TNgMkM#MMMM@<1N ! .:    .4/ .(N!   ..JY\\\"31-?!     ....?1-V\\\"^   _\\\"\\\"   .MMNg,.MMM]\\nT\\\"=`  dMMr .MM=   .#= .dMMMMMMMMMMMMMMMMMMMMMMMMMMMMNjd#dHMuM#jMX8dSBv5J6yGYT5c(77zZG,7HMNJHMMNgTMNe?YJHMNMMMMNN&.d; -?.   `..?C  .mJY=<.JJ7<..gVY7<_   ..gB^    `  ..,?!   4JMNMMM%\\n   ..M@   .MD   ,d^.(MMMMMMMMMMYTMNNMMMMMMMMMMMMMMMMMMM#MS@#MH4HwdG.^?t /(I,(CTTu&-.?1Wx4WMN(MNJTNHMMN,Tv\\\"MMMWMMb .N!>` ..?<!  ..d07WgkYn+HY\\\"<-~!` .....J+ggg+-.JZC+.      (d#.W@dM]\\nMMM\\\"M9.  (M^  .<Z~(MMMBuMMM9-(NgMMMMMMMMMMMMMMMMMMMMM#MNMgMHMn?kIjyk+&.JJHuJ0c(-~!(T-. 7w&TdMm7Nm.TNHMMe(& -HNHMN, Jb.>! .<-1dMB&dNYUNMB=-~+..J+NMMMMHQggQHHKVY\\\"7?7\\\"\\\"YSQJ.. 7Mm,.M7]\\nMMF .!  jB``.z(Y -MM\\\"(MMMBJNMBmMMM94QgMMMMMMMMMMHBWHMMMNJKMMM2(:dH9+<!(Co.<UJ?<i~.?! ?& ?NdJ?SMmN?, TmH4BJo  TVHKTn.N-,?\\\"<ugMNd#9&&MMMHHMMMMMMMMMMMMMMMMMMMMMMgHTYBQ+... _7T3(JHB'.]\\nMD ,`  (@` ,(zK.dM@-dMMMM#T6jMMBggMMMMMMMMMMMMMMMMMMMMMMNmd#$j>,y1uRI(>. +HJ\\\\i(J?-    ?1.jJHX,?HHHgm.(MNJ+Tp  ?o(UZVXRydMmMMMMMMMMQQgMMMMMMMBYW#\\\"7!~??7\\\"\\\"WMMNNa.,?Ya, _7\\\"YSaJ..-?=j]\\nN.!.NR.#` J.CJ (M5(MMMM@J<JWY(MMMMMMMMMMMMMMMMNgMMMMMMNHYV9zJI.ZO<vzmW1},UcugMmJ-,l  .i[(-7xTmk-I7mhJw~4o <,N&_JN@1zOHWQMB\\\"^(dMNgMMMMMMMmaggNNNNNNNNNNggggggggMMMMNgv\\\"Wk7!`.JNM#_??]\\nM:.MM#M!.2.C.%(MmMM5dMS=/+BQMMMMMMMMMMMMMMMMMMMMMMHB\\\"4#D>uS<YndjXO<J<<YqaTd#!~(3  Tz.l(z.(,.4J4mZn,4VSw.?o.<(mWWBQYWMMMB~.gMMMMBWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNms.?n.JMHWMN..]\\nN(MMMMt/((j>d`(MMM0dMV<<dNMMMMMM#dMMMWMM#NMMMMjkkQgYWM1mayC(1.d$z$+j<-_TQM#4...?d$-jmWed&,.> (6J8m+?T-?o(TmZjHM84gMMMMNVWMMM#9GgMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNgdMMMMMNgvzh..MMMt.]\\nMMMMFf/.f.@jF.MM#@(M#v(MMMMMMMMMMMBMNMMNMMMM#dNMMMNMN#kKjS^+CNKZj1j}(VJid@[.\\\\(k|(JR(NjNM#NKJ1.  ?uHHQ,7y(T4MHW8WMMMMMY(dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMqBTYMMMNmTMQx_    .]\\nMMMD(Z<v dWMRQM@XhMMKqMMMMMMMMMMM@MMDuMMMMMNMNMNMGG#M>JNNe,!z(SVhJ1(1!(.d@}I.l?SGJdNNMdMMMMMB,1,o.uWov9T=g#UX8dMNMMMQMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNkMMMMMMMMNg.. 7MMm,(THJ, .]\\nM#` (^.!.W#jNMWdWHMMnNMMNMMMMMMM@dM5uMHMMMMMNM\\\\fjZWJMv(NdqF(Z+JH$jk(>_:_MP77?4,.TNNMM5%(_?_m2-1Q?C1Y7BzGMBW5+MMNMMMMMMMMMMMWMMMMMMMMMMMMMMMMMMMMNadTMMMMMMMNHMMMNMMMMMMN&dMMN,  .7T]\\nMF .D k .d@JM$JMMdNMNMMHMBMMMMMMdHMMM5dMMMMWMEJwXT#DMl!JdM2(~K1dHK?d[.!~M#&..l`TMNM$..+ ..,4NWk7rdp /.dM@d6dMMMMMMMMMMMMMNMMMMMMMMMMMMMMMMBMMMMMMNNMMMMMMMMMMNMMMMMMMMMMMMMMMMN,  .]\\n^ .%{.@ (M\\\\(#wdMHdMM@MNM@dMMMM#HMQ#dNMMMNbMM#dMHIJbddj.V@Th.jBmfjM/j?GJ4MM+1/TGJMM4< _1-  -jRnJT4M8-i(MNkkMMMMMMMNdMMMMMMHMMMMMMMMMMMMMHUwvz&-(<TMNMMMMMMMMMMMMMMMMMNJTMMMm,_7HMNa-]\\n  J }J# +M{MN[d]JMMMM@MM1MMMMMdd@MNMMMMMM#MMDd$S1rR,WPw>v;.XdNKkICjZ.>.?,M#7- -?MF.    1,.i(B--(j.WN(MNMMgMMMmMMNdMMMMMMMMMMMMMMMMMMMMMMMMMMNNMHHNJTNdMMmMMMMMMMMMMMMMNmMMMMN, (HMa]\\nJ.! {ZN.dM(#M|d}.M#WMdMNJMMMMMSSW#JMMMMMS#WM+HkW(Zdr<Mhj><?odUJWMm-Zi/(>_?Np. _TWb.-'  ?VnjN, ...Gx7MMQMPMMM#qM#dMMMMMMMMMMMMMMBHggggJ.._7WNgNJHNgdMgHNVkHgMNMNMMMMMMMNMMMMMMMNa,(W]\\n5r  :>MIJMdNMNN[.MNMMMBMjMMM#M#dV#dMMMMM?NX#1MHm.(X4J?NvO[.jKzJ(zCdhJHu:~.dNNG?UMMl.  . .dMkSzo.y~LZMMVMPMMMNMMMMMMMMMMMMMMMMMMNNMM#6z+JTWMMMMNYMNMNmWkMMN?NdMMMNMMMMMMMmMMMMMMp75J[\\n,`  :ZM]zMM@MdMNvMMMNM(MdMMM6MbC%MMMMMMMpdZWdbdMy?,eTJTNsdQKbI(?(>1l~vdm:&4MMRW,1TN,1`: jK.?WM3,Ho[_dMyMbMMMMMMMMMMMMMMMMMMMMMMMHB01+.(dNHMNNMMMadMNMMNMMNMgMNMNMMMNMMMMMMsTMMMMN..]\\nb,  2jdb<MMbMMMM(MMMMMdNHMMMkdw<[JMMMMMMNXWNWiONWPWN+?4dTNMTH0z.>;Jt~_J4vZ} TWSqk?TMm.kYWJhZ3.wJ?mZo(M#M#HMMHMMMMMMMMMMMMMMMNHQkz-  .?WMMMMMMNMMRWMNMNKMMMNMMmMMMgMMMMMMMMMNsJWMMNg]\\nM#`.{.MN>MMbM#dMkMNMMMmNMMMM@dK_1,MMMNWNdMJKMJ(MW9c4#.+(MMMNHhJ1Jx?%.{.x?Ji ._<_71.?MMNNs5, ??(X?GHWkMMKMdMMMMMMMMMMMMMMMMMMWA&-..!??QNNNHMmdMMNNNMMMKMMMMMMMMMMMNNMMMMMMMMMMNe,4JH[\\nMF Z! WM<MMNd#4MNMMMMMMMMMMMNMb_Q,MMMM2MbdNWHd(NRjAJfJQk0??DCWWd&l`c`<(R:.<vzJ<?-.7c??/ (!<<jTWThJWNNdMMMNMMMMMMMMMMMMNmzOZ61-...?1XHgMMMMMMMNHNMNMMNMNWMMMMMm#MMMNMMMMMMMMMMNKY+ (]\\n#`.<_.~MbdMM#MdMMMMMMMMMMM#MMNNi,RMMMMNJWN?MMM(7M;Z~dN9O1l.YGwJWWNJ+.<<w.1??l-1J-_-??9>, .r.)-n.MMMMNNMMMMMMMMMMMMMMMMMMMMNKYUggdUZ3jMHMMNHHMMNWMMMNdMNMkWMNMMNdWNMMNTMMMMMNMMMN,_1]\\n\\\\ /. . (N2MMNMKMMMMMMMMMMMNMM#M#bHdMMMMMpTNdMNR:zbjh{dWk>_~j?ddW0VXBTi.`1.i. (nJG_-<..4m-.<7WMMMMMSqMM4MMMMMMMNgMMQgxwAQWMMMMNg-7a76zJMMNMMNWMMMNHWVMmMMMNMdMMMMmMMMMNxVWNMMMNMMMp1]\\n:.!, . ,M].MMMNMMMMMMMMMMMMMMMMNddNdM#MNda?NJMNyOPJL1JdC_{ ><JC(o.....4Z><C.-<(11<-3._u2dI/qMMMq#ZdMNJMMMMMMMMMNggMMMMMHNNJ7YQTMNgJYQJ7QVMMNMNdMMMkWNdMMMMMMRdMMMNKMNMMKIWMN#MMmMMN]\\n > < ...?N,dMMM2MMMMMMMMMMMNMMMM2MMMMMKMNJ8yMNTNm>,vJ1X&..+MM9TBTBWmXkMNNW,?\\\"U1C+.1-1XM@akjMM#u#dMMMMMMMHMWMMMMMMNdMMadWNJ?HNx,7u7MMNHNhJWZMMMMNMMMNkHNMMdMMNe/MMMMNNTMMNsWMpMNMMmd]\\n,` } ._z_MN/HMMN?MMMMMMMMMMNMMMMNJNMMWMMMNnj6dNVMRO11kQMM=( <..((;`(.?WHHMHn..<G.J-,_-BH:-MM#8MVdMMMMMMH@MMNMMMVMMNHHMMMNJHm,TMN, 7J7NK#MkjWWMMMMMNdMNJMMMmJMNMNyMMMMNJdMM2dNxdN,WM]\\n{..{  2. ?MkZMMMNdMMMMMMMMMM#MMMMbdbHNWMMMMm/,WMmJWN=.#t_<.1.(1+Jd[1d, .TW3? ~.dZn,$OVjNMMMMOWMuMNMMMMMdbMMMNMMbqb4HJM#WHMe7Me TNX+ ?4dMQdTdHHMMNMMNdMMn?MMMJTMMMMHMMMN#MMNJ?MmdNe?]\\ndM:: ,3, (,MK?MMMpMMMMMMMMMMNdMMMMpMRMNW2MMMN,zdJB./Q#1,l1JGX+KMMMMNMMMMMMNNb. 1-TfnmdNRM#d#(M?jMMMMMM#dNNXMMWMHJM<VN(WZOXMNedN,.TNZ+ <TWHMJWKKWMMMMMQMmWxWMMb.#MMmdMMMNgMMMKMMNWMg]\\n.M[!.!.+ .-?NddMMMMMMMMMMMMMMKMMKMMKMNMNU2RWm#HmJJh.H= (W,(NMNMD?> %<~.  (Mn.o. .~dMNdNgM#M#M#.dMMMMMMKdN#OMM#d#WWbjJLj]<IOJNUrTm.(MNVe+ ?MdMpfWHdMMMMRMNX0dMMMmRTWMNJrWMMMMNWMMNJW]\\n(#`(:  t  1:?4RWMM#MMMMMMMMMMMNMNJMM#MNMNkWmdMNsYWRhdi..\\\\1WMM#<>  '.u_.4`.N;.Hk?f1N#(MTNMDMNMN.WMMMMMfN(WN(WVNSMd8N.1X+I (vJo42-.H, 1TNW,(<OdhHmWHdMMNMNMNZeTMMMMNNM#TMgMMMMMMKN?hO]\\nMN.>~.J<- .+( ?eDHMNMMMMMMMMMMMMMMMMMMMMMMNMMMNHM,,4m~<?7WWMMMc?`    zS.jH^.1V(r JMmM8XMNSMMMb(NJMMMMbd[DW[41HPWMtvL.dHz   114dL  7m.(-TNHxcdhvxTkNNMMNMMgMgWYMNdNkWMN-/WMMMMMMMN.Tt\\nM@: .b.!..`1(  1W+WMNMMMMMMMMMMMMNMMMMMMMMMMMMMMNMbjJBe<_.(MMML??`  -..JHN,.y1O(JMMNMZdMW#(MMNdMJMMMMNJNd(N,l.N,MN-?xz#@e.  ??JJ<  .He.1.TNh2>?x3;TMNWMNHMNN#dl4?lMMNcfHMmMMM#NMMb.t\\n .  WMR  .- G. ,rl(?NHMMMMMMMMMMMMNMMMMMMMMMMMMMMMMN(+VNmY7(MN#N&-(.uJy4 _1UTh>.uMMWMdM#dLmMM#MMvMMMMMJMNRdk(l(b(Hd+?mS$WX+- .-<G1, `?N,(-?MNh-?G<4(?NKMMmMMNbTgx,PMMN#(b#HMKNdMMNJ]\\na(Jga(dNN, ~,L  t(,~{dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNZ6z-(mx  OH(HWNMM#4,>.XUCWuMMM#dMMOWMN#dMbMMrMMNMMNWXNRWd/l-zDh(lvHmJWI(+. ~ 7x1.  Tm.<+dWmx:?z?G/WSdMN#MNl+WcNdMdMNk#dM#MZNdM#]\\nMMMMWMMMMa..?;<.D 1{< ?MMMMMMMMMMMMMMMMY7?7TTT\\\"MMMMMNS-??n?/<~~j>MJ/0Tp.1z.2?MMHMMNKMNzdMM#dM#dMbdMNMMNXL1MR/dxl.$(l(<zHHXmxw+ `~  ?+i. ,TNQWJ?Hm(2vAvhJc?dMNVMJ1.zMNh?MNNMMNd)W/MN[\\nMMMNMMM\\\"JMM#`C~(y  %.   TMMMMMMMMMMMM@<<_-._,>>.JruTMMNs3.74p :_(JW2  (Wag(.dMNMMMMHWNZNMMNzMNvMMMMMMMMPW,IMp Tel(.._--1TdMHQA< dNgJ-?Gh,.?Tmd4x?TNgI7oJCSsWTHg7H&?dNI,MdMMMNM[dbJM[\\nMM$,MMo(MMMN.: ,ji <o_   ,MMMMMMMMMM@_4?!  _?\\\"YBdmJJmkMmTaJW2-    ?N&~?<(T@(NM#qdMMDJMbWNMMsMMRdMMMMMVMM/X.JN{ ds/}   (.</mXHNBgJWMNMNm(YT--!7N,WGRJHa.vGcvTb<_Tak3dNj.#0MMNNMLKNJM[\\ne ..dMFHMM@!.``..~?;.t    (/BWMMMMMMF?!>._-.._. .w(_?MNdMhTS/?Wxh-.>SHJXUMgMMMNM#MMZwMNRdHMNMM#dMMMMM6dMNJh(dK, Nd(.   < ..4dI('   ?TMMMm7_.v+-.THfTo,.CTz6uHClkzV<wNxd#WMMMMM#tJbH[\\n71MMMMaMHP  ( .  ..1_<i.   1.1?NMMMMb~<t-..     ~w>)((NMWk0zGvd76?jWSQMMMMNMMMMMN(MHzWMN/MMMdMNdMMMMMSRdMN?hdNj`JN[1    -_  _1J.      ?MMNx(,.. JH2Yl/z1++>jvW(H4x.(MUM@MM@MMHDqNMX%\\nNM#: XMN(Nx : dNMM,_~o.(.` .(.(64M#ML..1/   ?_.  (tl,+TMNQWI11l7V1%.qNMMMMMMNMMMMRMNb1WMb.MMMMMdMMM#MR64dMLjNN  .MR 1  `j;  .=d         7MMNZ!`.,THo_~2(>v+Z~1dXZDZJMXMbM#(MN#DHM#M[\\nMMMMMMMB9?\\\"<`  dMb.. _<, ?-. .-.?SUWM&.! .!!~_.._?F?<_ ,MWWk+<?OJ$jMMMMMHWSM#MMMMNMvMRvWMp(MMMMNMMMNMMNl<dMe1M_  MN. 1  (z  .?J[         JNVY^  `.MM+.>z+vj1<.XD$Pw3MMMdMF.MM]qMdNd[\\n....JWa....-....(\\\"\\\"    .<. -~. <<.C-,p._!(.--.  ..+,.~`-cHkNb<iiXWMMMMMM##M#NdMMbMpNJMNdNN,4#MM#MNdMM:?RljHJNM[  JM}  ~. 1r_`..d,` `     JMHU!~`  JMr(.v11Z+C.ODIt9(dMM4M]dMM}J#JMN)\\nMMNNgJJ-..?\\\"\\\"\\\"MMMMMNNJ.,._.   !.-- ~ ?e.(7T,~-.  .,l<?- ??NhOr_GdHMMMRMMNbH@(dM#NZNyh,HN?M#,dsMNMMWdMp ?p1ONXWri ,Nt     .N.  -^&    `   MMK??~___jM>%+1v(z1>.j1zj><dMMdM%(MH!MDd#W)\\n\\\"\\\"T\\\"WMMMMMMMNgJ.._7TMMMMMNaa,   ._~.~.,N,,^(<~!!!~~~_  ~   ~ic.gM%dMM#HMMR(HJsdNdNXUkh.TNJHJZMMMkVWLTM[ X/1O/vMsl Mj.    `?Ho! .V<,   ` dMMf??!~` dM(<O1>Z<1:xV(ww(!dMMHMld#X(MIMXd\\\\\\n          `?\\\"WMMMMNJ,. ?TWMMMMN&,   _`  7Nc .;  _!~<j(,._   .wdMNMMMNMXdMM UwdKMLvHn(vN,?WmWJMNMbnjBoO#: N,1WzM/l J|3`     .Wn.: J3&...dMV9x~?!! (W8C(11(I>d1II(%2( MM##MkdXRd#jNMd[\\n `~~-.           ?TMMMNg,.  ?TMMMMN,.     ?9a.,(  .=`  (, .dMNMMMMPMMJNRMM;(1OMHN,?Hh 1Wo WmrWM#MXwdcSVJ-,@.44.U,[ S.;       7HR.>.zFHMFZ???!`~ (Zz>:O>>z1+r(((P.[{.MMXWM#B>(M6dMMH\\\\\\n       ?-. `         ?TMMMNg,  (TMMMMNa,     ?TG.J:    Z[ JHHMM@MNKJMNdUVMN.2nWNWK<(Wh.(Nm.WNWdMK7cvI-?vs.z/JIh 1,,.;.,        7WMWgx((So...> _1zCv<(z(<CcJ>; v ((`,MMHfJNt.M#dMMMN)\\n          <.~.          -\\\"WMMNx.  ?MMMMMNa,    .=kC  .7(~+MM8MMbMMMdMMNkL?M;?gNHMN_1.CH,.WsJMMZMN OcZJ.(0X.t.xJ<.!(.(.(,`     .JzidXUWXmwAeoJ&uw0Z+IJc(<<<>!`.>~yc /dMdNjM_MMhdMMMN}\\n    `      ` `  `  `        TMMMm,  (HMMMMMNJ.=  (T9B=.tdN#dqMMNMMNNMWMMk{?NJMNNHMl (-_O& WRqMbM#-,L(k( .4W(_`3\\\\(, l   .i`  ` .XX$iz1zVwWW9Zdkd1wIZvG-u&(.<  ( (I!.LgM#W[TdMMrdMMMM)\\n `     `              `      `(WMMN,  (MMMMMF`       .=JMMHFdMMM0MM#MpUMMJ,WNMMMMNN..J71(S,W#MNM@(.0.._:  ?k, .I. ~.-    1.  .=Jw$jUUUUXUXAkRJvQWsuJY\\\"5UYTMNae!,% wNMMNNd}MMMOMMMMH)\\n?!  `   `      `        `       .TMMN,` ?MM#        J(dM#MMA#MMMNdMMJMpWMMN-MMMMMM#=/   D 7?MxMN@`~l1 ~.   .43.}_.  C     ?, ?~?=(<z1dUUuXU7`.d#6?` ` .  . ?HNmv .NMMMMN]uMMMrWUW0J)\\n-..      `  ` (~4e7<.     `        TMMm. .Wt     `.m-=XdNNMWMMMMMNMMNMMeWMNN,MNMM#`J    /  (,MdMM. ! >  `    1.1` _`,.  `  .<.`   _ ~<(X0:  .XM!  .<->.J-  .JzN).MMMMMMK#,MNMC?h?^,}\\n?i?+       `  j` .4, 7a.   `        .WMNe (`      dMMNbMMdNdMMMMMM#MMMMMRWMMNXMH#` G.  ,`    d?NR6.  .<.      <-   _ }`      -~     .?V7    1MF,=777T9WNX2_.l.XIgWMMMMMWNxM#=d^0n ,}\\n  ?l1,` `     ,,   (-  T,`    `       ?MMNt    `  dMMMMN#Z8WMMMMMMMMMNWMMNJMM#MM!   ?6.]   ` .L?W[ ` (dWQg,`   .-    >     `  `            .gM:?,      (MMN.(&gdM#MMMM#jMMMf(l (-n,}\\n    _V.     `  4.  `1   (n      `     `.H#`      .MMMMMMMNWMMM#WMMMNMMWMMMbMMNM>      .N+     O WW,  `?NMMM|`    _   _  `        ` `      `(MM)?k,      ,MMHNMHdWUMMMM4MM#j=,.` 4,d}\\n      (.  `     4, ..'   .h             .\\\\       JMMMMMMMMMMMMEHdMMNMMkdMM#MHWt     `.DW#>    .;,w;    .NHXMN,             u..             !jdE.?N,   `.ddNMMMWkdXMMM%.MMN(Ng/    (}\\n       1         ?dD_      h         `  - .      fMMMMMMMMMMMMHMMMMMM#CJMMMMX=    `  dK,MZ;`   < z1.   .d#WU8Ne.        `.. dMN.      `  `   Od),CH&J(dNNgdMMMydX0MMm.,WMHGMMN,   ,}\\n       .[        `>.<   `  .[   `       j  I.  `.' HMMMMMMMMMMN#MMMMXN!(MHN=     .. (NR_(NJ.     .Ii    ?dRWWXMNe(.  ` .7?_.j.!`  `          ?XN+1~WgMMMMMMMM#RRMXMF1. _?TM9WMMn..,}\\n   `   `(.`  `    .-(`    ``j.    ` `  `v       (p.d(MMMMMMMMMMMMMMMM@ dMY    `    .MSW[ ?#)  `   (/>  ,C?MkHWW9Tmn.     -`.dMHg..            (?% .MMMMMMMMMMNHM#dMb (71(.N:     .?}\\n    `   .)      ` .2        .]          r       dMNP(MMMMMMMMMMMMMMMN\\\\.#'         .fMkW]  Mb       1.: (v1MNkkn+QfTNUn..d_dY^  (7M3(;`  `       ~.MMMMMMMMMM#MMMMMMMN,            ,}\\n         1`       J%   `    .%      `   \\\\      `dMMMMMNMMMMMMMMMMMMN#.=       ` .MN<dNKb  d#  `(A. ._.!dMhJMN#dT(,jf(TNm.(^     .!        `    .J!HMMMMMMMMMQMSMN?MMNr?Ng..   `   ,}\\n    `  ` ,   `  ` d        7j[  `    ` .!  `    HMMMMNMMMHMMMMMMMMMM#!  `  `  (MkMNkMMSb  JE     ?TUh...Dd>dMMK8QJ(6Z<x?H,   `              ` .=  JMMMMMMMNNMBMjM[?MMH-?MN/WMHdm7 ,}\\n `    `  ._       d-        .S        `J        b.WMMMMMOdMMMMMMMMMM)  `    .MRMMM#HMMdF  jS   .Y177ZXHJxY=vqMMHWma--&J!1H    `        `     J!  .MMNMMMMMMMGMF,MN.?Y8r ?Mb.MNKN  ,}\\n,         [   `   ,F   `    `I     `  .t       .] .MMMMMMMM1?MMM#^  `      j#HdMjM#HMNWP  JK .Y .! .>  !7mdVdMMMM#SOCv1(K^       `  `    ``.C   `.MZMMMMM#MqM8].MMDJ!?7<(JM[(WMW[ ,)\\nSI.  `   `1        D      `  r        J`   `   .] ,DMMMMMMNy1uY^         .J8HSM@dMMMMMX%  z!.^ .k../     ?Nv0dWMMMNNgmYO    `             .^    .MMNdMMMMHW@M[b JMW)(.    ?F\\\"\\\"7N#h,)\\nXwS.    ` ,_`      P  `      b  `    .:  `     .] ,<`?MMMMM#\\\"`        `.JMMMmM#dM#dMMBd\\\\  1J'   .lZ`     `7MYWYWM#7~!J`?      `      `  .Y    `.MMNdNMMNMNM(MNd.MdXN,.\\\"T&.d>     jW)\\nVkWv;      [   `  .b         z    `.J^  .:     .[ ,c .~?MMY       `   .MMMMMMNWMM6MMMNF> .Z`     (!   `      _TY\\\"`  J`     `     `  ` .Y`     .MZMM#dMNKM@N.Md(](NMMMm,          `?}\\n?ONJN, `   j      .F   `  `  (_  `.Y    J    ` (o..b. i.Y          `.dMMMMMMMMMM$MMMSdHp J      (                       `         `..\\\"       .MWbd6DdMMNdMMjMMLb MMWWw/TN&J.,. ,  .}\\n ~(TNH)    .;   ` ,)        `.b` ,^  .(   `.  .#\\\\?N..kD      ` `  `.HMMMMMMMMMMMM#q@ZOidd`   ` .!  `   ` `  `               ` ``..M\\\\        .MMMNJrHkMMMKNJ#MMM#.Y(?W_  db.` ?M.  .}\\n& -THHg_.   3    `J!          (;J!  ,MB  ..!  J[  ?d#'            .kMMMMMMMMMMMMMMNf.T!        r           `           `    ..gMMMF         .MMMMk#dNMMNIMRMMMM#( ,- <, dE((h._b  .}\\nQ9,  ?TM[   (.   .F   `   `  `.F    .V}  _` . T\\\\   =    `    `.`.dMMMMMMM#MMMMMMMMM\\\"`    ` `  (U              `   ` `  ..(gMMMMMM#-.     `  dMMMMMNWMM##ZJW2MMM#j  4, ?&Z@dQH@ .b.,}\\nNdh/`  .h,` .}`  .\\\\         .J'     .<!  ` /       `  `    ` -(dMMMMMMMMMZMMMMMMM=          .Jt(   `  `  `  `  ` ..JNMMMMMMMMMMM#=        . MMMMMMMd#Mh#SJ-H,MMMd,  ?++%4m#=`   .b,}\\n7Wh?1-   ?.  (   v     ` `.J^     `,.`            `.Z`     .JdM#NeWMMMMMMKT\\\"\\\"T\\\"\\\"`       ` .7` I,`        ` ...gMMMMMMMMMMMMMMM#'        `.  dMMMMMMMNMdMRk.dnMMMNN,      (4-$ `  (m}\\n   ?4&(-     .! .\\\\    ` .J^        .r            `.f   ` `.?!W$ .?MB\\\"\\\"=`             ` ..4\\\\    WJ,......gNMMMMMMMMMMMMMMMMMMMY        `   ` ,MMMMMMMMS7MhNXdWMMMHWMm.      .4,  .XH)\\n      .7+.<     P      ,^          z`          ``.Z'    _.. .\\\\                      ...MMMb     M90dWXXNMMMMMMMMMMMMMMMMMMM#'      `       .78MMMMMWMh.MT9\\\"=?7\\\"TM#MMMJ,`     J;.?`,}\\n         T,  ` J`  `  /         ` .!  -   `     .?!  ` .>v`      !      `     ` ...(gMMMMM@`   `Jkkwv1zWWMMMMMMMMMMMMMMMMM@`   `                 ``` `     .??>   dX^     ` .d%   ,\\\\\\n    `     (n  .\\\\            `   `.\\\\` ,     `  `/!`   .d%:           `     `..gMMMMMMMMM#=` `    v~!?TWpddMMMMMMMMMMMMMMMB!       `  `   `  .             ....`   `d'       .%    .J}\\n      `     ?&J_  `             .:     `      !     .8:       !         ..dMMMMMMMMMMD`        .%     .MkMMMMMMMMMMMMMB'    `            .!`  ` ..   .,!   ` ?.. ,`      `.\\\\..JY=`,}\\n   `    `     d{`         `   ` !         `       .0'             ` (mJ7!`    ??77TB=       .JNc{      .bMMMMMMMMMMMM=        `    `   -v!      ..J.?`        jMMn       (MY^     .}\\n              (}   `   `          .             .v'  _ `        `..dY`                  ` .MMMMN}    +:.bdMMMMMMMMM@!                 _       `   `  .,!   .J=`        `,%        .}\\n    `  `      (`      `    `     .`  ` `   `  `.=     `  `  ``..jC(:       `            .dMMMMMMb  .dOzidgMMMMMMMM%    `   `  `  `  ` ...`  .... ..(Y`  ..=          ` ('       ` .}\\n      `   `  `j     `           .!          `.('           `.-> '       `   ....     ..gdHJMMMMMMb  (OzjMdMMMMMM#!           ._?!???!`         ?5i?\\\"h(HV=           .-Y!      ` ..J\\\\\\n   `       `  d    `      `   `.~       `   .>         ` ..J=        ..&W9MMMMMMM#YMMMMMMk(MMMMMMM<  j1zNdMMMMMF    `   `.J^                         `      `  ` .g#^  ` ...gWM#! ,}\\n      ` `     J~               J    `  `  `.\\\\    `  ` `.__^       .dMMM8_M#MMXM#M#bjMMMMMMNMMWMMMMb   ?:XdMMMM#         (!                `  `           `   ` .WD!  .-T\\\"!`..MM#  ,}\\n...           d`      `    `  .!          .1!                    .J5dMM+.dMMMkMMM#N(MNdMMMMMM#ZMMMM[    KMMMMM#    ` `.^      `  `     `        `            .+F   .dF  MMMMMMMF  ,}\\nI=====vIzC`  `d   `     `    .2   `   `  ``!   `   `         ` .Y<.,JMMr{,MMM#ddMNd_MN(#MMMMMb0>dMMM,   bMMMMM%      ,`            `       `  `    `   `  `  `...Jf!(Me ,\\\"<JMMMF J,}\\n+;>+zzwsssAA0OL              +:                   `    `     .Y   } CMMN1 MMM#WndMN[d#(MMTMMMMN(.,MMN, .PMMMMM\\\\              `           `             `...JW#TN,.NdMN?N,,MMMMN..MH}\\n `  __<<?<<+z4F    `   `    .(   `   `   .                  ,t    (.(JMMr;.UMMpXl?RldM4NEjMWMMMMx! TMN..tMMMMM~   `        `     `    `         `  ` .(HTMMb1?mJN,.MMM| dMN,.TMMN%,}\\n          (1zw]           ` ({          /                ` J^      { 1dMNJ. 1dMp6;(NM\\\\.Wn#!.MMMMMe  (Mb,jMMMMM`                            `     `..MMWMRMM#/G,HJMNdMMNJM!TMNggWM\\\\,}\\n           ``(\\\\  `  `   `  .l{  `    ` /       `  `  ` `  J!    `  .. >VMNx. ?XMcv<.Mz(X#: ?.(MMMMb  ,MddMMMMM,`      ` `   ` `  `  `   `   ` `..MMMMNdMMNMMJ/4.?HMM#WMMMNJJMMM(M|,}\\n      `  `   (`           `J`         /  `            ` .d!        `~  i?MMs. .WK<_v`.w2$  .{ 1WMMMN. d#dMM\\\"  h   `                `     `  `.jMMM#hMMNHMM#MdHx7, (\\\"N.,?MM= JMM;Mb,{\\n    `   `  ..y`   `   `    >       ` .`   `  `   ` `   .f`   `            4J>`  8<_ _-v_\\\\   1  17MMMN,(MY!    ,m.  `    `  `               .+MMMMMMHNNdMRdM;(HMN,+,.MMMMMMNgJMF.M#(}\\n((i..JgmkVOwX@     `   `  .`  `  `  .`        `      `.K   `  ` `          (1.   ..    !     i  _?MMMNJF    .MMMN,  `       ` `  `  `    ` .MMMMdNJNMMb?MNTN, 4JWZTNR_  ?WMHMMhMMD,}\\nYCzOOv7TUQAXdF  `         ``        }   `  `     `  `.#AZz1+...   `  `                  `  `      .MMMMF  .MMMMMMN.   `                     WMMNMeTg6JMm,!TMT5.?gMm.(TMa,  JMMF .Nj}\\n-(JJc\\\"7!`   J%        `           `-              ` .#zv11><?7771++-   `  `    ..XHHmaJ..           WMM].MMMMMM#^.N     `                    7MMMMR.Um,?Mn,(#+.MMMgMMF a,UxdMMh(Mb,{\\n            K     `             `      `         ` .@!<<+?<<<<-_~~<:;<<.`     .KwwwwvwOXXHMa,.       TM#MMMMMD`   ,b       `  `  `       `    /b?WMN,?Tn.W,?NMM9MMF`?! ?N.dMMMMMMMN:\\n   ``   .. .b   `  `   ` `  `             `  `  ` .F      `   !  ..__(,      `.NwZwwzwvuwzwOZHMa,.    7#MMM@`      ?x  `     `      `  `    `  (b   TK7aQ,Te,MN(MMp N,..?NMMMMNm,?j{\\n . .` .``  J]                        `          .J$..                  `    `((JNkXzwzwwQQkWmQkwwWMa-, qMB^     ` ..d,                          ?b   .=.-17TNdMMeWMkMNJN.JMMMMm?MF,{\\n           .]                          `   `   .#`   `                      .+++zNRrwXXuXWWMMMMMMMNmkMMNkUSa...JHSZrZMx   `      `              `vL     ..>  ??T@   MMNMNNd#!(MMN,,{\\n        `   t      `  `  `  `  `  `  `    `   .#`     ` :..                ___!` ,KwwrzuuuXWMMMMMMMMMMMMN0vdNggNMMMMHrHe    `            `  `     Ue      ._ .. .W, (MMMMMMMg-dMM%,{\\n   `  `     j.`  `                           .X3          !             `        -SuXvzXuwXwXXwzuXWHWXMMMNNkMH9HW8XvvwwMp     `    `         `     Wo          _<(dh.TMMMMMMMMMMN-,}\\n    `    `  ,)        `   `          ` `   ` (d~  `  `     ~..`  `  `  . ` -.   `,RuQggNNgggmQmXXuuuXQMMMMQM#WHHNNNNmmuXM[`         `    `          Ux `  `        7B,JMMMMMMMMdMN,}\\n       `   `,b `  `    `   `  `  `      `   .d(--.     `          `   `    ?`  `  ?MMMMMMMMMMMMMMMNMMdMMNMMMNcz1+vMMMMMNkMx `  `  `   `    `  `      Ua..            .4MM#  .MMMMMz}\\n `  `        N     `                `     `  X n...~.    `             `          ?=?\\\"\\\"\\\"TUYwUUTY\\\"\\\"\\\"TYT#MNMVMNMm/?~`.WMMMMMN,  `             `   `     VpOkHHUHHk&...   ?WY\\\"\\\"dMMMN!,\\\\\\n        `  ..M[         `   `        `      .f W-(z11.        `           ` ??!~`  ~.            ..v<.HMHdmdMMNMe.   .THWQXN.            `             ?b ?71aaeQXHMMm+  ?a,WMNMF ,}\\n     ` ..Y^   N.                  `      ` `?` dr~?<11(.             `         .             .>_-(+<`(HMKd#<JMMMRN,        .b                    `      ?k.        !?7!`   ?G,TMN,,}\\n    `.V!      ,b`  `  `                `       ,#(<+<TIue+(.`       `           j,.     .(?<<<-((>1+udHMRrN j<MMMNdN.       (b   `  `      `  `    `   ` (N.                 ?h,?=,}\\n    (D         d[         `                     MkY7<<_?C??i-.. `                  ?7i,`  ;<??!   ,C1MdNyOM_ (zNMMNZM,`      d;          `      `         .H,                  .4&,}\\n `.dt  `  `     N.  `  `    `  `  ` `     `     d[.-+<jzz>O1zQszl.   ` ` ` `          .>...      .?+j#MMkwd)  _?MdMNwMm.`  `  N     `  `    `               Te.`   `  `  ` .-WHBTMM%\\n.JD`       `  ` J[                   `  `       J#zZ1+vC&ua&-?TV=76..          `            .`.  -<<jSMMNzd] `<(dNdMNmdN,    `([              `  `   `       -N,     ...vY=vRVwwVZ(}\\n=     `          H.   `  `                   `  .N<1zu+gkwUXe++vO(Jz+(--    `     `  `  `        <<+HQMNHwdb`.++&MRMMNmwMe     W, `     `  `       `   ` `   ` TMY\\\"\\\"7!      ?NOu2`,}\\n       `  `  `   (L     `   `  `  `  `   `       dP<-++-xvOv77\\\"\\\"TSV77=jauz&.          `   ` `    +?jBdMMHzrN    (?WkMMMNsMb    .N.   `    `     `               (N,     `    (N}  ,}\\n    `             W-                  `   `      ,NO<(J<?!~(-uO+.Jz&+(z1i(-?z-.`   `            .?vHwdMMHwOH.   `(-NZdMMNZWh.   ,b           `          `  `      7m.         .N, ,}\\n      `  `        ,b  `   `        `              drvY<uZXJJTz<uyTSQZTUa+VI(.(Jz-.      `     `.-_(8wdMMBXwW_    (+dNwVMMHXdN,..,J[              `                 ,N,   `      4,z}\\n    `      `  `    M,       `  `     `    `  `    ,N(Jy?T1++uaJv61JJ71J(OA(ukdT6--..  `  ` .....z>K0XdMHuzwd]`    CvWkwZMNKzVNswzvM.     `  `   `   `  `   ` `       Tp `   `    ?g}\\n        `          Jb  `          `     `        ` dmJgyTBYYTWT\\\"YT9HBTMUMHa-.azGz&-(.`      .9771(8XuMNSzwwdF...J(+zdNuuwMRwzVNOOI?b  `                         `     (N,         (%\\n   `                N.     `                        W@z?OxVTXTTZ7TVY\\\"TVYTW9TTS&+78V99I(.    (11> KvXzWHSzOwXb+UZw0dkwWKuzdSXzwdb1+-J[`     `  `   `     `   `          .W,`       ,}\\n    `  `      `     ?b  `      `     `    `   `  `  .N2\\\"171Z3(-uSQXW#XNZXHxwWWOzOyw+-__-...   .OdSvvXHSwvvvd#wywZdHHWd#wZwwwvwzM[   M.          `    `       `          `?h.  `   .}\\n `      `  `     `   N.     `     `   `              .N/777OksVGJXx+J+1(.JZOzVY4V9w&+(-...    (4HwvXw0ZOvuzd#wz1+yWMMkMkvOwwXOwwN,  ,b   `  `            `      `         .W,     .)\\n,     `              d]                 `  `    `     ,NJuk&J&J+jJJgzywz?T9Sv1(-<!!...-<`    ` J#rXvwwvXvwXX@GZzwd9UXkd#zwwzvzXwdN   q,        `  `        `       `        7L    .}\\nN.  `     `   `   `  .N   `        `             `   ` ,NYv31+Z0v?0Z1-(x&(+1+(xvTCu&WSC_   ` .(j#zXzuzwwwXXd8w&wSxQdMHWNZXzzzwwwrM[  .b              `  `   `        `  `    (N.` .}\\n-N.     `             M-     `  `    `  `  `   `   `    ,NCCv1J1(.Jux?TZUUWmmWWYz+Xev!      (1+(KzuwwXwuwXwWzRGdgWRzAdWMuuuzzzXzwdb   J<  ` `   `        `    `  `     `      .W, .}\\n (b  `     `  `  `  ` d[                  `   `          ,N>..(+JdHUW9TY<OgkXUVz7!``     `,WSy&d0uzXXuzXXuXHUXWO6wZ4Y?1WOXwuXzrrzwW. .,b     `    `   `      `      `     `   ` 4e.\\\\\\n  ?b   `              ,b  `       `   `          `   `    ,N,(C1uXU&OAZWW9YwXUXC` !-. `   _uxzOdXuwuzXzzXuX#6<!!~.-`   JwX0XwXXwuwdR1&(J|  `        `                            Ug\\\\\\n   Xp   ` `  `    `    N.  `  `     `  `     `    `   `  ` ,Nx71+vUww0Ius0dKVW=..?`    ..17zOuzWXzXuXXXzwzd%~!`        ,kXkwzwwvzXdv11>.N.    ` `       `  `  ` `  `   `  `       T}\\n    N,          `      d|                 `                `,N&J?<(udYS+1zz7^`     ..!+xOu+(>_ WzuVzXuuwzXW             TNQQQmmmQQM0w1c1?b  `      `         `               `    .\\\\\\nR   ,N.               `,b       `     `         `            ,NJ7V1/7(-7!      ..<-+zZTY7T7wdY=TmmkXXuuuXw$         .._`.(OUzz&OovIzz+1Jod|       `    `                `         .}\\nMb   db`  `        `   .#   `      `      `      `  `  `      .N2--!        ...JQmQAOO77?` !` ?!~!?\\\"\\\"YB\\\"\\\"!  .....J(..xv6~7z1zuJi(oyuizJkwOH,  `          `  `    `    `   `       .)\\nM@.   W[`  `  `  `    ` N      `     `       `     `  `  ` `   ,N,       ...JOOz<<`                  .(++u+gXHMMGGXQWdXVTv4gD&kuww1+wdkH0OvN.  `    `   `    `  `   `       `  `  .\\\\\\nMN.    M,               N        `     `  `    `                .N,    (<<!!`           `  `   <1+ZUWkvGd9TW95V0XdwdQxiJdWYkUVXVZwU6VVXVS1-?b`   `         `             `      ` .)\\nMMN,`  .N,   `  `  `    N   `       `            `    `          ,N.                      .JwAg&gkNHHXHHAHHWdkHH6X9Y1CvACJ7<?UWU0OZZjzYoz(: d|        `               `      `    .)\\nMMMMp  `,N.`        `   M.     `     `   `        `  `  `    `    (N.             ` ` .(zMNggkMWH99WMVXKM8dAkXX&SZ(+JzCjXwXZwzZwwXwzZC+T:... W.    `    `    `  `  `    `         .)\\nMMMMM_   (N.    `       d|        `       `  ` `          `    `   ?R` `  `   `...zOQHHB0wQWHWMmmdHWXWXYzTYZv1VviJJjwJ6ZV6XV6XTUUZ1+=+&zZ^`  ,b `        `  `            `  `   ` .)\\nMMMMM`    ?b  `   `   ` (]  `        `      `      `  `    `      ` Tp    `  jSJSwvOXkAwwX9UWMMHMWYWW44ZZCTTX97ZXGkwdXJd8UvCOTC1?+v1?!        ?[    `  `       `    `             .[\\nMMMM#  `  `?b           ,b             `                       `     Wo      ?\\\"7?!`  ...(??=77V9UY7TwmkX2?J6>(<1VzUwWV4J1JZC1?~~` !          ` 4,                       `         .)\\nMMMMN       db          .@         `     `        `                  .N,                !~?~~---(-(((-vTCz--1JZ=+77! <_`.!                      N,       `  `              `  `   .[\\nMMMMM;  `    dp`   `  `  N            `                `              (b                    ~?????<<<u&&&zz11<~~                           `  ./?N,            `                ` .[\\nTMMMMM,      (dp         M     `           `    `  `      `  `  `      d[  `            `          `                        `           ` ..?<-~-,W, `  `    `          `         .[\\n.,MMMMMN,    .)7m        M_      `  `         `      `      `      `  ` N.`    `     `                                  `    `   ` ` ...1++<-<(!..,W,    `  `    `  `    `  `     .[\\nJNJMMMMMMN,  .\\\\ ?R.`  `  d)          `    `           `                 Jb              `  `     `     `  `  `             .   ...JCwOvjZ1J+v^-<~-  Te`                         ` .r\\nMMMMMMMMMF`  J`  ?N.     J]   `    `  ` `    `  ` `    ` `     `  `  `   MzIO+..   `         `  ` .... ......-_~++((+zwuagAdXkWX87COzxY1w+v^.<<_-~ ` ?b      `        `  `   `    .]\\n#^~`?=JMM`  .]   `,N,  ` ,b `                      `                   ` J#Owz<1XWa...` `  `        ??<1u+Jv4oJJxwdTHH0SAmkGO(zvIJiJ=(yOc=v11!        ,N,`      `       `     `   .]\\nm.... ,MN-  (:     .H,  `.N     `   `     `          `  `  `  `  `  `    .NuZUX&&&vOO+?7Tu....`    `        ??7\\\"THMMM#WmXXXSwXZ8AXYzI<-~,<<?`         ` 4,` `      `            ` .]\\nMMMMMMNMMb.`d_       Wp   M|           `       `  `                       dRXmXVTC1z&zC<+&&z&dMBY\\\"TO+(.....`        ~`(((-T7Vl-Z<(I<JCJ=7!         `     ?L            `    `     .]\\nMD7MMMMMMMMN(]        7b. (b         `     `         `            `     ` (b  .._???zCVY\\\"7<-(<++(<;+(((J-(+(7=1(..            ` !    `                    .N, `         `          ]\\nD7# TMMM@MMMFS.`` `   `?b. H.  ` ` `  `  `   `  ` ` `  `` `  ` ` `  ` `   .M `    ?!_~?!<?7\\\"??7?T77C1+(+zz111+<<<<?!..  `                  ` ` `` `  `  `   Te  ` ` `  `  `  ` ``  ]\\n\u00a9 J.I./Asahi Shimbun Publishing\\n\u00a9 J.I./Asahi Shimbun Publishing and Junji Ito \\\"Maniac\\\" Production Committee\\n*/\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/common/ERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\nimport \\\"erc721a/contracts/ERC721A.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport {DefaultOperatorFilterer} from \\\"./lib/OpenSea/DefaultOperatorFilterer.sol\\\";\\n\\ncontract Tomie is ERC721A, ERC2981, ReentrancyGuard, Ownable, DefaultOperatorFilterer {\\n    event Killed(address killer, uint256 killedTokenId, uint256 birthTokenId, uint256 totalKill);\\n\\n    uint256 firstBorn = 2222;\\n    uint256 lastPhase = 4;\\n    string baseName = \\\"Tomie \\\";\\n    string lv0_description =\\n        unicode'Regenerating TOMIE has been airdropped to \\\\\\\\\\\"TOMIE by Junji Ito\\\\\\\\\\\" holders.  \\\\\\\\nYou can enjoy the KILL gimmick at the following website  \\\\\\\\nhttps://nft.ji-anime.com/kill  \\\\\\\\n\u203bPlease note that the kill system is subject to terminate without notice.  \\\\\\\\n  \\\\\\\\n\u00a9 JI Inc./Asahi Shimbun Publications Inc.  \\\\\\\\n\u00a9 JI/Asahi Shimbun Publications, Junji Ito Maniac Production Committee';\\n    string description =\\n        unicode'This is the NFT of Tomie, who has been murdered once but regenerates and grows again and again.  \\\\\\\\nRegenerating Tomie can be killed again at the following website.  \\\\\\\\nhttps://nft.ji-anime.com/kill  \\\\\\\\nThis NFT is a benefit for the holders of \\\\\\\\\\\"TOMIE by Junji Ito\\\\\\\\\\\".  \\\\\\\\n\u203bPlease note that the kill system is subject to terminate without notice.  \\\\\\\\n  \\\\\\\\n\u00a9 JI Inc./Asahi Shimbun Publications Inc.  \\\\\\\\n\u00a9 JI/Asahi Shimbun Publications, Junji Ito Maniac Production Committee';\\n\\n    mapping(uint256 => string[]) private imageURIs;\\n    mapping(uint256 => string[]) private titles;\\n    mapping(uint256 => string[]) private colors;\\n\\n    uint256 private regenerateTime = 2 days;\\n    mapping(uint256 => uint256) private birthTimes;\\n    mapping(uint256 => uint256) private killTimes;\\n\\n    uint256 public killCost = 0.01 ether;\\n    uint256 public freeKill = 1;\\n\\n    mapping(address => uint256[]) public killedTokenIds;\\n\\n    address public royaltyAddress;\\n    uint96 public royaltyFee = 1000;\\n\\n    constructor() ERC721A(\\\"Tomie\\\", \\\"TOMIE\\\") {\\n        _setDefaultRoyalty(msg.sender, royaltyFee);\\n    }\\n\\n    function _startTokenId() internal pure override returns (uint256) {\\n        return 1;\\n    }\\n\\n    function beginning(address[] memory _enchantedPeople, uint256[] memory numOfTomie)\\n        external\\n        onlyOwner\\n    {\\n        require(_enchantedPeople.length == numOfTomie.length, \\\"No match Arguments\\\");\\n\\n        for (uint256 i = 0; i < _enchantedPeople.length; i++) {\\n            uint256 startTokenid = _nextTokenId();\\n            require(totalSupply() + numOfTomie[i] <= firstBorn, \\\"No more births.\\\");\\n\\n            _safeMint(_enchantedPeople[i], numOfTomie[i]);\\n\\n            for (uint256 j = 0; j < numOfTomie[i]; j++) {\\n                birthTimes[startTokenid + j] = 1;\\n            }\\n        }\\n    }\\n\\n    function setMetadata(\\n        uint256 phase,\\n        string[] memory newImageURIs,\\n        string[] memory newTitles,\\n        string[] memory newColors\\n    ) external onlyOwner {\\n        require(\\n            newImageURIs.length == newTitles.length && newImageURIs.length == newColors.length,\\n            \\\"Array size mismatch.\\\"\\n        );\\n        setImageURIs(phase, newImageURIs);\\n        setTitles(phase, newTitles);\\n        setColors(phase, newColors);\\n    }\\n\\n    function setImageURIs(uint256 phase, string[] memory newImageURIs) public onlyOwner {\\n        imageURIs[phase] = newImageURIs;\\n    }\\n\\n    function setTitles(uint256 phase, string[] memory newTitles) public onlyOwner {\\n        titles[phase] = newTitles;\\n    }\\n\\n    function setColors(uint256 phase, string[] memory newColors) public onlyOwner {\\n        colors[phase] = newColors;\\n    }\\n\\n    function setBaseName(string memory newBaseName) external onlyOwner {\\n        baseName = newBaseName;\\n    }\\n\\n    function setLv0Description(string memory newDescription) external onlyOwner {\\n        lv0_description = newDescription;\\n    }\\n\\n    function setDescription(string memory newDescription) external onlyOwner {\\n        description = newDescription;\\n    }\\n\\n    function setRegenerateTime(uint256 newRegenerateTime) external onlyOwner {\\n        regenerateTime = newRegenerateTime;\\n    }\\n\\n    function setFreeKill(uint256 newFreeKill) external onlyOwner {\\n        freeKill = newFreeKill;\\n    }\\n\\n    function setKillCost(uint256 newKillCost) external onlyOwner {\\n        killCost = newKillCost;\\n    }\\n\\n    // Kill her. But rebirth.\\n    function kill(uint256 tokenId) external payable nonReentrant {\\n        require(ownerOf(tokenId) == msg.sender, \\\"I'm not your Tomie, boy.\\\");\\n\\n        require(\\n            killedTokenIds[msg.sender].length < freeKill || msg.value == killCost,\\n            \\\"You need to pay the killing fee.\\\"\\n        );\\n\\n        // kill\\n        _burn(tokenId);\\n        killTimes[tokenId] = block.timestamp;\\n\\n        killedTokenIds[msg.sender].push(tokenId);\\n        birthTimes[_nextTokenId()] = block.timestamp;\\n        _safeMint(msg.sender, 1);\\n\\n        emit Killed(msg.sender, tokenId, _nextTokenId() - 1, killedTokenIds[msg.sender].length);\\n    }\\n\\n    function getOwnTokenIds(address owner) external view returns (uint256[] memory) {\\n        unchecked {\\n            uint256 tokenIdsIdx;\\n            address currOwnershipAddr;\\n            uint256 tokenIdsLength = balanceOf(owner);\\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\\n            TokenOwnership memory ownership;\\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\\n                ownership = _ownershipAt(i);\\n                if (ownership.burned) {\\n                    continue;\\n                }\\n                if (ownership.addr != address(0)) {\\n                    currOwnershipAddr = ownership.addr;\\n                }\\n                if (currOwnershipAddr == owner) {\\n                    tokenIds[tokenIdsIdx++] = i;\\n                }\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    function getKilledTokenIds(address walletAddress) external view returns (uint256[] memory) {\\n        return killedTokenIds[walletAddress];\\n    }\\n\\n    function isBorned(uint256 tokenId) private view returns (bool) {\\n        return _startTokenId() <= tokenId && tokenId < _nextTokenId();\\n    }\\n\\n    function getRegenerateLevel(uint256 tokenId) public view returns (uint256) {\\n        require(isBorned(tokenId), \\\"Not yet Birthed.\\\");\\n\\n        if (birthTimes[tokenId] == 1) {\\n            return 0;\\n        }\\n\\n        uint256 n = 0;\\n        if (killTimes[tokenId] == 0) {\\n            n = (block.timestamp - birthTimes[tokenId]) / regenerateTime + 1;\\n        } else {\\n            n = (killTimes[tokenId] - birthTimes[tokenId]) / regenerateTime + 1;\\n        }\\n\\n        if (n > lastPhase) n = lastPhase;\\n        return n;\\n    }\\n\\n    function _getImageIndex(uint256 tokenId) private view returns (uint256) {\\n        uint256 regenerateLevel = getRegenerateLevel(tokenId);\\n        uint256 imageNum = imageURIs[regenerateLevel].length;\\n        uint256 random = uint256(\\n            keccak256(abi.encodePacked(tokenId, birthTimes[tokenId], regenerateLevel))\\n        );\\n        uint256 imageIndex = random % imageNum;\\n        return imageIndex;\\n    }\\n\\n    function getDescription(uint256 level) private view returns (string memory) {\\n        if (level == 0) {\\n            return lv0_description;\\n        } else {\\n            return description;\\n        }\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override(ERC721A)\\n        returns (string memory)\\n    {\\n        require(isBorned(tokenId), \\\"Not yet Birthed.\\\");\\n\\n        uint256 level = getRegenerateLevel(tokenId);\\n        uint256 index = _getImageIndex(tokenId);\\n\\n        bytes memory attrs = abi.encodePacked(\\n            '\\\"attributes\\\":[{\\\"trait_type\\\":\\\"regenerateLevel\\\",\\\"value\\\":\\\"L',\\n            Strings.toString(level),\\n            '\\\"},{\\\"trait_type\\\":\\\"Title\\\",\\\"value\\\":\\\"',\\n            titles[level][index],\\n            '\\\"},{\\\"trait_type\\\":\\\"Color\\\",\\\"value\\\":\\\"',\\n            colors[level][index],\\n            '\\\"}]'\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            '{\\\"name\\\":\\\"',\\n                            baseName,\\n                            \\\"#\\\",\\n                            Strings.toString(tokenId),\\n                            '\\\",\\\"description\\\":\\\"',\\n                            getDescription(level),\\n                            '\\\",\\\"image\\\":\\\"',\\n                            imageURIs[level][index],\\n                            '\\\",',\\n                            attrs,\\n                            \\\"}\\\"\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    //other function\\n    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {\\n        _setDefaultRoyalty(receiver, feeNumerator);\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        require(payable(msg.sender).send(address(this).balance));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override(ERC721A, ERC2981)\\n        returns (bool)\\n    {\\n        return ERC721A.supportsInterface(interfaceId) || ERC2981.supportsInterface(interfaceId);\\n    }\\n\\n    // DefaultOperatorFilterer\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        override\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.setApprovalForAll(operator, approved);\\n    }\\n\\n    function approve(address operator, uint256 tokenId)\\n        public\\n        payable\\n        override\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override onlyAllowedOperator(from) {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public payable override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OpenSea/DefaultOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {OperatorFilterer} from \\\"./OperatorFilterer.sol\\\";\\n\\n/**\\n * @title  DefaultOperatorFilterer\\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\\n */\\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\\n\\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport './IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721 token receiver.\\n */\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @title ERC721A\\n *\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\n * Non-Fungible Token Standard, including the Metadata extension.\\n * Optimized for lower gas during batch mints.\\n *\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\n * starting from `_startTokenId()`.\\n *\\n * Assumptions:\\n *\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\n */\\ncontract ERC721A is IERC721A {\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\n    struct TokenApprovalRef {\\n        address value;\\n    }\\n\\n    // =============================================================\\n    //                           CONSTANTS\\n    // =============================================================\\n\\n    // Mask of an entry in packed address data.\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant _BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\n\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\n\\n    // The bit position of `extraData` in packed ownership.\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\n\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\n    // This limit is to prevent overflows on the address data entries.\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\n    // is required to cause an overflow, which is unrealistic.\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // =============================================================\\n    //                            STORAGE\\n    // =============================================================\\n\\n    // The next token ID to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See {_packedOwnershipOf} implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    // - [232..255] `extraData`\\n    mapping(uint256 => uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // =============================================================\\n    //                          CONSTRUCTOR\\n    // =============================================================\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();\\n    }\\n\\n    // =============================================================\\n    //                   TOKEN COUNTING OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the starting token ID.\\n     * To change the starting token ID, please override this function.\\n     */\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Returns the next token ID to be minted.\\n     */\\n    function _nextTokenId() internal view virtual returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {\\n            return _currentIndex - _burnCounter - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens minted in the contract.\\n     */\\n    function _totalMinted() internal view virtual returns (uint256) {\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\n        // and it is initialized to `_startTokenId()`.\\n        unchecked {\\n            return _currentIndex - _startTokenId();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens burned.\\n     */\\n    function _totalBurned() internal view virtual returns (uint256) {\\n        return _burnCounter;\\n    }\\n\\n    // =============================================================\\n    //                    ADDRESS DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\n    }\\n\\n    /**\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\n    }\\n\\n    /**\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(address owner, uint64 aux) internal virtual {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        // Cast `aux` with assembly to avoid redundant masking.\\n        assembly {\\n            auxCasted := aux\\n        }\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\n        _packedAddressData[owner] = packed;\\n    }\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, it can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    // =============================================================\\n    //                     OWNERSHIPS OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }\\n\\n    /**\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\n     */\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\n     */\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);\\n    }\\n\\n    /**\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\n     */\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\n        }\\n    }\\n\\n    /**\\n     * Returns the packed ownership data of `tokenId`.\\n     */\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n\\n        unchecked {\\n            if (_startTokenId() <= curr)\\n                if (curr < _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed & _BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an initialized ownership slot\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\n                        // before an unintialized ownership slot\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\n                        // Hence, `curr` will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed will be zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];\\n                        }\\n                        return packed;\\n                    }\\n                }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\n     */\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\n    }\\n\\n    /**\\n     * @dev Packs ownership data into a single uint256.\\n     */\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\n     */\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\n        // For branchless setting of the `nextInitialized` flag.\\n        assembly {\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      APPROVAL OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\n        address owner = ownerOf(tokenId);\\n\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId].value = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId].value;\\n    }\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted. See {_mint}.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return\\n            _startTokenId() <= tokenId &&\\n            tokenId < _currentIndex && // If within bounds,\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\n    }\\n\\n    /**\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\n     */\\n    function _isSenderApprovedOrOwner(\\n        address approvedAddress,\\n        address owner,\\n        address msgSender\\n    ) private pure returns (bool result) {\\n        assembly {\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            owner := and(owner, _BITMASK_ADDRESS)\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\n            // `msgSender == owner || msgSender == approvedAddress`.\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\n     */\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\n        private\\n        view\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\n    {\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\n        assembly {\\n            approvedAddressSlot := tokenApproval.slot\\n            approvedAddress := sload(approvedAddressSlot)\\n        }\\n    }\\n\\n    // =============================================================\\n    //                      TRANSFER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                to,\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public payable virtual override {\\n        transferFrom(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\n     * are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _beforeTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\n     * have been transferred. This includes minting.\\n     * And also called after one token has been burned.\\n     *\\n     * `startTokenId` - the first token ID to be transferred.\\n     * `quantity` - the amount to be transferred.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfers(\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * `from` - Previous owner of the given token ID.\\n     * `to` - Target address that will receive the token.\\n     * `tokenId` - Token ID to be transferred.\\n     * `_data` - Optional data to send along with the call.\\n     *\\n     * Returns whether the call correctly returned the expected magic value.\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    // =============================================================\\n    //                        MINT OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _mint(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are incredibly unrealistic.\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\n        // `tokenId` has a maximum limit of 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            uint256 toMasked;\\n            uint256 end = startTokenId + quantity;\\n\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\n            // The assembly, together with the surrounding Solidity code, have been\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\n            assembly {\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\n                toMasked := and(to, _BITMASK_ADDRESS)\\n                // Emit the `Transfer` event.\\n                log4(\\n                    0, // Start of data (0, since no data).\\n                    0, // End of data (0, since no data).\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\n                    0, // `address(0)`.\\n                    toMasked, // `to`.\\n                    startTokenId // `tokenId`.\\n                )\\n\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\n                // that overflows uint256 will make the loop run out of gas.\\n                // The compiler will optimize the `iszero` away for performance.\\n                for {\\n                    let tokenId := add(startTokenId, 1)\\n                } iszero(eq(tokenId, end)) {\\n                    tokenId := add(tokenId, 1)\\n                } {\\n                    // Emit the `Transfer` event. Similar to above.\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\n                }\\n            }\\n            if (toMasked == 0) revert MintToZeroAddress();\\n\\n            _currentIndex = end;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * This function is intended for efficient minting only during contract creation.\\n     *\\n     * It emits only one {ConsecutiveTransfer} as defined in\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\n     * instead of a sequence of {Transfer} event(s).\\n     *\\n     * Calling this function outside of contract creation WILL make your contract\\n     * non-compliant with the ERC721 standard.\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {ConsecutiveTransfer} event.\\n     */\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\n\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the `balance` and `numberMinted`.\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\n                to,\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\n            );\\n\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\n\\n            _currentIndex = startTokenId + quantity;\\n        }\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * See {_mint}.\\n     *\\n     * Emits a {Transfer} event for each mint.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, quantity);\\n\\n        unchecked {\\n            if (to.code.length != 0) {\\n                uint256 end = _currentIndex;\\n                uint256 index = end - quantity;\\n                do {\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();\\n                    }\\n                } while (index < end);\\n                // Reentrancy protection.\\n                if (_currentIndex != end) revert();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\n     */\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\n        _safeMint(to, quantity, '');\\n    }\\n\\n    // =============================================================\\n    //                        BURN OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n\\n        address from = address(uint160(prevOwnershipPacked));\\n\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\n\\n        if (approvalCheck) {\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\n        }\\n\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Clear approvals from the previous owner.\\n        assembly {\\n            if approvedAddress {\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\n                sstore(approvedAddressSlot, 0)\\n            }\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\n\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\n                from,\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\n            );\\n\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\n                    }\\n                }\\n            }\\n        }\\n\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            _burnCounter++;\\n        }\\n    }\\n\\n    // =============================================================\\n    //                     EXTRA DATA OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Directly sets the extra data for the ownership data `index`.\\n     */\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\n        uint256 packed = _packedOwnerships[index];\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\n        uint256 extraDataCasted;\\n        // Cast `extraData` with assembly to avoid redundant masking.\\n        assembly {\\n            extraDataCasted := extraData\\n        }\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\n        _packedOwnerships[index] = packed;\\n    }\\n\\n    /**\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\n     * Intended to be overridden by the cosumer contract.\\n     *\\n     * `previousExtraData` - the value of `extraData` before transfer.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _extraData(\\n        address from,\\n        address to,\\n        uint24 previousExtraData\\n    ) internal view virtual returns (uint24) {}\\n\\n    /**\\n     * @dev Returns the next extra data for the packed ownership data.\\n     * The returned result is shifted into position.\\n     */\\n    function _nextExtraData(\\n        address from,\\n        address to,\\n        uint256 prevOwnershipPacked\\n    ) private view returns (uint256) {\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\n    }\\n\\n    // =============================================================\\n    //                       OTHER OPERATIONS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\n     *\\n     * If you are writing GSN compatible contracts, you need to override this function.\\n     */\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /**\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/common/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\n *\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\n *\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\n * fee is specified in basis points by default.\\n *\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\n *\\n * _Available since v4.5._\\n */\\nabstract contract ERC2981 is IERC2981, ERC165 {\\n    struct RoyaltyInfo {\\n        address receiver;\\n        uint96 royaltyFraction;\\n    }\\n\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC2981\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\\n\\n        if (royalty.receiver == address(0)) {\\n            royalty = _defaultRoyaltyInfo;\\n        }\\n\\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\\n\\n        return (royalty.receiver, royaltyAmount);\\n    }\\n\\n    /**\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\n     * override.\\n     */\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\n        return 10000;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\n\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Removes default royalty information.\\n     */\\n    function _deleteDefaultRoyalty() internal virtual {\\n        delete _defaultRoyaltyInfo;\\n    }\\n\\n    /**\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\n     *\\n     * Requirements:\\n     *\\n     * - `receiver` cannot be the zero address.\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\n     */\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address receiver,\\n        uint96 feeNumerator\\n    ) internal virtual {\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\n\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\n    }\\n\\n    /**\\n     * @dev Resets royalty information for the token id back to the global default.\\n     */\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\n        delete _tokenRoyaltyInfo[tokenId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OpenSea/OperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {IOperatorFilterRegistry} from \\\"./IOperatorFilterRegistry.sol\\\";\\n\\n/**\\n * @title  OperatorFilterer\\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\\n *         registrant's entries in the OperatorFilterRegistry.\\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\\n */\\nabstract contract OperatorFilterer {\\n    error OperatorNotAllowed(address operator);\\n\\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\\n\\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\n        // order for the modifier to filter addresses.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (subscribe) {\\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(\\n                    address(this),\\n                    subscriptionOrRegistrantToCopy\\n                );\\n            } else {\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(\\n                        address(this),\\n                        subscriptionOrRegistrantToCopy\\n                    );\\n                } else {\\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\\n                }\\n            }\\n        }\\n    }\\n\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\n        _checkFilterOperator(operator);\\n        _;\\n    }\\n\\n    function _checkFilterOperator(address operator) internal view virtual {\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/OpenSea/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    function register(address registrant) external;\\n\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    function unregister(address addr) external;\\n\\n    function updateOperator(\\n        address registrant,\\n        address operator,\\n        bool filtered\\n    ) external;\\n\\n    function updateOperators(\\n        address registrant,\\n        address[] calldata operators,\\n        bool filtered\\n    ) external;\\n\\n    function updateCodeHash(\\n        address registrant,\\n        bytes32 codehash,\\n        bool filtered\\n    ) external;\\n\\n    function updateCodeHashes(\\n        address registrant,\\n        bytes32[] calldata codeHashes,\\n        bool filtered\\n    ) external;\\n\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode)\\n        external\\n        returns (bool);\\n\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    function isRegistered(address addr) external returns (bool);\\n\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"killer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"killedTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"birthTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalKill\",\"type\":\"uint256\"}],\"name\":\"Killed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_enchantedPeople\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numOfTomie\",\"type\":\"uint256[]\"}],\"name\":\"beginning\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeKill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"getKilledTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRegenerateLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"killedTokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseName\",\"type\":\"string\"}],\"name\":\"setBaseName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"newColors\",\"type\":\"string[]\"}],\"name\":\"setColors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feeNumerator\",\"type\":\"uint96\"}],\"name\":\"setDefaultRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newDescription\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFreeKill\",\"type\":\"uint256\"}],\"name\":\"setFreeKill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"newImageURIs\",\"type\":\"string[]\"}],\"name\":\"setImageURIs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newKillCost\",\"type\":\"uint256\"}],\"name\":\"setKillCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newDescription\",\"type\":\"string\"}],\"name\":\"setLv0Description\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"newImageURIs\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"newTitles\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"newColors\",\"type\":\"string[]\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRegenerateTime\",\"type\":\"uint256\"}],\"name\":\"setRegenerateTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"newTitles\",\"type\":\"string[]\"}],\"name\":\"setTitles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Tomie", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}