{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: --DG--\r\n\r\npragma solidity =0.8.15;\r\n\r\ncontract TokenKeeper {\r\n\r\n    address public tokenKeeper;\r\n    uint256 public totalRequired;\r\n\r\n    uint256 immutable minTimeFrame;\r\n    address immutable tokenAddress;\r\n\r\n    struct KeeperInfo {\r\n        uint256 keeperRate;\r\n        uint256 keeperFrom;\r\n        uint256 keeperTill;\r\n        uint256 keeperBalance;\r\n        uint256 keeperPayouts;\r\n    }\r\n\r\n    mapping(address => KeeperInfo) public keeperList;\r\n\r\n    modifier onlyTokenKeeper() {\r\n        require(\r\n            msg.sender == tokenKeeper,\r\n            \"TokenKeeper: ACCESS_DENIED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event recipientCreated(\r\n        address indexed recipient,\r\n        uint256 timeLock,\r\n        uint256 timeReward,\r\n        uint256 instantReward,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event tokensScraped(\r\n        address indexed scraper,\r\n        uint256 scrapedAmount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    constructor(\r\n        address _tokenKeeper,\r\n        uint256 _minTimeFrame,\r\n        address _tokenAddress\r\n    ) {\r\n        if (_tokenKeeper == address(0)) {\r\n            revert(\"TokenKeeper: INVALID_KEEPER\");\r\n        }\r\n\r\n        if (_minTimeFrame == 0) {\r\n            revert(\"TokenKeeper: INVALID_TIMEFRAME\");\r\n        }\r\n\r\n        if (_tokenAddress == address(0)) {\r\n            revert(\"TokenKeeper: INVALID_TOKEN\");\r\n        }\r\n\r\n        tokenKeeper = _tokenKeeper;\r\n        minTimeFrame = _minTimeFrame;\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    function allocateTokensBulk(\r\n        address[] memory _recipients,\r\n        uint256[] memory _tokensOpened,\r\n        uint256[] memory _tokensLocked,\r\n        uint256[] memory _timeFrame\r\n    )\r\n        external\r\n        onlyTokenKeeper\r\n    {\r\n        for (uint256 i = 0; i < _recipients.length; i++) {\r\n            allocateTokens(\r\n                _recipients[i],\r\n                _tokensOpened[i],\r\n                _tokensLocked[i],\r\n                _timeFrame[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function allocateTokens(\r\n        address _recipient,\r\n        uint256 _tokensOpened,\r\n        uint256 _tokensLocked,\r\n        uint256 _timeFrame\r\n    )\r\n        public\r\n        onlyTokenKeeper\r\n    {\r\n        require(\r\n            _timeFrame >= minTimeFrame,\r\n            \"TokenKeeper: INVALID_TIME_FRAME\"\r\n        );\r\n\r\n        totalRequired = totalRequired\r\n            + _tokensOpened\r\n            + _tokensLocked;\r\n\r\n        _checkTokenBalance(\r\n            totalRequired\r\n        );\r\n\r\n        uint256 timestamp = getNow();\r\n\r\n        keeperList[_recipient].keeperFrom = timestamp;\r\n        keeperList[_recipient].keeperTill = timestamp\r\n            + _timeFrame;\r\n\r\n        keeperList[_recipient].keeperRate = _tokensLocked\r\n            / _timeFrame;\r\n\r\n        keeperList[_recipient].keeperBalance = _tokensLocked\r\n            % _timeFrame\r\n            + _tokensOpened;\r\n\r\n        emit recipientCreated(\r\n            _recipient,\r\n            _timeFrame,\r\n            _tokensLocked,\r\n            _tokensOpened,\r\n            timestamp\r\n        );\r\n    }\r\n\r\n    function scrapeMyTokens()\r\n        external\r\n    {\r\n        _scrapeTokens(\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function _scrapeTokens(\r\n        address _recipient\r\n    )\r\n        private\r\n    {\r\n        uint256 scrapeAmount = availableBalance(\r\n            _recipient\r\n        );\r\n\r\n        keeperList[_recipient].keeperPayouts += scrapeAmount;\r\n\r\n        _safeTokenScrape(\r\n            _recipient,\r\n            scrapeAmount\r\n        );\r\n\r\n        emit tokensScraped(\r\n            _recipient,\r\n            scrapeAmount,\r\n            getNow()\r\n        );\r\n    }\r\n\r\n    function availableBalance(\r\n        address _recipient\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 timePassed =\r\n            getNow() < keeperList[_recipient].keeperTill ?\r\n            getNow() - keeperList[_recipient].keeperFrom : _diff(_recipient);\r\n\r\n        balance = keeperList[_recipient].keeperRate\r\n            * timePassed\r\n            + keeperList[_recipient].keeperBalance\r\n            - keeperList[_recipient].keeperPayouts;\r\n    }\r\n\r\n    function lockedBalance(\r\n        address _recipient\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        uint256 timeRemaining =\r\n            keeperList[_recipient].keeperTill > getNow() ?\r\n            keeperList[_recipient].keeperTill - getNow() : 0;\r\n\r\n        balance = keeperList[_recipient].keeperRate\r\n            * timeRemaining;\r\n    }\r\n\r\n    function getNow()\r\n        public\r\n        view\r\n        returns (uint256 time)\r\n    {\r\n        time = block.timestamp;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        external\r\n        onlyTokenKeeper\r\n    {\r\n        delete tokenKeeper;\r\n    }\r\n\r\n    function _diff(\r\n        address _recipient\r\n    )\r\n        private\r\n        view\r\n        returns (uint256 res)\r\n    {\r\n        res = keeperList[_recipient].keeperTill\r\n            - keeperList[_recipient].keeperFrom;\r\n    }\r\n\r\n    bytes4 private constant TRANSFER = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \"transfer(address,uint256)\"\r\n            )\r\n        )\r\n    );\r\n\r\n    bytes4 private constant BALANCEOF = bytes4(\r\n        keccak256(\r\n            bytes(\r\n                \"balanceOf(address)\"\r\n            )\r\n        )\r\n    );\r\n\r\n    function _safeTokenScrape(\r\n        address _to,\r\n        uint256 _scrapeAmount\r\n    )\r\n        private\r\n    {\r\n        totalRequired -= _scrapeAmount;\r\n\r\n        (bool success, bytes memory data) = tokenAddress.call(\r\n            abi.encodeWithSelector(\r\n                TRANSFER,\r\n                _to,\r\n                _scrapeAmount\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && (\r\n                data.length == 0 || abi.decode(\r\n                    data, (bool)\r\n                )\r\n            ),\r\n            \"TokenKeeper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function _checkTokenBalance(\r\n        uint256 _required\r\n    )\r\n        private\r\n    {\r\n        (bool success, bytes memory data) = tokenAddress.call(\r\n            abi.encodeWithSelector(\r\n                BALANCEOF,\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && abi.decode(\r\n                data, (uint256)\r\n            ) >= _required,\r\n            \"TokenKeeper: BALANCE_CHECK_FAILED\"\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenKeeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTimeFrame\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeLock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"instantReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"recipientCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"scraper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"tokensScraped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeFrame\",\"type\":\"uint256\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensOpened\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensLocked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_timeFrame\",\"type\":\"uint256[]\"}],\"name\":\"allocateTokensBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keeperList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"keeperRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperTill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keeperPayouts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"lockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scrapeMyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenKeeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenKeeper", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c383b7ffd5d2bf24ebd1fc8509cefa9b7d1976f000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000004f81c790581b240a5c948afd173620ecc8c71c8d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dadbbf74c63a23cca29f51ac4457f745c3fadd9f3ffa3c3407cf4d24b90ad633"}]}