{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport {LinkTokenInterface} from '@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol';\\nimport {TypeAndVersionInterface} from '@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol';\\nimport {AggregatorV3Interface} from '@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol';\\nimport {ConfirmedOwner} from '@chainlink/contracts/src/v0.8/ConfirmedOwner.sol';\\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\\nimport {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\\nimport {IERC165} from '@openzeppelin/contracts/interfaces/IERC165.sol';\\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\\nimport {IStaking} from './interfaces/IStaking.sol';\\nimport {IStakingOwner} from './interfaces/IStakingOwner.sol';\\nimport {IMerkleAccessController} from './interfaces/IMerkleAccessController.sol';\\nimport {IAlertsController} from './interfaces/IAlertsController.sol';\\nimport {IMigratable} from './interfaces/IMigratable.sol';\\nimport {StakingPoolLib} from './StakingPoolLib.sol';\\nimport {RewardLib, SafeCast} from './RewardLib.sol';\\n\\ncontract Staking is\\n  IStaking,\\n  IStakingOwner,\\n  IMigratable,\\n  IMerkleAccessController,\\n  IAlertsController,\\n  ConfirmedOwner,\\n  TypeAndVersionInterface,\\n  Pausable\\n{\\n  using StakingPoolLib for StakingPoolLib.Pool;\\n  using RewardLib for RewardLib.Reward;\\n  using SafeCast for uint256;\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct PoolConstructorParams {\\n    /// @notice The LINK Token\\n    LinkTokenInterface LINKAddress;\\n    /// @notice The feed being monitored when raising alerts\\n    AggregatorV3Interface monitoredFeed;\\n    /// @notice The initial maximum total stake amount across all stakers\\n    uint256 initialMaxPoolSize;\\n    /// @notice The initial maximum stake amount for a single community staker\\n    uint256 initialMaxCommunityStakeAmount;\\n    /// @notice The initial maximum stake amount for a single node operator\\n    uint256 initialMaxOperatorStakeAmount;\\n    /// @notice The minimum stake amount that a community staker can stake\\n    uint256 minCommunityStakeAmount;\\n    /// @notice The minimum stake amount that an operator can stake\\n    uint256 minOperatorStakeAmount;\\n    /// @notice The number of seconds until the feed is considered stale\\n    /// and the priority period begins.\\n    uint256 priorityPeriodThreshold;\\n    /// @notice The number of seconds until the priority period ends\\n    /// and the regular period begins.\\n    uint256 regularPeriodThreshold;\\n    /// @notice The amount of LINK to reward an operator who\\n    /// raises an alert in the priority period.\\n    uint256 maxAlertingRewardAmount;\\n    /// @notice The minimum number of node operators required to initialize the\\n    /// staking pool.\\n    uint256 minInitialOperatorCount;\\n    /// @notice The minimum reward duration after pool config updates and pool\\n    /// reward extensions\\n    uint256 minRewardDuration;\\n    /// @notice The duration of earned rewards to slash when an alert is raised\\n    uint256 slashableDuration;\\n    /// @notice Used to calculate delegated stake amount\\n    /// = amount / delegation rate denominator = 100% / 100 = 1%\\n    uint256 delegationRateDenominator;\\n  }\\n\\n  /// @notice The amount to divide an alerter's stake amount when\\n  /// calculating their reward for raising an alert.\\n  uint256 private constant ALERTING_REWARD_STAKED_AMOUNT_DENOMINATOR = 5;\\n\\n  LinkTokenInterface private immutable i_LINK;\\n  StakingPoolLib.Pool private s_pool;\\n  RewardLib.Reward private s_reward;\\n  /// @notice The ETH USD feed that alerters can raise alerts for.\\n  AggregatorV3Interface private immutable i_monitoredFeed;\\n  /// @notice The proposed address stakers will migrate funds to\\n  address private s_proposedMigrationTarget;\\n  /// @notice The timestamp of when the migration target was proposed at\\n  uint256 private s_proposedMigrationTargetAt;\\n  /// @notice The address stakers can migrate their funds to\\n  address private s_migrationTarget;\\n  /// @notice The round ID of the last feed round an alert was raised\\n  uint256 private s_lastAlertedRoundId;\\n  /// @notice The merkle root of the merkle tree generated from the list\\n  /// of staker addresses with early acccess.\\n  bytes32 private s_merkleRoot;\\n  /// @notice The number of seconds until the feed is considered stale\\n  /// and the priority period begins.\\n  uint256 private immutable i_priorityPeriodThreshold;\\n  /// @notice The number of seconds until the priority period ends\\n  /// and the regular period begins.\\n  uint256 private immutable i_regularPeriodThreshold;\\n  /// @notice The amount of LINK to reward an operator who\\n  /// raises an alert in the priority period.\\n  uint256 private immutable i_maxAlertingRewardAmount;\\n  /// @notice The minimum stake amount that a node operator can stake\\n  uint256 private immutable i_minOperatorStakeAmount;\\n  /// @notice The minimum stake amount that a community staker can stake\\n  uint256 private immutable i_minCommunityStakeAmount;\\n  /// @notice The minimum number of node operators required to initialize the\\n  /// staking pool.\\n  uint256 private immutable i_minInitialOperatorCount;\\n  /// @notice The minimum reward duration after pool config updates and pool\\n  /// reward extensions\\n  uint256 private immutable i_minRewardDuration;\\n  /// @notice The duration of earned rewards to slash when an alert is raised\\n  uint256 private immutable i_slashableDuration;\\n  /// @notice Used to calculate delegated stake amount\\n  /// = amount / delegation rate denominator = 100% / 100 = 1%\\n  uint256 private immutable i_delegationRateDenominator;\\n\\n  constructor(PoolConstructorParams memory params) ConfirmedOwner(msg.sender) {\\n    if (address(params.LINKAddress) == address(0)) revert InvalidZeroAddress();\\n    if (address(params.monitoredFeed) == address(0))\\n      revert InvalidZeroAddress();\\n    if (params.delegationRateDenominator == 0) revert InvalidDelegationRate();\\n    if (RewardLib.REWARD_PRECISION % params.delegationRateDenominator > 0)\\n      revert InvalidDelegationRate();\\n    if (params.regularPeriodThreshold <= params.priorityPeriodThreshold)\\n      revert InvalidRegularPeriodThreshold();\\n    if (params.minOperatorStakeAmount == 0)\\n      revert InvalidMinOperatorStakeAmount();\\n    if (params.minOperatorStakeAmount > params.initialMaxOperatorStakeAmount)\\n      revert InvalidMinOperatorStakeAmount();\\n    if (params.minCommunityStakeAmount > params.initialMaxCommunityStakeAmount)\\n      revert InvalidMinCommunityStakeAmount();\\n    if (params.maxAlertingRewardAmount > params.initialMaxOperatorStakeAmount)\\n      revert InvalidMaxAlertingRewardAmount();\\n\\n    s_pool._setConfig(\\n      params.initialMaxPoolSize,\\n      params.initialMaxCommunityStakeAmount,\\n      params.initialMaxOperatorStakeAmount\\n    );\\n    i_LINK = params.LINKAddress;\\n    i_monitoredFeed = params.monitoredFeed;\\n    i_priorityPeriodThreshold = params.priorityPeriodThreshold;\\n    i_regularPeriodThreshold = params.regularPeriodThreshold;\\n    i_maxAlertingRewardAmount = params.maxAlertingRewardAmount;\\n    i_minOperatorStakeAmount = params.minOperatorStakeAmount;\\n    i_minCommunityStakeAmount = params.minCommunityStakeAmount;\\n    i_minInitialOperatorCount = params.minInitialOperatorCount;\\n    i_minRewardDuration = params.minRewardDuration;\\n    i_slashableDuration = params.slashableDuration;\\n    i_delegationRateDenominator = params.delegationRateDenominator;\\n  }\\n\\n  // =======================\\n  // TypeAndVersionInterface\\n  // =======================\\n\\n  /// @inheritdoc TypeAndVersionInterface\\n  function typeAndVersion() external pure override returns (string memory) {\\n    return 'Staking 0.1.0';\\n  }\\n\\n  // =================\\n  // IMerkleAccessController\\n  // =================\\n\\n  /// @inheritdoc IMerkleAccessController\\n  function hasAccess(address staker, bytes32[] memory proof)\\n    external\\n    view\\n    override\\n    returns (bool)\\n  {\\n    if (s_merkleRoot == bytes32(0)) return true;\\n    return\\n      MerkleProof.verify(proof, s_merkleRoot, keccak256(abi.encode(staker)));\\n  }\\n\\n  /// @inheritdoc IMerkleAccessController\\n  function setMerkleRoot(bytes32 newMerkleRoot) external override onlyOwner {\\n    s_merkleRoot = newMerkleRoot;\\n    emit MerkleRootChanged(newMerkleRoot);\\n  }\\n\\n  /// @inheritdoc IMerkleAccessController\\n  function getMerkleRoot() external view override returns (bytes32) {\\n    return s_merkleRoot;\\n  }\\n\\n  // =============\\n  // IStakingOwner\\n  // =============\\n\\n  /// @inheritdoc IStakingOwner\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxCommunityStakeAmount,\\n    uint256 maxOperatorStakeAmount\\n  ) external override(IStakingOwner) onlyOwner whenActive {\\n    s_pool._setConfig(\\n      maxPoolSize,\\n      maxCommunityStakeAmount,\\n      maxOperatorStakeAmount\\n    );\\n\\n    s_reward._updateDuration(\\n      maxPoolSize,\\n      s_pool._getTotalStakedAmount(),\\n      uint256(s_reward.base.rate),\\n      i_minRewardDuration,\\n      getAvailableReward(),\\n      getTotalDelegatedAmount()\\n    );\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function setFeedOperators(address[] calldata operators)\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n  {\\n    s_pool._setFeedOperators(operators);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function start(uint256 amount, uint256 initialRewardRate)\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n  {\\n    if (s_merkleRoot == bytes32(0)) revert MerkleRootNotSet();\\n\\n    s_pool._open(i_minInitialOperatorCount);\\n\\n    // We need to transfer LINK balance before we initialize the reward to\\n    // calculate the new reward expiry timestamp.\\n    i_LINK.transferFrom(msg.sender, address(this), amount);\\n\\n    s_reward._initialize(\\n      uint256(s_pool.limits.maxPoolSize),\\n      initialRewardRate,\\n      i_minRewardDuration,\\n      getAvailableReward()\\n    );\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function conclude() external override(IStakingOwner) onlyOwner whenActive {\\n    s_reward._release(\\n      s_pool._getTotalStakedAmount(),\\n      getTotalDelegatedAmount()\\n    );\\n\\n    s_pool._close();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function addReward(uint256 amount)\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n    whenActive\\n  {\\n    // We need to transfer LINK balance before we recalculate the reward expiry\\n    // timestamp so the new amount is accounted for.\\n    i_LINK.transferFrom(msg.sender, address(this), amount);\\n\\n    s_reward._updateDuration(\\n      uint256(s_pool.limits.maxPoolSize),\\n      s_pool._getTotalStakedAmount(),\\n      uint256(s_reward.base.rate),\\n      i_minRewardDuration,\\n      getAvailableReward(),\\n      getTotalDelegatedAmount()\\n    );\\n\\n    emit RewardLib.RewardAdded(amount);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function withdrawUnusedReward()\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n    whenInactive\\n  {\\n    uint256 unusedRewards = getAvailableReward() -\\n      uint256(s_reward.reserved.base) -\\n      uint256(s_reward.reserved.delegated);\\n    emit RewardLib.RewardWithdrawn(unusedRewards);\\n\\n    // msg.sender is the owner address as only the owner can call this function\\n    i_LINK.transfer(msg.sender, unusedRewards);\\n  }\\n\\n  /// @dev Required conditions for adding operators:\\n  /// - Operators can only be added to the pool if they have no prior stake.\\n  /// - Operators can only be readded to the pool if they have no removed\\n  /// stake.\\n  /// - Operators cannot be added to the pool after staking ends (either through\\n  /// conclusion or through reward expiry).\\n  /// @inheritdoc IStakingOwner\\n  function addOperators(address[] calldata operators)\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n  {\\n    // If reward was initialized (meaning the pool was active) but the pool is\\n    // no longer active we want to prevent adding new operators.\\n    if (s_reward.startTimestamp > 0 && !isActive())\\n      revert StakingPoolLib.InvalidPoolStatus(false, true);\\n\\n    s_pool._addOperators(operators);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function removeOperators(address[] calldata operators)\\n    external\\n    override(IStakingOwner)\\n    onlyOwner\\n    whenActive\\n  {\\n    // Accumulate delegation rewards before removing operators as this affects\\n    // rewards that are distributed to remaining operators.\\n    s_reward._accumulateDelegationRewards(getTotalDelegatedAmount());\\n\\n    for (uint256 i; i < operators.length; i++) {\\n      address operator = operators[i];\\n      StakingPoolLib.Staker memory staker = s_pool.stakers[operator];\\n\\n      if (!staker.isOperator)\\n        revert StakingPoolLib.OperatorDoesNotExist(operator);\\n\\n      // Operator must not be on the feed\\n      if (staker.isFeedOperator)\\n        revert StakingPoolLib.OperatorIsAssignedToFeed(operator);\\n\\n      uint256 principal = staker.stakedAmount;\\n      // An operator with stake is a delegate\\n      if (principal > 0) {\\n        // The operator's rewards are forfeited when they are removed\\n        // Unreserve operator's earned base reward\\n        s_reward.reserved.base -= getBaseReward(operator)._toUint96();\\n        // Unreserve operator's future base reward\\n        s_reward.reserved.base -= s_reward\\n          ._calculateReward(principal, s_reward._getRemainingDuration())\\n          ._toUint96();\\n\\n        // Unreserve operator's earned delegation reward. We don't need to\\n        // unreserve future delegation rewards because they will be split by\\n        // other operators.\\n        s_reward.reserved.delegated -= getDelegationReward(operator)\\n          ._toUint96();\\n\\n        s_reward.delegated.delegatesCount -= 1;\\n        delete s_pool.stakers[operator].stakedAmount;\\n        uint96 castPrincipal = principal._toUint96();\\n        s_pool.state.totalOperatorStakedAmount -= castPrincipal;\\n        // Only the operator's principal is withdrawable after they are removed\\n        s_pool.stakers[operator].removedStakeAmount = castPrincipal;\\n        s_pool.totalOperatorRemovedAmount += castPrincipal;\\n\\n        // We need to reset operator's missed base rewards in case they decide\\n        // to stake as a community staker using the same address. It's fine to\\n        // not reset missed delegated rewards, because a removed operator\\n        // cannot be re-added as operator again.\\n        delete s_reward.missed[operator].base;\\n      }\\n\\n      s_pool.stakers[operator].isOperator = false;\\n      emit StakingPoolLib.OperatorRemoved(operator, principal);\\n    }\\n\\n    s_pool.state.operatorsCount -= operators.length._toUint8();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function changeRewardRate(uint256 newRate)\\n    external\\n    override\\n    onlyOwner\\n    whenActive\\n  {\\n    if (newRate == 0) revert();\\n\\n    uint256 totalDelegatedAmount = getTotalDelegatedAmount();\\n\\n    s_reward._accumulateDelegationRewards(totalDelegatedAmount);\\n    s_reward._accumulateBaseRewards();\\n    s_reward._updateDuration(\\n      uint256(s_pool.limits.maxPoolSize),\\n      s_pool._getTotalStakedAmount(),\\n      newRate,\\n      i_minRewardDuration,\\n      getAvailableReward(),\\n      totalDelegatedAmount\\n    );\\n\\n    emit RewardLib.RewardRateChanged(newRate);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function emergencyPause() external override(IStakingOwner) onlyOwner {\\n    _pause();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function emergencyUnpause() external override(IStakingOwner) onlyOwner {\\n    _unpause();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  function getFeedOperators()\\n    external\\n    view\\n    override(IStakingOwner)\\n    returns (address[] memory)\\n  {\\n    return s_pool.feedOperators;\\n  }\\n\\n  // ===========\\n  // IMigratable\\n  // ===========\\n\\n  /// @inheritdoc IMigratable\\n  function getMigrationTarget()\\n    external\\n    view\\n    override(IMigratable)\\n    returns (address)\\n  {\\n    return s_migrationTarget;\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  function proposeMigrationTarget(address migrationTarget)\\n    external\\n    override(IMigratable)\\n    onlyOwner\\n  {\\n    if (\\n      migrationTarget.code.length == 0 ||\\n      migrationTarget == address(this) ||\\n      s_proposedMigrationTarget == migrationTarget ||\\n      s_migrationTarget == migrationTarget ||\\n      !IERC165(migrationTarget).supportsInterface(this.onTokenTransfer.selector)\\n    ) revert InvalidMigrationTarget();\\n\\n    s_migrationTarget = address(0);\\n    s_proposedMigrationTarget = migrationTarget;\\n    s_proposedMigrationTargetAt = block.timestamp;\\n    emit MigrationTargetProposed(migrationTarget);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  function acceptMigrationTarget() external override(IMigratable) onlyOwner {\\n    if (s_proposedMigrationTarget == address(0))\\n      revert InvalidMigrationTarget();\\n\\n    if (block.timestamp < (uint256(s_proposedMigrationTargetAt) + 7 days))\\n      revert AccessForbidden();\\n\\n    s_migrationTarget = s_proposedMigrationTarget;\\n    s_proposedMigrationTarget = address(0);\\n    emit MigrationTargetAccepted(s_migrationTarget);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  function migrate(bytes calldata data)\\n    external\\n    override(IMigratable)\\n    whenInactive\\n  {\\n    if (s_migrationTarget == address(0)) revert InvalidMigrationTarget();\\n\\n    (uint256 amount, uint256 baseReward, uint256 delegationReward) = _exit(\\n      msg.sender\\n    );\\n\\n    emit Migrated(msg.sender, amount, baseReward, delegationReward, data);\\n\\n    i_LINK.transferAndCall(\\n      s_migrationTarget,\\n      uint256(amount + baseReward + delegationReward),\\n      abi.encode(msg.sender, data)\\n    );\\n  }\\n\\n  // =================\\n  // IAlertsController\\n  // =================\\n\\n  /// @inheritdoc IAlertsController\\n  function raiseAlert() external override(IAlertsController) whenActive {\\n    uint256 stakedAmount = getStake(msg.sender);\\n    if (stakedAmount == 0) revert AccessForbidden();\\n\\n    (uint256 roundId, , , uint256 lastFeedUpdatedAt, ) = i_monitoredFeed\\n      .latestRoundData();\\n\\n    if (roundId == s_lastAlertedRoundId) revert AlertAlreadyExists(roundId);\\n\\n    if (block.timestamp < lastFeedUpdatedAt + i_priorityPeriodThreshold)\\n      revert AlertInvalid();\\n\\n    bool isInPriorityPeriod = block.timestamp <\\n      lastFeedUpdatedAt + i_regularPeriodThreshold;\\n\\n    if (isInPriorityPeriod && !s_pool._isOperator(msg.sender))\\n      revert AlertInvalid();\\n\\n    s_lastAlertedRoundId = roundId;\\n\\n    // There is a risk that this might get us below the total amount of\\n    // reserved if the reward amount slashed is greater than LINK\\n    // balance in the pool.  This is an extreme edge case that will only occur\\n    /// if an alert is raised many times such that it completely depletes the\\n    // available rewards in the pool.  As this is an unlikely scenario, the\\n    // contract avoids adding an extra check to minimize gas costs.\\n    // There is a similar edge case when the total slashed amount is less than\\n    // the alerting reward. This can happen because slashed amounts are capped to\\n    // earned rewards so far. The result is a net outflow of rewards from the\\n    // staking pool up to the max alerting reward amount in the worst case.\\n    // This is acceptable and in practice has little to no impact to staking.\\n    uint256 rewardAmount = _calculateAlertingRewardAmount(\\n      stakedAmount,\\n      isInPriorityPeriod\\n    );\\n\\n    emit AlertRaised(msg.sender, roundId, rewardAmount);\\n\\n    // We need to transfer the rewards out before recalculating the new reward\\n    // expiry timestamp\\n    i_LINK.transfer(msg.sender, rewardAmount);\\n\\n    s_reward._slashOnFeedOperators(\\n      i_minOperatorStakeAmount,\\n      i_slashableDuration,\\n      s_pool.feedOperators,\\n      s_pool.stakers,\\n      getTotalDelegatedAmount()\\n    );\\n\\n    s_reward._updateDuration(\\n      uint256(s_pool.limits.maxPoolSize),\\n      s_pool._getTotalStakedAmount(),\\n      uint256(s_reward.base.rate),\\n      0,\\n      getAvailableReward(),\\n      getTotalDelegatedAmount()\\n    );\\n  }\\n\\n  /// @inheritdoc IAlertsController\\n  function canAlert(address alerter)\\n    external\\n    view\\n    override(IAlertsController)\\n    returns (bool)\\n  {\\n    if (getStake(alerter) == 0) return false;\\n    if (!isActive()) return false;\\n    (uint256 roundId, , , uint256 updatedAt, ) = i_monitoredFeed\\n      .latestRoundData();\\n    if (roundId == s_lastAlertedRoundId) return false;\\n\\n    // nobody can (feed is not stale)\\n    if (block.timestamp < updatedAt + i_priorityPeriodThreshold) return false;\\n\\n    // all stakers can (regular alerters)\\n    if (block.timestamp >= updatedAt + i_regularPeriodThreshold) return true;\\n    return s_pool._isOperator(alerter); // only operators can (priority alerters)\\n  }\\n\\n  // ========\\n  // IStaking\\n  // ========\\n\\n  /// @inheritdoc IStaking\\n  function unstake() external override(IStaking) whenInactive {\\n    (uint256 amount, uint256 baseReward, uint256 delegationReward) = _exit(\\n      msg.sender\\n    );\\n\\n    emit Unstaked(msg.sender, amount, baseReward, delegationReward);\\n    i_LINK.transfer(msg.sender, amount + baseReward + delegationReward);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function withdrawRemovedStake() external override(IStaking) whenInactive {\\n    uint256 amount = s_pool.stakers[msg.sender].removedStakeAmount;\\n    if (amount == 0) revert StakingPoolLib.StakeNotFound(msg.sender);\\n\\n    s_pool.totalOperatorRemovedAmount -= amount;\\n    delete s_pool.stakers[msg.sender].removedStakeAmount;\\n    emit Unstaked(msg.sender, amount, 0, 0);\\n    i_LINK.transfer(msg.sender, amount);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getStake(address staker)\\n    public\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return s_pool.stakers[staker].stakedAmount;\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function isOperator(address staker)\\n    external\\n    view\\n    override(IStaking)\\n    returns (bool)\\n  {\\n    return s_pool._isOperator(staker);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function isActive() public view override(IStaking) returns (bool) {\\n    return s_pool.state.isOpen && !s_reward._isDepleted();\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getMaxPoolSize() external view override(IStaking) returns (uint256) {\\n    return uint256(s_pool.limits.maxPoolSize);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getCommunityStakerLimits()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256, uint256)\\n  {\\n    return (\\n      i_minCommunityStakeAmount,\\n      uint256(s_pool.limits.maxCommunityStakeAmount)\\n    );\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getOperatorLimits()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256, uint256)\\n  {\\n    return (\\n      i_minOperatorStakeAmount,\\n      uint256(s_pool.limits.maxOperatorStakeAmount)\\n    );\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getRewardTimestamps()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256, uint256)\\n  {\\n    return (uint256(s_reward.startTimestamp), uint256(s_reward.endTimestamp));\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getRewardRate() external view override(IStaking) returns (uint256) {\\n    return uint256(s_reward.base.rate);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getDelegationRateDenominator()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return i_delegationRateDenominator;\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getAvailableReward()\\n    public\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return\\n      i_LINK.balanceOf(address(this)) -\\n      s_pool._getTotalStakedAmount() -\\n      s_pool.totalOperatorRemovedAmount;\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getBaseReward(address staker)\\n    public\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    uint256 stake = s_pool.stakers[staker].stakedAmount;\\n    if (stake == 0) return 0;\\n\\n    if (s_pool._isOperator(staker)) {\\n      return s_reward._getOperatorEarnedBaseRewards(staker, stake);\\n    }\\n\\n    return\\n      s_reward._calculateAccruedBaseRewards(\\n        RewardLib._getNonDelegatedAmount(stake, i_delegationRateDenominator)\\n      ) - uint256(s_reward.missed[staker].base);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getDelegationReward(address staker)\\n    public\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    StakingPoolLib.Staker memory stakerAccount = s_pool.stakers[staker];\\n    if (!stakerAccount.isOperator) return 0;\\n    if (stakerAccount.stakedAmount == 0) return 0;\\n    return\\n      s_reward._getOperatorEarnedDelegatedRewards(\\n        staker,\\n        getTotalDelegatedAmount()\\n      );\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getTotalDelegatedAmount()\\n    public\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return\\n      RewardLib._getDelegatedAmount(\\n        s_pool.state.totalCommunityStakedAmount,\\n        i_delegationRateDenominator\\n      );\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getDelegatesCount()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return uint256(s_reward.delegated.delegatesCount);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getTotalStakedAmount()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return s_pool._getTotalStakedAmount();\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getTotalCommunityStakedAmount()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return s_pool.state.totalCommunityStakedAmount;\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getTotalRemovedAmount()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return s_pool.totalOperatorRemovedAmount;\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getEarnedBaseRewards()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return\\n      s_reward._getEarnedBaseRewards(\\n        s_pool._getTotalStakedAmount(),\\n        getTotalDelegatedAmount()\\n      );\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getEarnedDelegationRewards()\\n    external\\n    view\\n    override(IStaking)\\n    returns (uint256)\\n  {\\n    return s_reward._getEarnedDelegationRewards(getTotalDelegatedAmount());\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function isPaused() external view override(IStaking) returns (bool) {\\n    return paused();\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getChainlinkToken()\\n    public\\n    view\\n    override(IStaking)\\n    returns (address)\\n  {\\n    return address(i_LINK);\\n  }\\n\\n  /// @inheritdoc IStaking\\n  function getMonitoredFeed() external view override returns (address) {\\n    return address(i_monitoredFeed);\\n  }\\n\\n  /**\\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\\n   * @param sender Address of the sender\\n   * @param amount Amount of LINK sent (specified in wei)\\n   * @param data Optional payload containing a Staking Allowlist Merkle proof\\n   */\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes memory data\\n  ) external validateFromLINK whenNotPaused whenActive {\\n    if (amount < RewardLib.REWARD_PRECISION)\\n      revert StakingPoolLib.InsufficientStakeAmount(RewardLib.REWARD_PRECISION);\\n\\n    // TL;DR: Reward calculation and delegation logic requires precise numbers\\n    // to avoid cumulative rounding errors.\\n    // Long explanation:\\n    // When users stake amounts that are rounded down to 0 after dividing\\n    // by the delegation rate denominator, not enough rewards are reserved for\\n    // the user. When the user then stakes enough times, small rounding errors\\n    // accumulate. This causes an integer underflow when unreserving rewards because\\n    // the total delegated amount returns a larger number than what individual\\n    // reserved amounts sum up to.\\n    uint256 remainder = amount % RewardLib.REWARD_PRECISION;\\n    if (remainder > 0) {\\n      amount -= remainder;\\n      i_LINK.transfer(sender, remainder);\\n    }\\n\\n    if (s_pool._isOperator(sender)) {\\n      _stakeAsOperator(sender, amount);\\n    } else {\\n      // If a Merkle root is set, the sender should\\n      // prove that they are part of the merkle tree\\n      if (s_merkleRoot != bytes32(0)) {\\n        if (data.length == 0) revert AccessForbidden();\\n        if (\\n          !MerkleProof.verify(\\n            abi.decode(data, (bytes32[])),\\n            s_merkleRoot,\\n            keccak256(abi.encode(sender))\\n          )\\n        ) revert AccessForbidden();\\n      }\\n      _stakeAsCommunityStaker(sender, amount);\\n    }\\n  }\\n\\n  // =======\\n  // Private\\n  // =======\\n\\n  /// @notice Helper function for when a community staker enters the pool\\n  /// @param staker The staker address\\n  /// @param amount The amount of principal staked\\n  /// @dev When an operator is removed they can stake as a community staker.\\n  /// We allow that because the alternative (checking for removed stake before\\n  /// staking) is going to unnecessarily increase gas costs in 99.99% of the\\n  /// cases.\\n  function _stakeAsCommunityStaker(address staker, uint256 amount) private {\\n    uint256 currentStakedAmount = s_pool.stakers[staker].stakedAmount;\\n    uint256 newStakedAmount = currentStakedAmount + amount;\\n    // Check that the amount is greater than or equal to the minimum required\\n    if (newStakedAmount < i_minCommunityStakeAmount)\\n      revert StakingPoolLib.InsufficientStakeAmount(i_minCommunityStakeAmount);\\n\\n    // Check that the amount is less than or equal to the maximum allowed\\n    uint256 maxCommunityStakeAmount = uint256(\\n      s_pool.limits.maxCommunityStakeAmount\\n    );\\n    if (newStakedAmount > maxCommunityStakeAmount)\\n      revert StakingPoolLib.ExcessiveStakeAmount(\\n        maxCommunityStakeAmount - currentStakedAmount\\n      );\\n\\n    // Check if the amount supplied increases the total staked amount above\\n    // the maximum pool size\\n    uint256 remainingPoolSpace = s_pool._getRemainingPoolSpace();\\n    if (amount > remainingPoolSpace)\\n      revert StakingPoolLib.ExcessiveStakeAmount(remainingPoolSpace);\\n\\n    s_reward._accumulateDelegationRewards(getTotalDelegatedAmount());\\n    uint256 extraNonDelegatedAmount = RewardLib._getNonDelegatedAmount(\\n      amount,\\n      i_delegationRateDenominator\\n    );\\n    s_reward.missed[staker].base += s_reward\\n      ._calculateAccruedBaseRewards(extraNonDelegatedAmount)\\n      ._toUint96();\\n    s_reward._reserve(\\n      extraNonDelegatedAmount,\\n      RewardLib._getDelegatedAmount(amount, i_delegationRateDenominator)\\n    );\\n    s_pool.state.totalCommunityStakedAmount += amount._toUint96();\\n    s_pool.stakers[staker].stakedAmount = newStakedAmount._toUint96();\\n    emit Staked(staker, amount, newStakedAmount);\\n  }\\n\\n  /// @notice Helper function for when an operator enters the pool\\n  /// @dev Function skips validating whether or not the operator stake\\n  /// amount will cause the total stake amount to exceed the maximum pool size.\\n  /// This is because the pool already reserves a fixed amount of space\\n  /// for each operator meaning that an operator staking cannot cause the\\n  /// total stake amount to exceed the maximum pool size.  Each operator\\n  /// receives a reserved stake amount equal to the maxOperatorStakeAmount.\\n  /// This is done by deducting operatorCount * maxOperatorStakeAmount from the\\n  /// remaining pool space available for staking.\\n  /// @param staker The staker address\\n  /// @param amount The amount of principal staked\\n  function _stakeAsOperator(address staker, uint256 amount) private {\\n    StakingPoolLib.Staker storage operator = s_pool.stakers[staker];\\n    uint256 currentStakedAmount = operator.stakedAmount;\\n    uint256 newStakedAmount = currentStakedAmount + amount;\\n\\n    // Check that the amount is greater than or equal to the minimum required\\n    if (newStakedAmount < i_minOperatorStakeAmount)\\n      revert StakingPoolLib.InsufficientStakeAmount(i_minOperatorStakeAmount);\\n\\n    // Check that the amount is less than or equal to the maximum allowed\\n    uint256 maxOperatorStakeAmount = uint256(\\n      s_pool.limits.maxOperatorStakeAmount\\n    );\\n    if (newStakedAmount > maxOperatorStakeAmount)\\n      revert StakingPoolLib.ExcessiveStakeAmount(\\n        maxOperatorStakeAmount - currentStakedAmount\\n      );\\n\\n    // On first stake\\n    if (currentStakedAmount == 0) {\\n      s_reward._accumulateDelegationRewards(getTotalDelegatedAmount());\\n      uint8 delegatesCount = s_reward.delegated.delegatesCount;\\n\\n      // We are doing this check to unreserve any unused delegated rewards\\n      // prior to the first operator staking. After the rewards are unreserved\\n      // we reset the accumulated value so it doesn't count towards missed\\n      // rewards.\\n      // There is a known edge-case where, if no operator stakes throughout the\\n      // duration of the pool, we wouldn't unreserve unused delegation rewards.\\n      // In practice this shouldn't happen and, if it does, there are\\n      // operational workarounds to unreserve those rewards.\\n      if (delegatesCount == 0) {\\n        s_reward.reserved.delegated -= s_reward.delegated.cumulativePerDelegate;\\n        delete s_reward.delegated.cumulativePerDelegate;\\n      }\\n\\n      s_reward.delegated.delegatesCount = delegatesCount + 1;\\n\\n      s_reward.missed[staker].delegated = s_reward\\n        .delegated\\n        .cumulativePerDelegate;\\n    }\\n\\n    s_reward.missed[staker].base += s_reward\\n      ._calculateAccruedBaseRewards(amount)\\n      ._toUint96();\\n    s_pool.state.totalOperatorStakedAmount += amount._toUint96();\\n    s_reward._reserve(amount, 0);\\n    s_pool.stakers[staker].stakedAmount = newStakedAmount._toUint96();\\n    emit Staked(staker, amount, newStakedAmount);\\n  }\\n\\n  /// @notice Helper function when staker exits the pool\\n  /// @param staker The staker address\\n  function _exit(address staker)\\n    private\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    StakingPoolLib.Staker memory stakerAccount = s_pool.stakers[staker];\\n    if (stakerAccount.stakedAmount == 0)\\n      revert StakingPoolLib.StakeNotFound(staker);\\n\\n    // If the pool isOpen that means that we haven't concluded it and stakers\\n    // got here because the reward depleted. In that case, the first user to\\n    // unstake will accumulate delegation and base rewards to save on cost for\\n    // others.\\n    if (s_pool.state.isOpen) {\\n      // Accumulate base and delegation rewards before unreserving rewards to\\n      // save gas costs. We can use the accumulated reward per micro LINK and\\n      // accumulated delegation reward to simplify reward calculations.\\n      s_reward._accumulateDelegationRewards(getTotalDelegatedAmount());\\n      s_reward._accumulateBaseRewards();\\n      delete s_pool.state.isOpen;\\n    }\\n\\n    if (stakerAccount.isOperator) {\\n      s_pool.state.totalOperatorStakedAmount -= stakerAccount.stakedAmount;\\n\\n      uint256 baseReward = s_reward._calculateConcludedBaseRewards(\\n        stakerAccount.stakedAmount,\\n        staker\\n      );\\n      uint256 delegationReward = uint256(\\n        s_reward.delegated.cumulativePerDelegate\\n      ) - uint256(s_reward.missed[staker].delegated);\\n\\n      delete s_pool.stakers[staker].stakedAmount;\\n      s_reward.reserved.base -= baseReward._toUint96();\\n      s_reward.reserved.delegated -= delegationReward._toUint96();\\n      return (stakerAccount.stakedAmount, baseReward, delegationReward);\\n    } else {\\n      s_pool.state.totalCommunityStakedAmount -= stakerAccount.stakedAmount;\\n\\n      uint256 baseReward = s_reward._calculateConcludedBaseRewards(\\n        RewardLib._getNonDelegatedAmount(\\n          stakerAccount.stakedAmount,\\n          i_delegationRateDenominator\\n        ),\\n        staker\\n      );\\n      delete s_pool.stakers[staker].stakedAmount;\\n      s_reward.reserved.base -= baseReward._toUint96();\\n      return (stakerAccount.stakedAmount, baseReward, 0);\\n    }\\n  }\\n\\n  /// @notice Calculates the reward amount an alerter will receive for raising\\n  /// a successful alert in the current alerting period.\\n  /// @param stakedAmount Amount of LINK staked by the alerter\\n  /// @param isInPriorityPeriod True if it is currently in the priority period\\n  /// @return rewardAmount Amount of LINK rewards to be paid to the alerter\\n  function _calculateAlertingRewardAmount(\\n    uint256 stakedAmount,\\n    bool isInPriorityPeriod\\n  ) private view returns (uint256) {\\n    if (isInPriorityPeriod) return i_maxAlertingRewardAmount;\\n    return\\n      Math.min(\\n        stakedAmount / ALERTING_REWARD_STAKED_AMOUNT_DENOMINATOR,\\n        i_maxAlertingRewardAmount\\n      );\\n  }\\n\\n  // =========\\n  // Modifiers\\n  // =========\\n\\n  /// @dev Having a private function for the modifer saves on the contract size\\n  function _isActive() private view {\\n    if (!isActive()) revert StakingPoolLib.InvalidPoolStatus(false, true);\\n  }\\n\\n  /// @dev Reverts if the staking pool is inactive (not open for staking or\\n  /// expired)\\n  modifier whenActive() {\\n    _isActive();\\n\\n    _;\\n  }\\n\\n  /// @dev Reverts if the staking pool is active (open for staking)\\n  modifier whenInactive() {\\n    if (isActive()) revert StakingPoolLib.InvalidPoolStatus(true, false);\\n\\n    _;\\n  }\\n\\n  /// @dev Reverts if not sent from the LINK token\\n  modifier validateFromLINK() {\\n    if (msg.sender != getChainlinkToken()) revert SenderNotLinkToken();\\n\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/RewardLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport {SafeCast} from './SafeCast.sol';\\nimport {StakingPoolLib} from './StakingPoolLib.sol';\\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nlibrary RewardLib {\\n  using SafeCast for uint256;\\n\\n  /// @notice emitted when the reward is initialized for the first time\\n  /// @param rate the reward rate\\n  /// @param available the amount of rewards available for distribution in the\\n  /// staking pool\\n  /// @param startTimestamp the start timestamp when rewards are started\\n  /// @param endTimestamp the timestamp when the reward will run out\\n  event RewardInitialized(\\n    uint256 rate,\\n    uint256 available,\\n    uint256 startTimestamp,\\n    uint256 endTimestamp\\n  );\\n  /// @notice emitted when owner changes the reward rate\\n  /// @param rate the new reward rate\\n  event RewardRateChanged(uint256 rate);\\n  /// @notice emitted when owner adds more rewards to the pool\\n  /// @param amountAdded the amount of LINK rewards added to the pool\\n  event RewardAdded(uint256 amountAdded);\\n  /// @notice emitted when owner withdraws unreserved rewards\\n  /// @param amount the amount of rewards withdrawn\\n  event RewardWithdrawn(uint256 amount);\\n  /// @notice emitted when an on feed operator gets slashed.\\n  /// Node operators are not slashed more than the amount of rewards they\\n  /// have earned.  This means that a node operator that has not\\n  /// accumulated at least two weeks of rewards will be slashed\\n  /// less than an operator that has accumulated at least\\n  /// two weeks of rewards.\\n  event RewardSlashed(\\n    address[] operator,\\n    uint256[] slashedBaseRewards,\\n    uint256[] slashedDelegatedRewards\\n  );\\n\\n  /// @notice This error is thrown when the updated reward duration is less than a month\\n  error RewardDurationTooShort();\\n\\n  /// @notice This is the reward calculation precision variable. LINK token has the\\n  /// 1e18 multiplier which means that rewards are floored after 6 decimals\\n  /// points. Micro LINK is the smallest unit that is eligible for rewards.\\n  uint256 internal constant REWARD_PRECISION = 1e12;\\n\\n  struct DelegatedRewards {\\n    // Count of delegates who are eligible for a share of a reward\\n    // This is always going to be less or equal to operatorsCount\\n    uint8 delegatesCount;\\n    // Tracks base reward amounts that goes to an operator as delegation rewards.\\n    // Used to correctly account for any changes in operator count, delegated amount, or reward rate.\\n    // Formula: duration * rate * amount\\n    uint96 cumulativePerDelegate;\\n    // Timestamp of the last time accumulate was called\\n    // `startTimestamp` <= `delegated.lastAccumulateTimestamp`\\n    uint32 lastAccumulateTimestamp;\\n  }\\n\\n  struct BaseRewards {\\n    // Reward rate expressed in juels per second per micro LINK\\n    uint80 rate;\\n    // The cumulative LINK accrued per stake from past reward rates\\n    // expressed in juels per micro LINK\\n    // Formula: sum of (previousRate * elapsedDurationSinceLastAccumulate)\\n    uint96 cumulativePerMicroLINK;\\n    // Timestamp of the last time the base reward rate was accumulated\\n    uint32 lastAccumulateTimestamp;\\n  }\\n\\n  struct MissedRewards {\\n    // Tracks missed base rewards that are deducted from late stakers\\n    uint96 base;\\n    // Tracks missed delegation rewards that are deducted from late delegates\\n    uint96 delegated;\\n  }\\n\\n  struct ReservedRewards {\\n    // Tracks base reward amount reserved for stakers. This can be used after\\n    // `endTimestamp` to calculate unused amount.\\n    // This amount accumulates as the reward is utilized.\\n    // Formula: duration * rate * amount\\n    uint96 base;\\n    // Tracks delegated reward amount reserved for node operators. This can\\n    // be used after `endTimestamp` to calculate unused amount.\\n    // This amount accumulates as the reward is utilized.\\n    // Formula: duration * rate * amount\\n    uint96 delegated;\\n  }\\n\\n  struct Reward {\\n    mapping(address => MissedRewards) missed;\\n    DelegatedRewards delegated;\\n    BaseRewards base;\\n    ReservedRewards reserved;\\n    // Timestamp when the reward stops accumulating. Has to support a very long\\n    // duration for scenarios with low reward rate.\\n    // `endTimestamp` >= `startTimestamp`\\n    uint256 endTimestamp;\\n    // Timestamp when the reward comes into effect\\n    // `startTimestamp` <= `endTimestamp`\\n    uint32 startTimestamp;\\n  }\\n\\n  /// @notice initializes the reward with the defined parameters\\n  /// @param maxPoolSize maximum pool size that the reward is initialized with\\n  /// @param rate reward rate\\n  /// @param minRewardDuration the minimum duration rewards need to last for\\n  /// @param availableReward available reward amount\\n  /// @dev can only be called once. Any future reward changes have to be done\\n  /// using specific functions.\\n  function _initialize(\\n    Reward storage reward,\\n    uint256 maxPoolSize,\\n    uint256 rate,\\n    uint256 minRewardDuration,\\n    uint256 availableReward\\n  ) internal {\\n    if (reward.startTimestamp != 0) revert();\\n\\n    reward.base.rate = rate._toUint80();\\n\\n    uint32 blockTimestamp = block.timestamp._toUint32();\\n    reward.startTimestamp = blockTimestamp;\\n    reward.delegated.lastAccumulateTimestamp = blockTimestamp;\\n    reward.base.lastAccumulateTimestamp = blockTimestamp;\\n\\n    _updateDuration(\\n      reward,\\n      maxPoolSize,\\n      0,\\n      rate,\\n      minRewardDuration,\\n      availableReward,\\n      0\\n    );\\n\\n    emit RewardInitialized(\\n      rate,\\n      availableReward,\\n      reward.startTimestamp,\\n      reward.endTimestamp\\n    );\\n  }\\n\\n  /// @return bool true if the reward is expired (end <= now)\\n  function _isDepleted(Reward storage reward) internal view returns (bool) {\\n    return reward.endTimestamp <= block.timestamp;\\n  }\\n\\n  /// @notice Helper function to accumulate base rewards\\n  /// Accumulate reward per micro LINK before changing reward rate.\\n  /// This keeps rewards prior to rate change unaffected.\\n  function _accumulateBaseRewards(Reward storage reward) internal {\\n    uint256 cappedTimestamp = _getCappedTimestamp(reward);\\n\\n    reward.base.cumulativePerMicroLINK += (uint256(reward.base.rate) *\\n      (cappedTimestamp - uint256(reward.base.lastAccumulateTimestamp)))\\n      ._toUint96();\\n    reward.base.lastAccumulateTimestamp = cappedTimestamp._toUint32();\\n  }\\n\\n  /// @notice Helper function to accumulate delegation rewards\\n  /// @dev This function is necessary to correctly account for any changes in\\n  /// eligible operators, delegated amount or reward rate.\\n  function _accumulateDelegationRewards(\\n    Reward storage reward,\\n    uint256 delegatedAmount\\n  ) internal {\\n    reward.delegated.cumulativePerDelegate = _calculateAccruedDelegatedRewards(\\n      reward,\\n      delegatedAmount\\n    )._toUint96();\\n\\n    reward.delegated.lastAccumulateTimestamp = _getCappedTimestamp(reward)\\n      ._toUint32();\\n  }\\n\\n  /// @notice Helper function to calculate rewards\\n  /// @param amount a staked amount to calculate rewards for\\n  /// @param duration a duration that the specified amount receives rewards for\\n  /// @return rewardsAmount\\n  function _calculateReward(\\n    Reward storage reward,\\n    uint256 amount,\\n    uint256 duration\\n  ) internal view returns (uint256) {\\n    return (amount * uint256(reward.base.rate) * duration) / REWARD_PRECISION;\\n  }\\n\\n  /// @notice Calculates the amount of delegated rewards accumulated so far.\\n  /// @dev This function takes into account the amount of delegated\\n  /// rewards accumulated from previous delegate counts and amounts and\\n  /// the latest additional value.\\n  function _calculateAccruedDelegatedRewards(\\n    Reward storage reward,\\n    uint256 totalDelegatedAmount\\n  ) internal view returns (uint256) {\\n    uint256 elapsedDurationSinceLastAccumulate = _isDepleted(reward)\\n      ? uint256(reward.endTimestamp) -\\n        uint256(reward.delegated.lastAccumulateTimestamp)\\n      : block.timestamp - uint256(reward.delegated.lastAccumulateTimestamp);\\n\\n    return\\n      uint256(reward.delegated.cumulativePerDelegate) +\\n      _calculateReward(\\n        reward,\\n        totalDelegatedAmount,\\n        elapsedDurationSinceLastAccumulate\\n      ) /\\n      // We are doing this to keep track of delegated rewards prior to the\\n      // first operator staking.\\n      Math.max(uint256(reward.delegated.delegatesCount), 1);\\n  }\\n\\n  /// @notice Calculates the amount of rewards accrued so far.\\n  /// @dev This function takes into account the amount of\\n  /// rewards accumulated from previous rates in addition to\\n  /// the rewards that will be accumulated based off the current rate\\n  /// over a given duration.\\n  function _calculateAccruedBaseRewards(Reward storage reward, uint256 amount)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    uint256 elapsedDurationSinceLastAccumulate = _isDepleted(reward)\\n      ? (uint256(reward.endTimestamp) -\\n        uint256(reward.base.lastAccumulateTimestamp))\\n      : block.timestamp - uint256(reward.base.lastAccumulateTimestamp);\\n\\n    return\\n      (amount *\\n        (uint256(reward.base.cumulativePerMicroLINK) +\\n          uint256(reward.base.rate) *\\n          elapsedDurationSinceLastAccumulate)) / REWARD_PRECISION;\\n  }\\n\\n  /// @notice We use a simplified reward calculation formula because we know that\\n  /// the reward is expired. We accumulate reward per micro LINK\\n  /// before concluding the pool so we can avoid reading additional storage\\n  /// variables.\\n  function _calculateConcludedBaseRewards(\\n    Reward storage reward,\\n    uint256 amount,\\n    address staker\\n  ) internal view returns (uint256) {\\n    return\\n      (amount * uint256(reward.base.cumulativePerMicroLINK)) /\\n      REWARD_PRECISION -\\n      uint256(reward.missed[staker].base);\\n  }\\n\\n  /// @notice Reserves staker rewards. This is necessary to make sure that\\n  /// there are always enough available LINK tokens for all stakers until the\\n  /// reward end timestamp. The amount is calculated for the remaining reward\\n  /// duration using the current reward rate.\\n  /// @param baseRewardAmount The amount of base rewards to reserve\\n  /// or unreserve for\\n  /// @param delegatedRewardAmount The amount of delegated rewards to reserve\\n  /// or unreserve for\\n  /// @param isReserving true if function should reserve more rewards. false will\\n  /// unreserve and deduct from the reserved total\\n  function _updateReservedRewards(\\n    Reward storage reward,\\n    uint256 baseRewardAmount,\\n    uint256 delegatedRewardAmount,\\n    bool isReserving\\n  ) private {\\n    uint256 duration = _getRemainingDuration(reward);\\n    uint96 deltaBaseReward = _calculateReward(\\n      reward,\\n      baseRewardAmount,\\n      duration\\n    )._toUint96();\\n    uint96 deltaDelegatedReward = _calculateReward(\\n      reward,\\n      delegatedRewardAmount,\\n      duration\\n    )._toUint96();\\n    // add if is reserving, subtract otherwise\\n    if (isReserving) {\\n      // We round up (by adding an extra juels) if the amount includes an\\n      // increment below REWARD_PRECISION. We always need to reserve more than\\n      // the user will earn. The consequence of this is that we\u2019ll have dust\\n      // LINK amounts left over in the contract after stakers exit. The amount\\n      // will be approximately 1 juels for every call to reserve function,\\n      // which translates to <1 LINK for the duration of staking v0.1 contract.\\n      if (baseRewardAmount % REWARD_PRECISION > 0) deltaBaseReward++;\\n      if (delegatedRewardAmount % REWARD_PRECISION > 0) deltaDelegatedReward++;\\n\\n      reward.reserved.base += deltaBaseReward;\\n      reward.reserved.delegated += deltaDelegatedReward;\\n    } else {\\n      reward.reserved.base -= deltaBaseReward;\\n      reward.reserved.delegated -= deltaDelegatedReward;\\n    }\\n  }\\n\\n  /// @notice Increase reserved staker rewards.\\n  /// @param baseRewardAmount The amount of base rewards to reserve\\n  /// or unreserve for\\n  /// @param delegatedRewardAmount The amount of delegated rewards to reserve\\n  /// or unreserve for\\n  function _reserve(\\n    Reward storage reward,\\n    uint256 baseRewardAmount,\\n    uint256 delegatedRewardAmount\\n  ) internal {\\n    _updateReservedRewards(\\n      reward,\\n      baseRewardAmount,\\n      delegatedRewardAmount,\\n      true\\n    );\\n  }\\n\\n  /// @notice Decrease reserved staker rewards.\\n  /// @param baseRewardAmount The amount of base rewards to reserve\\n  /// or unreserve for\\n  /// @param delegatedRewardAmount The amount of delegated rewards to reserve\\n  /// or unreserve for\\n  function _unreserve(\\n    Reward storage reward,\\n    uint256 baseRewardAmount,\\n    uint256 delegatedRewardAmount\\n  ) internal {\\n    _updateReservedRewards(\\n      reward,\\n      baseRewardAmount,\\n      delegatedRewardAmount,\\n      false\\n    );\\n  }\\n\\n  /// @notice function does multiple things:\\n  /// - Unreserves future staking rewards to make them available for withdrawal;\\n  /// - Expires the reward to stop rewards from accumulating;\\n  function _release(\\n    Reward storage reward,\\n    uint256 amount,\\n    uint256 delegatedAmount\\n  ) internal {\\n    // Accumulate base and delegation rewards before unreserving rewards to save gas costs.\\n    // We can use the accumulated reward per micro LINK and accumulated delegation reward\\n    // to simplify reward calculations in migrate() and unstake() instead of recalculating.\\n    _accumulateDelegationRewards(reward, delegatedAmount);\\n    _accumulateBaseRewards(reward);\\n    _unreserve(reward, amount - delegatedAmount, delegatedAmount);\\n\\n    reward.endTimestamp = block.timestamp;\\n  }\\n\\n  /// @notice calculates an amount that community stakers have to delegate to operators\\n  /// @param amount base staked amount to calculate delegated amount against\\n  /// @param delegationRateDenominator Delegation rate used to calculate delegated stake amount\\n  function _getDelegatedAmount(\\n    uint256 amount,\\n    uint256 delegationRateDenominator\\n  ) internal pure returns (uint256) {\\n    return amount / delegationRateDenominator;\\n  }\\n\\n  /// @notice calculates the amount of stake that remains after accounting for delegation requirement\\n  /// @param amount base staked amount to calculate non-delegated amount against\\n  /// @param delegationRateDenominator Delegation rate used to calculate delegated stake amount\\n  function _getNonDelegatedAmount(\\n    uint256 amount,\\n    uint256 delegationRateDenominator\\n  ) internal pure returns (uint256) {\\n    return amount - _getDelegatedAmount(amount, delegationRateDenominator);\\n  }\\n\\n  /// @return uint256 the remaining reward duration (time until end), or 0 if expired/ended.\\n  function _getRemainingDuration(Reward storage reward)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return _isDepleted(reward) ? 0 : reward.endTimestamp - block.timestamp;\\n  }\\n\\n  /// @notice This function is called when the staking pool is initialized,\\n  /// pool size is changed, reward rates are changed, rewards are added, and an alert is raised\\n  /// @param maxPoolSize Current maximum staking pool size\\n  /// @param totalStakedAmount Currently staked amount across community stakers and operators\\n  /// @param newRate New reward rate if it needs to be changed\\n  /// @param minRewardDuration The minimum duration rewards need to last for\\n  /// @param availableReward available reward amount\\n  /// @param totalDelegatedAmount total delegated amount delegated by community stakers\\n  function _updateDuration(\\n    Reward storage reward,\\n    uint256 maxPoolSize,\\n    uint256 totalStakedAmount,\\n    uint256 newRate,\\n    uint256 minRewardDuration,\\n    uint256 availableReward,\\n    uint256 totalDelegatedAmount\\n  ) internal {\\n    uint256 earnedBaseRewards = _getEarnedBaseRewards(\\n      reward,\\n      totalStakedAmount,\\n      totalDelegatedAmount\\n    );\\n    uint256 earnedDelegationRewards = _getEarnedDelegationRewards(\\n      reward,\\n      totalDelegatedAmount\\n    );\\n\\n    uint256 remainingRewards = availableReward -\\n      earnedBaseRewards -\\n      earnedDelegationRewards;\\n\\n    if (newRate != uint256(reward.base.rate)) {\\n      reward.base.rate = newRate._toUint80();\\n    }\\n\\n    uint256 availableRewardDuration = (remainingRewards * REWARD_PRECISION) /\\n      (newRate * maxPoolSize);\\n\\n    // Validate that the new reward duration is at least the min reward duration.\\n    // This is a safety mechanism to guard against operational mistakes.\\n    if (availableRewardDuration < minRewardDuration)\\n      revert RewardDurationTooShort();\\n\\n    // Because we utilize unreserved rewards we need to update reserved amounts as well.\\n    // Reserved amounts are set to currently earned rewards plus new future rewards\\n    // based on the available reward duration.\\n    reward.reserved.base = (earnedBaseRewards +\\n      // Future base rewards for currently staked amounts based on the new duration\\n      _calculateReward(\\n        reward,\\n        totalStakedAmount - totalDelegatedAmount,\\n        availableRewardDuration\\n      ))._toUint96();\\n\\n    reward.reserved.delegated = (earnedDelegationRewards +\\n      // Future delegation rewards for currently staked amounts based on the new duration\\n      _calculateReward(reward, totalDelegatedAmount, availableRewardDuration))\\n      ._toUint96();\\n\\n    reward.endTimestamp = block.timestamp + availableRewardDuration;\\n  }\\n\\n  /// @return The total amount of base rewards earned by all stakers\\n  function _getEarnedBaseRewards(\\n    Reward storage reward,\\n    uint256 totalStakedAmount,\\n    uint256 totalDelegatedAmount\\n  ) internal view returns (uint256) {\\n    return\\n      reward.reserved.base -\\n      _calculateReward(\\n        reward,\\n        totalStakedAmount - totalDelegatedAmount,\\n        _getRemainingDuration(reward)\\n      );\\n  }\\n\\n  /// @return The total amount of delegated rewards earned by all node operators\\n  function _getEarnedDelegationRewards(\\n    Reward storage reward,\\n    uint256 totalDelegatedAmount\\n  ) internal view returns (uint256) {\\n    return\\n      reward.reserved.delegated -\\n      _calculateReward(\\n        reward,\\n        totalDelegatedAmount,\\n        _getRemainingDuration(reward)\\n      );\\n  }\\n\\n  /// @notice Slashes all on feed node operators.\\n  /// Node operators are slashed the minimum of either the\\n  /// amount of rewards they have earned or the amount\\n  /// of rewards earned by the minimum operator stake amount\\n  /// over the slashable duration.\\n  function _slashOnFeedOperators(\\n    Reward storage reward,\\n    uint256 minOperatorStakeAmount,\\n    uint256 slashableDuration,\\n    address[] memory feedOperators,\\n    mapping(address => StakingPoolLib.Staker) storage stakers,\\n    uint256 totalDelegatedAmount\\n  ) internal {\\n    if (reward.delegated.delegatesCount == 0) return; // Skip slashing if there are no staking operators\\n\\n    uint256 slashableBaseRewards = _getSlashableBaseRewards(\\n      reward,\\n      minOperatorStakeAmount,\\n      slashableDuration\\n    );\\n    uint256 slashableDelegatedRewards = _getSlashableDelegatedRewards(\\n      reward,\\n      slashableDuration,\\n      totalDelegatedAmount\\n    );\\n\\n    uint256 totalSlashedBaseReward;\\n    uint256 totalSlashedDelegatedReward;\\n\\n    uint256[] memory slashedBaseAmounts = new uint256[](feedOperators.length);\\n    uint256[] memory slashedDelegatedAmounts = new uint256[](\\n      feedOperators.length\\n    );\\n\\n    for (uint256 i; i < feedOperators.length; i++) {\\n      address operator = feedOperators[i];\\n      uint256 operatorStakedAmount = stakers[operator].stakedAmount;\\n      if (operatorStakedAmount == 0) continue;\\n      slashedBaseAmounts[i] = _slashOperatorBaseRewards(\\n        reward,\\n        slashableBaseRewards,\\n        operator,\\n        operatorStakedAmount\\n      );\\n      slashedDelegatedAmounts[i] = _slashOperatorDelegatedRewards(\\n        reward,\\n        slashableDelegatedRewards,\\n        operator,\\n        totalDelegatedAmount\\n      );\\n      totalSlashedBaseReward += slashedBaseAmounts[i];\\n      totalSlashedDelegatedReward += slashedDelegatedAmounts[i];\\n    }\\n    reward.reserved.base -= totalSlashedBaseReward._toUint96();\\n    reward.reserved.delegated -= totalSlashedDelegatedReward._toUint96();\\n\\n    emit RewardSlashed(\\n      feedOperators,\\n      slashedBaseAmounts,\\n      slashedDelegatedAmounts\\n    );\\n  }\\n\\n  /// @return The amount of base rewards to slash\\n  /// @notice The amount of rewards accrued over the slashable duration for a\\n  /// minimum node operator stake amount\\n  function _getSlashableBaseRewards(\\n    Reward storage reward,\\n    uint256 minOperatorStakeAmount,\\n    uint256 slashableDuration\\n  ) private view returns (uint256) {\\n    return _calculateReward(reward, minOperatorStakeAmount, slashableDuration);\\n  }\\n\\n  /// @return The amount of delegated rewards to slash\\n  /// @dev The amount of delegated rewards accrued over the slashable duration\\n  function _getSlashableDelegatedRewards(\\n    Reward storage reward,\\n    uint256 slashableDuration,\\n    uint256 totalDelegatedAmount\\n  ) private view returns (uint256) {\\n    DelegatedRewards memory delegatedRewards = reward.delegated;\\n\\n    return\\n      _calculateReward(reward, totalDelegatedAmount, slashableDuration) /\\n      // We don't validate for delegatedRewards.delegatesCount to be a\\n      // non-zero value as this is already checked in _slashOnFeedOperators.\\n      uint256(delegatedRewards.delegatesCount);\\n  }\\n\\n  /// @notice Slashes an on feed node operator the minimum of\\n  /// either the total amount of base rewards they have\\n  /// earned or the amount of rewards earned by the\\n  ///  minimum operator stake amount over the slashable duration.\\n  function _slashOperatorBaseRewards(\\n    Reward storage reward,\\n    uint256 slashableRewards,\\n    address operator,\\n    uint256 operatorStakedAmount\\n  ) private returns (uint256) {\\n    uint256 earnedRewards = _getOperatorEarnedBaseRewards(\\n      reward,\\n      operator,\\n      operatorStakedAmount\\n    );\\n    uint256 slashedRewards = Math.min(slashableRewards, earnedRewards); // max capped by earnings\\n    reward.missed[operator].base += slashedRewards._toUint96();\\n    return slashedRewards;\\n  }\\n\\n  /// @notice Slashes an on feed node operator the minimum of\\n  /// either the total amount of delegated rewards they have\\n  /// earned or the amount of delegated rewards they have\\n  /// earned over the slashable duration.\\n  function _slashOperatorDelegatedRewards(\\n    Reward storage reward,\\n    uint256 slashableRewards,\\n    address operator,\\n    uint256 totalDelegatedAmount\\n  ) private returns (uint256) {\\n    uint256 earnedRewards = _getOperatorEarnedDelegatedRewards(\\n      reward,\\n      operator,\\n      totalDelegatedAmount\\n    );\\n    uint256 slashedRewards = Math.min(slashableRewards, earnedRewards); // max capped by earnings\\n    reward.missed[operator].delegated += slashedRewards._toUint96();\\n    return slashedRewards;\\n  }\\n\\n  /// @return The amount of base rewards an operator\\n  /// has earned.\\n  function _getOperatorEarnedBaseRewards(\\n    Reward storage reward,\\n    address operator,\\n    uint256 operatorStakedAmount\\n  ) internal view returns (uint256) {\\n    return\\n      _calculateAccruedBaseRewards(reward, operatorStakedAmount) -\\n      uint256(reward.missed[operator].base);\\n  }\\n\\n  /// @return The amount of delegated rewards an operator\\n  /// has earned.\\n  function _getOperatorEarnedDelegatedRewards(\\n    Reward storage reward,\\n    address operator,\\n    uint256 totalDelegatedAmount\\n  ) internal view returns (uint256) {\\n    return\\n      _calculateAccruedDelegatedRewards(reward, totalDelegatedAmount) -\\n      uint256(reward.missed[operator].delegated);\\n  }\\n\\n  /// @return The current timestamp or, if the current timestamp has passed reward\\n  /// end timestamp, reward end timestamp.\\n  /// @dev This is necessary to ensure that rewards are calculated correctly\\n  /// after the reward is depleted.\\n  function _getCappedTimestamp(Reward storage reward)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return Math.min(uint256(reward.endTimestamp), block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/// @notice Owner functions restricted to the setup and maintenance\\n/// of the staking contract by the owner.\\ninterface IStakingOwner {\\n  /// @notice This error is thrown when an zero delegation rate is supplied\\n  error InvalidDelegationRate();\\n\\n  /// @notice This error is thrown when an invalid regular period threshold is supplied\\n  error InvalidRegularPeriodThreshold();\\n\\n  /// @notice This error is thrown when an invalid min operator stake amount is\\n  /// supplied\\n  error InvalidMinOperatorStakeAmount();\\n\\n  /// @notice This error is thrown when an invalid min community stake amount\\n  /// is supplied\\n  error InvalidMinCommunityStakeAmount();\\n\\n  /// @notice This error is thrown when an invalid max alerting reward is\\n  /// supplied\\n  error InvalidMaxAlertingRewardAmount();\\n\\n  /// @notice This error is thrown when the pool is started with an empty\\n  /// merkle root\\n  error MerkleRootNotSet();\\n\\n  /// @notice Adds one or more operators to a list of operators\\n  /// @dev Should only callable by the Owner\\n  /// @param operators A list of operator addresses to add\\n  function addOperators(address[] calldata operators) external;\\n\\n  /// @notice Removes one or more operators from a list of operators. When an\\n  /// operator is removed, we store their principal in a separate mapping to\\n  /// prevent immediate withdrawals. This is so that the removed operator can\\n  /// only unstake at the same time as every other staker.\\n  /// @dev Should only be callable by the owner when the pool is open.\\n  /// When an operator is removed they can stake as a community staker.\\n  /// We allow that because the alternative (checking for removed stake before\\n  /// staking) is going to unnecessarily increase gas costs in 99.99% of the\\n  /// cases.\\n  /// @param operators A list of operator addresses to remove\\n  function removeOperators(address[] calldata operators) external;\\n\\n  /// @notice Allows the contract owner to set the list of on-feed operator addresses who are subject to slashing\\n  /// @dev Existing feed operators are cleared before setting the new operators.\\n  /// @param operators New list of on-feed operator staker addresses\\n  function setFeedOperators(address[] calldata operators) external;\\n\\n  /// @return List of the ETH-USD feed node operators' staking addresses\\n  function getFeedOperators() external view returns (address[] memory);\\n\\n  /// @notice This function can be called to change the reward rate for the pool.\\n  /// This change only affects future rewards, i.e. rewards earned at a previous\\n  /// rate are unaffected.\\n  /// @dev Should only be callable by the owner. The rate can be increased or decreased.\\n  /// The new rate cannot be 0.\\n  /// @param rate The new reward rate\\n  function changeRewardRate(uint256 rate) external;\\n\\n  /// @notice This function can be called to add rewards to the pool\\n  /// @dev Should only be callable by the owner\\n  /// @param amount The amount of rewards to add to the pool\\n  function addReward(uint256 amount) external;\\n\\n  /// @notice This function can be called to withdraw unused reward amount from\\n  /// the staking pool. It can be called before the pool is initialized, after\\n  /// the pool is concluded or when the reward expires.\\n  /// @dev Should only be callable by the owner when the pool is closed\\n  function withdrawUnusedReward() external;\\n\\n  /// @notice Set the pool config\\n  /// @param maxPoolSize The max amount of staked LINK allowed in the pool\\n  /// @param maxCommunityStakeAmount The max amount of LINK a community staker can stake\\n  /// @param maxOperatorStakeAmount The max amount of LINK a Node Op can stake\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxCommunityStakeAmount,\\n    uint256 maxOperatorStakeAmount\\n  ) external;\\n\\n  /// @notice Transfers LINK tokens and initializes the reward\\n  /// @dev Uses ERC20 approve + transferFrom flow\\n  /// @param amount rewards amount in LINK\\n  /// @param initialRewardRate The amount of LINK earned per second for\\n  /// each LINK staked.\\n  function start(uint256 amount, uint256 initialRewardRate) external;\\n\\n  /// @notice Closes the pool, unreserving future staker rewards, expires the\\n  /// reward and releases unreserved rewards\\n  function conclude() external;\\n\\n  /// @notice This function pauses staking\\n  /// @dev Sets the pause flag to true\\n  function emergencyPause() external;\\n\\n  /// @notice This function unpauses staking\\n  /// @dev Sets the pause flag to false\\n  function emergencyUnpause() external;\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport {SafeCast} from './SafeCast.sol';\\n\\nlibrary StakingPoolLib {\\n  using SafeCast for uint256;\\n\\n  /// @notice This event is emitted when the staking pool is opened for stakers\\n  event PoolOpened();\\n  /// @notice This event is emitted when the staking pool is concluded\\n  event PoolConcluded();\\n  /// @notice This event is emitted when the staking pool's maximum size is\\n  /// increased\\n  /// @param maxPoolSize the new maximum pool size\\n  event PoolSizeIncreased(uint256 maxPoolSize);\\n  /// @notice This event is emitted when the maximum stake amount\\n  // for community stakers is increased\\n  /// @param maxStakeAmount the new maximum stake amount\\n  event MaxCommunityStakeAmountIncreased(uint256 maxStakeAmount);\\n  /// @notice This event is emitted when the maximum stake amount for node\\n  /// operators is increased\\n  /// @param maxStakeAmount the new maximum stake amount\\n  event MaxOperatorStakeAmountIncreased(uint256 maxStakeAmount);\\n  /// @notice This event is emitted when an operator is added\\n  /// @param operator address of the operator that was added to the staking pool\\n  event OperatorAdded(address operator);\\n  /// @notice This event is emitted when an operator is removed\\n  /// @param operator address of the operator that was removed from the staking pool\\n  /// @param amount principal amount that will be available for withdrawal when staking ends\\n  event OperatorRemoved(address operator, uint256 amount);\\n  /// @notice This event is emitted when the contract owner sets the list\\n  /// of feed operators subject to slashing\\n  /// @param feedOperators new list of feed operator staking addresses\\n  event FeedOperatorsSet(address[] feedOperators);\\n  /// @notice Surfaces the required pool status to perform an operation\\n  /// @param currentStatus current status of the pool (true if open / false if closed)\\n  /// @param requiredStatus required status of the pool to proceed\\n  /// (true if pool must be open / false if pool must be closed)\\n  error InvalidPoolStatus(bool currentStatus, bool requiredStatus);\\n  /// @notice This error is raised when attempting to decrease maximum pool size\\n  /// @param maxPoolSize the current maximum pool size\\n  error InvalidPoolSize(uint256 maxPoolSize);\\n  /// @notice This error is raised when attempting to decrease maximum stake amount\\n  /// for community stakers or node operators\\n  /// @param maxStakeAmount the current maximum stake amount\\n  error InvalidMaxStakeAmount(uint256 maxStakeAmount);\\n  /// @notice This error is raised when attempting to add more node operators without\\n  /// sufficient available pool space to reserve their allocations.\\n  /// @param remainingPoolSize the remaining pool space available to reserve\\n  /// @param requiredPoolSize the required reserved pool space to add new node operators\\n  error InsufficientRemainingPoolSpace(\\n    uint256 remainingPoolSize,\\n    uint256 requiredPoolSize\\n  );\\n  /// @param requiredAmount minimum required stake amount\\n  error InsufficientStakeAmount(uint256 requiredAmount);\\n  /// @notice This error is raised when stakers attempt to stake past pool limits\\n  /// @param remainingAmount maximum remaining amount that can be staked. This is\\n  /// the difference between the existing staked amount and the individual and global limits.\\n  error ExcessiveStakeAmount(uint256 remainingAmount);\\n  /// @notice This error is raised when stakers attempt to exit the pool\\n  /// @param staker address of the staker who attempted to withdraw funds\\n  error StakeNotFound(address staker);\\n  /// @notice This error is raised when addresses with existing stake is added as an operator\\n  /// @param staker address of the staker who is being added as an operator\\n  error ExistingStakeFound(address staker);\\n  /// @notice This error is raised when an address is duplicated in the supplied list of operators.\\n  /// This can happen in addOperators and setFeedOperators functions.\\n  /// @param operator address of the operator\\n  error OperatorAlreadyExists(address operator);\\n  /// @notice This error is thrown when the owner attempts to remove an on-feed operator.\\n  /// @dev The owner must remove the operator from the on-feed list first.\\n  error OperatorIsAssignedToFeed(address operator);\\n  /// @notice This error is raised when removing an operator in removeOperators\\n  /// and setFeedOperators\\n  /// @param operator address of the operator\\n  error OperatorDoesNotExist(address operator);\\n  /// @notice This error is raised when operator has been removed from the pool\\n  /// and is attempted to be readded\\n  /// @param operator address of the locked operator\\n  error OperatorIsLocked(address operator);\\n  /// @notice This error is raised when attempting to start staking with less\\n  /// than the minimum required node operators\\n  /// @param currentOperatorsCount The current number of operators in the staking pool\\n  /// @param minInitialOperatorsCount The minimum required number of operators\\n  /// in the staking pool before opening\\n  error InadequateInitialOperatorsCount(\\n    uint256 currentOperatorsCount,\\n    uint256 minInitialOperatorsCount\\n  );\\n\\n  struct PoolLimits {\\n    // The max amount of staked LINK allowed in the pool\\n    uint96 maxPoolSize;\\n    // The max amount of LINK a community staker can stake\\n    uint80 maxCommunityStakeAmount;\\n    // The max amount of LINK a Node Op can stake\\n    uint80 maxOperatorStakeAmount;\\n  }\\n\\n  struct PoolState {\\n    // Flag that signals if the staking pool is open for staking\\n    bool isOpen;\\n    // Total number of operators added to the staking pool\\n    uint8 operatorsCount;\\n    // Total amount of LINK staked by community stakers\\n    uint96 totalCommunityStakedAmount;\\n    // Total amount of LINK staked by operators\\n    uint96 totalOperatorStakedAmount;\\n  }\\n\\n  struct Staker {\\n    // Flag that signals whether a staker is an operator\\n    bool isOperator;\\n    // Flag that signals whether a staker is an on-feed operator\\n    bool isFeedOperator;\\n    // Amount of LINK staked by a staker\\n    uint96 stakedAmount;\\n    // Amount of LINK staked by a removed operator that can be withdrawn\\n    // Removed operators can only withdraw at the end of staking.\\n    // Used to know which operators have been removed.\\n    uint96 removedStakeAmount;\\n  }\\n\\n  struct Pool {\\n    mapping(address => Staker) stakers;\\n    address[] feedOperators;\\n    PoolState state;\\n    PoolLimits limits;\\n    // Sum of removed operator principals that have not been withdrawn.\\n    // Used to make sure that contract's balance is correct.\\n    // total staked amount + total removed amount + available rewards = current balance\\n    uint256 totalOperatorRemovedAmount;\\n  }\\n\\n  /// @notice Sets staking pool parameters\\n  /// @param maxPoolSize Maximum total stake amount across all stakers\\n  /// @param maxCommunityStakeAmount Maximum stake amount for a single community staker\\n  /// @param maxOperatorStakeAmount Maximum stake amount for a single node operator\\n  function _setConfig(\\n    Pool storage pool,\\n    uint256 maxPoolSize,\\n    uint256 maxCommunityStakeAmount,\\n    uint256 maxOperatorStakeAmount\\n  ) internal {\\n    if (maxOperatorStakeAmount > maxPoolSize)\\n      revert InvalidMaxStakeAmount(maxOperatorStakeAmount);\\n\\n    if (pool.limits.maxPoolSize > maxPoolSize)\\n      revert InvalidPoolSize(maxPoolSize);\\n    if (pool.limits.maxCommunityStakeAmount > maxCommunityStakeAmount)\\n      revert InvalidMaxStakeAmount(maxCommunityStakeAmount);\\n    if (pool.limits.maxOperatorStakeAmount > maxOperatorStakeAmount)\\n      revert InvalidMaxStakeAmount(maxOperatorStakeAmount);\\n\\n    PoolState memory poolState = pool.state;\\n    if (\\n      maxPoolSize <\\n      (poolState.operatorsCount * maxOperatorStakeAmount) +\\n        poolState.totalCommunityStakedAmount\\n    ) revert InvalidMaxStakeAmount(maxOperatorStakeAmount);\\n    if (pool.limits.maxPoolSize != maxPoolSize) {\\n      pool.limits.maxPoolSize = maxPoolSize._toUint96();\\n      emit PoolSizeIncreased(maxPoolSize);\\n    }\\n    if (pool.limits.maxCommunityStakeAmount != maxCommunityStakeAmount) {\\n      pool.limits.maxCommunityStakeAmount = maxCommunityStakeAmount._toUint80();\\n      emit MaxCommunityStakeAmountIncreased(maxCommunityStakeAmount);\\n    }\\n    if (pool.limits.maxOperatorStakeAmount != maxOperatorStakeAmount) {\\n      pool.limits.maxOperatorStakeAmount = maxOperatorStakeAmount._toUint80();\\n      emit MaxOperatorStakeAmountIncreased(maxOperatorStakeAmount);\\n    }\\n  }\\n\\n  /// @notice Opens the staking pool\\n  function _open(Pool storage pool, uint256 minInitialOperatorCount) internal {\\n    if (uint256(pool.state.operatorsCount) < minInitialOperatorCount)\\n      revert InadequateInitialOperatorsCount(\\n        pool.state.operatorsCount,\\n        minInitialOperatorCount\\n      );\\n    pool.state.isOpen = true;\\n    emit PoolOpened();\\n  }\\n\\n  /// @notice Closes the staking pool\\n  function _close(Pool storage pool) internal {\\n    pool.state.isOpen = false;\\n    emit PoolConcluded();\\n  }\\n\\n  /// @notice Returns true if a supplied staker address is in the operators list\\n  /// @param staker Address of a staker\\n  /// @return bool\\n  function _isOperator(Pool storage pool, address staker)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return pool.stakers[staker].isOperator;\\n  }\\n\\n  /// @notice Returns the sum of all principal staked in the pool\\n  /// @return totalStakedAmount\\n  function _getTotalStakedAmount(Pool storage pool)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    StakingPoolLib.PoolState memory poolState = pool.state;\\n    return\\n      uint256(poolState.totalCommunityStakedAmount) +\\n      uint256(poolState.totalOperatorStakedAmount);\\n  }\\n\\n  /// @notice Returns the amount of remaining space available in the pool for\\n  /// community stakers. Community stakers can only stake up to this amount\\n  /// even if they are within their individual limits.\\n  /// @return remainingPoolSpace\\n  function _getRemainingPoolSpace(Pool storage pool)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    StakingPoolLib.PoolState memory poolState = pool.state;\\n    return\\n      uint256(pool.limits.maxPoolSize) -\\n      (uint256(poolState.operatorsCount) *\\n        uint256(pool.limits.maxOperatorStakeAmount)) -\\n      uint256(poolState.totalCommunityStakedAmount);\\n  }\\n\\n  /// @dev Required conditions for adding operators:\\n  /// - Operators can only been added to the pool if they have no prior stake.\\n  /// - Operators can only been readded to the pool if they have no removed\\n  /// stake.\\n  /// - Operators cannot be added to the pool after staking ends (either through\\n  /// conclusion or through reward expiry).\\n  function _addOperators(Pool storage pool, address[] calldata operators)\\n    internal\\n  {\\n    uint256 requiredReservedPoolSpace = operators.length *\\n      uint256(pool.limits.maxOperatorStakeAmount);\\n    uint256 remainingPoolSpace = _getRemainingPoolSpace(pool);\\n    if (requiredReservedPoolSpace > remainingPoolSpace)\\n      revert InsufficientRemainingPoolSpace(\\n        remainingPoolSpace,\\n        requiredReservedPoolSpace\\n      );\\n\\n    for (uint256 i; i < operators.length; i++) {\\n      if (pool.stakers[operators[i]].isOperator)\\n        revert OperatorAlreadyExists(operators[i]);\\n      if (pool.stakers[operators[i]].stakedAmount > 0)\\n        revert ExistingStakeFound(operators[i]);\\n      // Avoid edge-cases where we attempt to add an operator that has\\n      // locked principal (this means that the operator was previously removed).\\n      if (pool.stakers[operators[i]].removedStakeAmount > 0)\\n        revert OperatorIsLocked(operators[i]);\\n      pool.stakers[operators[i]].isOperator = true;\\n      emit OperatorAdded(operators[i]);\\n    }\\n\\n    // Safely update operators count with respect to the maximum of 255 operators\\n    pool.state.operatorsCount =\\n      pool.state.operatorsCount +\\n      operators.length._toUint8();\\n  }\\n\\n  /// @notice Helper function to set the list of on-feed Operator addresses\\n  /// @param operators List of Operator addresses\\n  function _setFeedOperators(Pool storage pool, address[] calldata operators)\\n    internal\\n  {\\n    for (uint256 i; i < pool.feedOperators.length; i++) {\\n      delete pool.stakers[pool.feedOperators[i]].isFeedOperator;\\n    }\\n    delete pool.feedOperators;\\n\\n    for (uint256 i; i < operators.length; i++) {\\n      address newFeedOperator = operators[i];\\n      if (!_isOperator(pool, newFeedOperator))\\n        revert OperatorDoesNotExist(newFeedOperator);\\n      if (pool.stakers[newFeedOperator].isFeedOperator)\\n        revert OperatorAlreadyExists(newFeedOperator);\\n\\n      pool.stakers[newFeedOperator].isFeedOperator = true;\\n    }\\n    pool.feedOperators = operators;\\n\\n    emit FeedOperatorsSet(operators);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAlertsController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IAlertsController {\\n  /// @param alerter The address of an alerter\\n  /// @param roundId The feed's round ID that an alert has been raised for\\n  /// @param rewardAmount The amount of LINK rewarded to the alerter\\n  /// @notice Emitted when a valid alert is raised for a feed round\\n  event AlertRaised(address alerter, uint256 roundId, uint256 rewardAmount);\\n\\n  /// @param roundId The feed's round ID that the alerter is trying to raise an alert for\\n  /// @notice This error is thrown when an alerter tries to raise an\\n  // alert for a round that has already been alerted.\\n  error AlertAlreadyExists(uint256 roundId);\\n\\n  /// @notice This error is thrown when alerting conditions are not met and the\\n  /// alert is invalid.\\n  error AlertInvalid();\\n\\n  /// @notice This function creates an alert for a stalled feed\\n  function raiseAlert() external;\\n\\n  /// @notice This function checks to see whether the alerter may raise an alert\\n  /// to claim rewards\\n  function canAlert(address alerter) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMigratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IMigratable {\\n  /// @notice This event is emitted when a migration target is proposed by the contract owner.\\n  /// @param migrationTarget Contract address to migrate stakes to.\\n  event MigrationTargetProposed(address migrationTarget);\\n  /// @notice This event is emitted after a 7 day period has passed since a migration target is proposed, and the target is accepted.\\n  /// @param migrationTarget Contract address to migrate stakes to.\\n  event MigrationTargetAccepted(address migrationTarget);\\n  /// @notice This event is emitted when a staker migrates their stake to the migration target.\\n  /// @param staker Staker address\\n  /// @param principal Principal amount deposited\\n  /// @param baseReward Amount of base rewards withdrawn\\n  /// @param delegationReward Amount of delegation rewards withdrawn (if applicable)\\n  /// @param data Migration payload\\n  event Migrated(\\n    address staker,\\n    uint256 principal,\\n    uint256 baseReward,\\n    uint256 delegationReward,\\n    bytes data\\n  );\\n\\n  /// @notice This error is raised when the contract owner supplies a non-contract migration target.\\n  error InvalidMigrationTarget();\\n\\n  /// @notice This function returns the migration target contract address\\n  function getMigrationTarget() external view returns (address);\\n\\n  /// @notice This function allows the contract owner to set a proposed\\n  /// migration target address. If the migration target is valid it renounces\\n  /// the previously accepted migration target (if any).\\n  /// @param migrationTarget Contract address to migrate stakes to.\\n  function proposeMigrationTarget(address migrationTarget) external;\\n\\n  /// @notice This function allows the contract owner to accept a proposed migration target address after a waiting period.\\n  function acceptMigrationTarget() external;\\n\\n  /// @notice This function allows stakers to migrate funds to a new staking pool.\\n  /// @param data Migration path details\\n  function migrate(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IStaking {\\n  /// @notice This event is emitted when a staker adds stake to the pool.\\n  /// @param staker Staker address\\n  /// @param newStake New principal amount staked\\n  /// @param totalStake Total principal amount staked\\n  event Staked(address staker, uint256 newStake, uint256 totalStake);\\n  /// @notice This event is emitted when a staker exits the pool.\\n  /// @param staker Staker address\\n  /// @param principal Principal amount staked\\n  /// @param baseReward base reward earned\\n  /// @param delegationReward delegation reward earned, if any\\n  event Unstaked(\\n    address staker,\\n    uint256 principal,\\n    uint256 baseReward,\\n    uint256 delegationReward\\n  );\\n\\n  /// @notice This error is thrown whenever the sender is not the LINK token\\n  error SenderNotLinkToken();\\n\\n  /// @notice This error is thrown whenever an address does not have access\\n  /// to successfully execute a transaction\\n  error AccessForbidden();\\n\\n  /// @notice This error is thrown whenever a zero-address is supplied when\\n  /// a non-zero address is required\\n  error InvalidZeroAddress();\\n\\n  /// @notice This function allows stakers to exit the pool after it has been\\n  /// concluded. It returns the principal as well as base and delegation\\n  /// rewards.\\n  function unstake() external;\\n\\n  /// @notice This function allows removed operators to withdraw their original\\n  /// principal. Operators can only withdraw after the pool is closed, like\\n  /// every other staker.\\n  function withdrawRemovedStake() external;\\n\\n  /// @return address LINK token contract's address that is used by the pool\\n  function getChainlinkToken() external view returns (address);\\n\\n  /// @param staker address\\n  /// @return uint256 staker's staked principal amount\\n  function getStake(address staker) external view returns (uint256);\\n\\n  /// @notice Returns true if an address is an operator\\n  function isOperator(address staker) external view returns (bool);\\n\\n  /// @notice The staking pool starts closed and only allows\\n  /// stakers to stake once it's opened\\n  /// @return bool pool status\\n  function isActive() external view returns (bool);\\n\\n  /// @return uint256 current maximum staking pool size\\n  function getMaxPoolSize() external view returns (uint256);\\n\\n  /// @return uint256 minimum amount that can be staked by a community staker\\n  /// @return uint256 maximum amount that can be staked by a community staker\\n  function getCommunityStakerLimits() external view returns (uint256, uint256);\\n\\n  /// @return uint256 minimum amount that can be staked by an operator\\n  /// @return uint256 maximum amount that can be staked by an operator\\n  function getOperatorLimits() external view returns (uint256, uint256);\\n\\n  /// @return uint256 reward initialization timestamp\\n  /// @return uint256 reward expiry timestamp\\n  function getRewardTimestamps() external view returns (uint256, uint256);\\n\\n  /// @return uint256 current reward rate, expressed in juels per second per micro LINK\\n  function getRewardRate() external view returns (uint256);\\n\\n  /// @return uint256 current delegation rate\\n  function getDelegationRateDenominator() external view returns (uint256);\\n\\n  /// @return uint256 total amount of LINK tokens made available for rewards in\\n  /// Juels\\n  /// @dev This reflects how many rewards were made available over the\\n  /// lifetime of the staking pool. This is not updated when the rewards are\\n  /// unstaked or migrated by the stakers. This means that the contract balance\\n  /// will dip below available amount when the reward expires and users start\\n  /// moving their rewards.\\n  function getAvailableReward() external view returns (uint256);\\n\\n  /// @return uint256 amount of base rewards earned by a staker in Juels\\n  function getBaseReward(address) external view returns (uint256);\\n\\n  /// @return uint256 amount of delegation rewards earned by an operator in Juels\\n  function getDelegationReward(address) external view returns (uint256);\\n\\n  /// @notice Total delegated amount is calculated by dividing the total\\n  /// community staker staked amount by the delegation rate, i.e.\\n  /// totalDelegatedAmount = pool.totalCommunityStakedAmount / delegationRateDenominator\\n  /// @return uint256 staked amount that is used when calculating delegation rewards in Juels\\n  function getTotalDelegatedAmount() external view returns (uint256);\\n\\n  /// @notice Delegates count increases after an operator is added to the list\\n  /// of operators and stakes the minimum required amount.\\n  /// @return uint256 number of staking operators that are eligible for delegation rewards\\n  function getDelegatesCount() external view returns (uint256);\\n\\n  /// @return uint256 total amount of base rewards earned by all stakers in Juels\\n  function getEarnedBaseRewards() external view returns (uint256);\\n\\n  /// @return uint256 total amount of delegated rewards earned by all node operators in Juels\\n  function getEarnedDelegationRewards() external view returns (uint256);\\n\\n  /// @return uint256 total amount staked by community stakers and operators in Juels\\n  function getTotalStakedAmount() external view returns (uint256);\\n\\n  /// @return uint256 total amount staked by community stakers in Juels\\n  function getTotalCommunityStakedAmount() external view returns (uint256);\\n\\n  /// @return uint256 the sum of removed operator principals that have not been\\n  /// withdrawn from the staking pool in Juels.\\n  /// @dev Used to make sure that contract's balance is correct.\\n  /// total staked amount + total removed amount + available rewards = current balance\\n  function getTotalRemovedAmount() external view returns (uint256);\\n\\n  /// @notice This function returns the pause state\\n  /// @return bool whether or not the pool is paused\\n  function isPaused() external view returns (bool);\\n\\n  /// @return address The address of the feed being monitored to raise alerts for\\n  function getMonitoredFeed() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IMerkleAccessController {\\n  /// @notice Emitted when the contract owner updates the staking allowlist\\n  /// @param newMerkleRoot The root of a new Staking allowlist merkle tree\\n  event MerkleRootChanged(bytes32 newMerkleRoot);\\n\\n  /// @notice Validates if a community staker has access to the private staking pool\\n  /// @param staker The community staker's address\\n  /// @param proof Merkle proof for the community staker's allowlist\\n  function hasAccess(address staker, bytes32[] calldata proof)\\n    external\\n    view\\n    returns (bool);\\n\\n  /// @notice This function is called to update the staking allowlist in a private staking pool\\n  /// @dev Only callable by the contract owner\\n  /// @param newMerkleRoot Merkle Tree root, used to prove access for community stakers\\n  /// will be required at start but can be removed at any time by the owner when\\n  /// staking access will be granted to the public.\\n  function setMerkleRoot(bytes32 newMerkleRoot) external;\\n\\n  /// @return The current root of the Staking allowlist merkle tree\\n  function getMerkleRoot() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nlibrary SafeCast {\\n  error CastError();\\n\\n  /// @notice This is used to safely case timestamps to uint8\\n  uint256 private constant MAX_UINT_8 = type(uint8).max;\\n  /// @notice This is used to safely case timestamps to uint32\\n  uint256 private constant MAX_UINT_32 = type(uint32).max;\\n  /// @notice This is used to safely case timestamps to uint80\\n  uint256 private constant MAX_UINT_80 = type(uint80).max;\\n  /// @notice This is used to safely case timestamps to uint96\\n  uint256 private constant MAX_UINT_96 = type(uint96).max;\\n\\n  function _toUint8(uint256 value) internal pure returns (uint8) {\\n    if (value > MAX_UINT_8) revert CastError();\\n    return uint8(value);\\n  }\\n\\n  function _toUint32(uint256 value) internal pure returns (uint32) {\\n    if (value > MAX_UINT_32) revert CastError();\\n    return uint32(value);\\n  }\\n\\n  function _toUint80(uint256 value) internal pure returns (uint80) {\\n    if (value > MAX_UINT_80) revert CastError();\\n    return uint80(value);\\n  }\\n\\n  function _toUint96(uint256 value) internal pure returns (uint96) {\\n    if (value > MAX_UINT_96) revert CastError();\\n    return uint96(value);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 75000\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"LINKAddress\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"monitoredFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxCommunityStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialMaxOperatorStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCommunityStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOperatorStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priorityPeriodThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"regularPeriodThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAlertingRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minInitialOperatorCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRewardDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashableDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delegationRateDenominator\",\"type\":\"uint256\"}],\"internalType\":\"struct Staking.PoolConstructorParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessForbidden\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"AlertAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlertInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CastError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"}],\"name\":\"ExcessiveStakeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"ExistingStakeFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentOperatorsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minInitialOperatorsCount\",\"type\":\"uint256\"}],\"name\":\"InadequateInitialOperatorsCount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredPoolSize\",\"type\":\"uint256\"}],\"name\":\"InsufficientRemainingPoolSpace\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requiredAmount\",\"type\":\"uint256\"}],\"name\":\"InsufficientStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegationRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxAlertingRewardAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidMaxStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMigrationTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinCommunityStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinOperatorStakeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"}],\"name\":\"InvalidPoolSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"currentStatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"requiredStatus\",\"type\":\"bool\"}],\"name\":\"InvalidPoolStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRegularPeriodThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MerkleRootNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorIsAssignedToFeed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorIsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardDurationTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotLinkToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"StakeNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"AlertRaised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegationReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"migrationTarget\",\"type\":\"address\"}],\"name\":\"MigrationTargetAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"migrationTarget\",\"type\":\"address\"}],\"name\":\"MigrationTargetProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delegationReward\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptMigrationTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"addOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"canAlert\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"changeRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getBaseReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCommunityStakerLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelegatesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelegationRateDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getDelegationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarnedBaseRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarnedDelegationRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeedOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPoolSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigrationTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMonitoredFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalCommunityStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDelegatedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRemovedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migrationTarget\",\"type\":\"address\"}],\"name\":\"proposeMigrationTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raiseAlert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"removeOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setFeedOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCommunityStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxOperatorStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setPoolConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialRewardRate\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRemovedStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUnusedReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "75000", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b841900000000000000000000000000000000000000000014adf4b7320334b900000000000000000000000000000000000000000000000000017b7883c06916600000000000000000000000000000000000000000000000000a968163f0a57b4000000000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000000000000000000000000000000000000002ee000000000000000000000000000000000000000000000017b7883c0691660000000000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}