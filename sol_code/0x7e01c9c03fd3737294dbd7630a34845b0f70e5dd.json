{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"IStaking.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588     \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n//               \u2590\u2588\u2588\u2588\u2588\u258c    \u2590\u2588\u2588\u2588\u2588\u258c\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Interface of Threshold Network staking contract\\n/// @notice The staking contract enables T owners to have their wallets offline\\n///         and their stake managed by providers on their behalf. All off-chain\\n///         client software should be able to run without exposing provider\u2019s\\n///         private key and should not require any owner\u2019s keys at all.\\n///         The stake delegation optimizes the network throughput without\\n///         compromising the security of the owners\u2019 stake.\\ninterface IStaking {\\n    enum StakeType {\\n        NU,\\n        KEEP,\\n        T\\n    }\\n\\n    //\\n    //\\n    // Delegating a stake\\n    //\\n    //\\n\\n    /// @notice Creates a delegation with `msg.sender` owner with the given\\n    ///         provider, beneficiary, and authorizer. Transfers the given\\n    ///         amount of T to the staking contract.\\n    /// @dev The owner of the delegation needs to have the amount approved to\\n    ///      transfer to the staking contract.\\n    function stake(\\n        address stakingProvider,\\n        address payable beneficiary,\\n        address authorizer,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Copies delegation from the legacy KEEP staking contract to T\\n    ///         staking contract. No tokens are transferred. Caches the active\\n    ///         stake amount from KEEP staking contract. Can be called by\\n    ///         anyone.\\n    function stakeKeep(address stakingProvider) external;\\n\\n    /// @notice Copies delegation from the legacy NU staking contract to T\\n    ///         staking contract, additionally appointing beneficiary and\\n    ///         authorizer roles. Caches the amount staked in NU staking\\n    ///         contract. Can be called only by the original delegation owner.\\n    function stakeNu(\\n        address stakingProvider,\\n        address payable beneficiary,\\n        address authorizer\\n    ) external;\\n\\n    /// @notice Refresh Keep stake owner. Can be called only by the old owner.\\n    function refreshKeepStakeOwner(address stakingProvider) external;\\n\\n    /// @notice Allows the Governance to set the minimum required stake amount.\\n    ///         This amount is required to protect against griefing the staking\\n    ///         contract and individual applications are allowed to require\\n    ///         higher minimum stakes if necessary.\\n    function setMinimumStakeAmount(uint96 amount) external;\\n\\n    //\\n    //\\n    // Authorizing an application\\n    //\\n    //\\n\\n    /// @notice Allows the Governance to approve the particular application\\n    ///         before individual stake authorizers are able to authorize it.\\n    function approveApplication(address application) external;\\n\\n    /// @notice Increases the authorization of the given provider for the given\\n    ///         application by the given amount. Can only be called by the given\\n    ///         provider\u2019s authorizer.\\n    /// @dev Calls `authorizationIncreased(address stakingProvider, uint256 amount)`\\n    ///      on the given application to notify the application about\\n    ///      authorization change. See `IApplication`.\\n    function increaseAuthorization(\\n        address stakingProvider,\\n        address application,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Requests decrease of the authorization for the given provider on\\n    ///         the given application by the provided amount.\\n    ///         It may not change the authorized amount immediatelly. When\\n    ///         it happens depends on the application. Can only be called by the\\n    ///         given provider\u2019s authorizer. Overwrites pending authorization\\n    ///         decrease for the given provider and application.\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\n    ///      on the given application. See `IApplication`.\\n    function requestAuthorizationDecrease(\\n        address stakingProvider,\\n        address application,\\n        uint96 amount\\n    ) external;\\n\\n    /// @notice Requests decrease of all authorizations for the given provider on\\n    ///         the applications by all authorized amount.\\n    ///         It may not change the authorized amount immediatelly. When\\n    ///         it happens depends on the application. Can only be called by the\\n    ///         given provider\u2019s authorizer. Overwrites pending authorization\\n    ///         decrease for the given provider and application.\\n    /// @dev Calls `authorizationDecreaseRequested(address stakingProvider, uint256 amount)`\\n    ///      for each authorized application. See `IApplication`.\\n    function requestAuthorizationDecrease(address stakingProvider) external;\\n\\n    /// @notice Called by the application at its discretion to approve the\\n    ///         previously requested authorization decrease request. Can only be\\n    ///         called by the application that was previously requested to\\n    ///         decrease the authorization for that provider.\\n    ///         Returns resulting authorized amount for the application.\\n    function approveAuthorizationDecrease(address stakingProvider)\\n        external\\n        returns (uint96);\\n\\n    /// @notice Decreases the authorization for the given `stakingProvider` on\\n    ///         the given disabled `application`, for all authorized amount.\\n    ///         Can be called by anyone.\\n    function forceDecreaseAuthorization(\\n        address stakingProvider,\\n        address application\\n    ) external;\\n\\n    /// @notice Pauses the given application\u2019s eligibility to slash stakes.\\n    ///         Besides that stakers can\\u0027t change authorization to the application.\\n    ///         Can be called only by the Panic Button of the particular\\n    ///         application. The paused application can not slash stakes until\\n    ///         it is approved again by the Governance using `approveApplication`\\n    ///         function. Should be used only in case of an emergency.\\n    function pauseApplication(address application) external;\\n\\n    /// @notice Disables the given application. The disabled application can\\u0027t\\n    ///         slash stakers. Also stakers can\\u0027t increase authorization to that\\n    ///         application but can decrease without waiting by calling\\n    ///         `requestAuthorizationDecrease` at any moment. Can be called only\\n    ///         by the governance. The disabled application can\\u0027t be approved\\n    ///         again. Should be used only in case of an emergency.\\n    function disableApplication(address application) external;\\n\\n    /// @notice Sets the Panic Button role for the given application to the\\n    ///         provided address. Can only be called by the Governance. If the\\n    ///         Panic Button for the given application should be disabled, the\\n    ///         role address should be set to 0x0 address.\\n    function setPanicButton(address application, address panicButton) external;\\n\\n    /// @notice Sets the maximum number of applications one provider can\\n    ///         authorize. Used to protect against DoSing slashing queue.\\n    ///         Can only be called by the Governance.\\n    function setAuthorizationCeiling(uint256 ceiling) external;\\n\\n    //\\n    //\\n    // Stake top-up\\n    //\\n    //\\n\\n    /// @notice Increases the amount of the stake for the given provider.\\n    ///         Can be called only by the owner or provider.\\n    /// @dev The sender of this transaction needs to have the amount approved to\\n    ///      transfer to the staking contract.\\n    function topUp(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Propagates information about stake top-up from the legacy KEEP\\n    ///         staking contract to T staking contract. Can be called only by\\n    ///         the owner or provider.\\n    function topUpKeep(address stakingProvider) external;\\n\\n    /// @notice Propagates information about stake top-up from the legacy NU\\n    ///         staking contract to T staking contract. Can be called only by\\n    ///         the owner or provider.\\n    function topUpNu(address stakingProvider) external;\\n\\n    //\\n    //\\n    // Undelegating a stake (unstaking)\\n    //\\n    //\\n\\n    /// @notice Reduces the liquid T stake amount by the provided amount and\\n    ///         withdraws T to the owner. Reverts if there is at least one\\n    ///         authorization higher than the sum of the legacy stake and\\n    ///         remaining liquid T stake or if the unstake amount is higher than\\n    ///         the liquid T stake amount. Can be called only by the owner or\\n    ///         provider.\\n    function unstakeT(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Sets the legacy KEEP staking contract active stake amount cached\\n    ///         in T staking contract to 0. Reverts if the amount of liquid T\\n    ///         staked in T staking contract is lower than the highest\\n    ///         application authorization. This function allows to unstake from\\n    ///         KEEP staking contract and still being able to operate in T\\n    ///         network and earning rewards based on the liquid T staked. Can be\\n    ///         called only by the delegation owner and provider.\\n    function unstakeKeep(address stakingProvider) external;\\n\\n    /// @notice Reduces cached legacy NU stake amount by the provided amount.\\n    ///         Reverts if there is at least one authorization higher than the\\n    ///         sum of remaining legacy NU stake and liquid T stake for that\\n    ///         provider or if the untaked amount is higher than the cached\\n    ///         legacy stake amount. If succeeded, the legacy NU stake can be\\n    ///         partially or fully undelegated on the legacy staking contract.\\n    ///         This function allows to unstake from NU staking contract and\\n    ///         still being able to operate in T network and earning rewards\\n    ///         based on the liquid T staked. Can be called only by the\\n    ///         delegation owner and provider.\\n    function unstakeNu(address stakingProvider, uint96 amount) external;\\n\\n    /// @notice Sets cached legacy stake amount to 0, sets the liquid T stake\\n    ///         amount to 0 and withdraws all liquid T from the stake to the\\n    ///         owner. Reverts if there is at least one non-zero authorization.\\n    ///         Can be called only by the delegation owner and provider.\\n    function unstakeAll(address stakingProvider) external;\\n\\n    //\\n    //\\n    // Keeping information in sync\\n    //\\n    //\\n\\n    /// @notice Notifies about the discrepancy between legacy KEEP active stake\\n    ///         and the amount cached in T staking contract. Slashes the provider\\n    ///         in case the amount cached is higher than the actual active stake\\n    ///         amount in KEEP staking contract. Needs to update authorizations\\n    ///         of all affected applications and execute an involuntary\\n    ///         allocation decrease on all affected applications. Can be called\\n    ///         by anyone, notifier receives a reward.\\n    function notifyKeepStakeDiscrepancy(address stakingProvider) external;\\n\\n    /// @notice Notifies about the discrepancy between legacy NU active stake\\n    ///         and the amount cached in T staking contract. Slashes the\\n    ///         provider in case the amount cached is higher than the actual\\n    ///         active stake amount in NU staking contract. Needs to update\\n    ///         authorizations of all affected applications and execute an\\n    ///         involuntary allocation decrease on all affected applications.\\n    ///         Can be called by anyone, notifier receives a reward.\\n    function notifyNuStakeDiscrepancy(address stakingProvider) external;\\n\\n    /// @notice Sets the penalty amount for stake discrepancy and reward\\n    ///         multiplier for reporting it. The penalty is seized from the\\n    ///         provider account, and 5% of the penalty, scaled by the\\n    ///         multiplier, is given to the notifier. The rest of the tokens are\\n    ///         burned. Can only be called by the Governance. See `seize` function.\\n    function setStakeDiscrepancyPenalty(\\n        uint96 penalty,\\n        uint256 rewardMultiplier\\n    ) external;\\n\\n    /// @notice Sets reward in T tokens for notification of misbehaviour\\n    ///         of one provider. Can only be called by the governance.\\n    function setNotificationReward(uint96 reward) external;\\n\\n    /// @notice Transfer some amount of T tokens as reward for notifications\\n    ///         of misbehaviour\\n    function pushNotificationReward(uint96 reward) external;\\n\\n    /// @notice Withdraw some amount of T tokens from notifiers treasury.\\n    ///         Can only be called by the governance.\\n    function withdrawNotificationReward(address recipient, uint96 amount)\\n        external;\\n\\n    /// @notice Adds providers to the slashing queue along with the amount that\\n    ///         should be slashed from each one of them. Can only be called by\\n    ///         application authorized for all providers in the array.\\n    function slash(uint96 amount, address[] memory stakingProviders) external;\\n\\n    /// @notice Adds providers to the slashing queue along with the amount.\\n    ///         The notifier will receive reward per each provider from\\n    ///         notifiers treasury. Can only be called by application\\n    ///         authorized for all providers in the array.\\n    function seize(\\n        uint96 amount,\\n        uint256 rewardMultipier,\\n        address notifier,\\n        address[] memory stakingProviders\\n    ) external;\\n\\n    /// @notice Takes the given number of queued slashing operations and\\n    ///         processes them. Receives 5% of the slashed amount.\\n    ///         Executes `involuntaryAllocationDecrease` function on each\\n    ///         affected application.\\n    function processSlashing(uint256 count) external;\\n\\n    //\\n    //\\n    // Auxiliary functions\\n    //\\n    //\\n\\n    /// @notice Returns the authorized stake amount of the provider for the\\n    ///         application.\\n    function authorizedStake(address stakingProvider, address application)\\n        external\\n        view\\n        returns (uint96);\\n\\n    /// @notice Returns staked amount of T, Keep and Nu for the specified\\n    ///         staking provider.\\n    /// @dev    All values are in T denomination\\n    function stakes(address stakingProvider)\\n        external\\n        view\\n        returns (\\n            uint96 tStake,\\n            uint96 keepInTStake,\\n            uint96 nuInTStake\\n        );\\n\\n    /// @notice Returns start staking timestamp for T/NU stake.\\n    /// @dev    This value is set at most once, and only when a stake is created\\n    ///         with T or NU tokens. If a stake is created from a legacy KEEP\\n    ///         stake, this value will remain as zero\\n    function getStartStakingTimestamp(address stakingProvider)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns staked amount of NU for the specified provider\\n    function stakedNu(address stakingProvider) external view returns (uint256);\\n\\n    /// @notice Gets the stake owner, the beneficiary and the authorizer\\n    ///         for the specified provider address.\\n    /// @return owner Stake owner address.\\n    /// @return beneficiary Beneficiary address.\\n    /// @return authorizer Authorizer address.\\n    function rolesOf(address stakingProvider)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            address payable beneficiary,\\n            address authorizer\\n        );\\n\\n    /// @notice Returns length of application array\\n    function getApplicationsLength() external view returns (uint256);\\n\\n    /// @notice Returns length of slashing queue\\n    function getSlashingQueueLength() external view returns (uint256);\\n\\n    /// @notice Returns minimum possible stake for T, KEEP or NU in T denomination\\n    /// @dev For example, suppose the given provider has 10 T, 20 T worth\\n    ///      of KEEP, and 30 T worth of NU all staked, and the maximum\\n    ///      application authorization is 40 T, then `getMinStaked` for\\n    ///      that provider returns:\\n    ///          * 0 T if KEEP stake type specified i.e.\\n    ///            min = 40 T max - (10 T + 30 T worth of NU) = 0 T\\n    ///          * 10 T if NU stake type specified i.e.\\n    ///            min = 40 T max - (10 T + 20 T worth of KEEP) = 10 T\\n    ///          * 0 T if T stake type specified i.e.\\n    ///            min = 40 T max - (20 T worth of KEEP + 30 T worth of NU) \\u003c 0 T\\n    ///      In other words, the minimum stake amount for the specified\\n    ///      stake type is the minimum amount of stake of the given type\\n    ///      needed to satisfy the maximum application authorization given\\n    ///      the staked amounts of the other stake types for that provider.\\n    function getMinStaked(address stakingProvider, StakeType stakeTypes)\\n        external\\n        view\\n        returns (uint96);\\n\\n    /// @notice Returns available amount to authorize for the specified application\\n    function getAvailableToAuthorize(\\n        address stakingProvider,\\n        address application\\n    ) external view returns (uint96);\\n}\\n\"},\"SimplePREApplication.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"IStaking.sol\\\";\\n\\n\\n/**\\n* @title PRE Application\\n* @notice Contract handles PRE configuration\\n*/\\ncontract SimplePREApplication {\\n\\n    /**\\n    * @notice Signals that an operator was bonded to the staking provider\\n    * @param stakingProvider Staking provider address\\n    * @param operator Operator address\\n    * @param startTimestamp Timestamp bonding occurred\\n    */\\n    event OperatorBonded(address indexed stakingProvider, address indexed operator, uint256 startTimestamp);\\n\\n    /**\\n    * @notice Signals that an operator address is confirmed\\n    * @param stakingProvider Staking provider address\\n    * @param operator Operator address\\n    */\\n    event OperatorConfirmed(address indexed stakingProvider, address indexed operator);\\n\\n    struct StakingProviderInfo {\\n        address operator;\\n        bool operatorConfirmed;\\n        uint256 operatorStartTimestamp;\\n    }\\n\\n    uint256 public immutable minAuthorization;\\n    uint256 public immutable minOperatorSeconds;\\n\\n    IStaking public immutable tStaking;\\n\\n    mapping (address =\\u003e StakingProviderInfo) public stakingProviderInfo;\\n    address[] public stakingProviders;\\n    mapping(address =\\u003e address) internal _stakingProviderFromOperator;\\n\\n\\n    /**\\n    * @notice Constructor sets address of token contract and parameters for staking\\n    * @param _tStaking T token staking contract\\n    * @param _minAuthorization Amount of minimum allowable authorization\\n    * @param _minOperatorSeconds Min amount of seconds while an operator can\\u0027t be changed\\n    */\\n    constructor(\\n        IStaking _tStaking,\\n        uint256 _minAuthorization,\\n        uint256 _minOperatorSeconds\\n    ) {\\n        require(\\n            _tStaking.authorizedStake(address(this), address(this)) == 0,\\n            \\\"Wrong input parameters\\\"\\n        );\\n        minAuthorization = _minAuthorization;\\n        tStaking = _tStaking;\\n        minOperatorSeconds = _minOperatorSeconds;\\n    }\\n\\n    /**\\n    * @dev Checks caller is a staking provider or stake owner\\n    */\\n    modifier onlyOwnerOrStakingProvider(address _stakingProvider)\\n    {\\n        require(isAuthorized(_stakingProvider), \\\"Not owner or provider\\\");\\n        if (_stakingProvider != msg.sender) {\\n            (address owner,,) = tStaking.rolesOf(_stakingProvider);\\n            require(owner == msg.sender, \\\"Not owner or provider\\\");\\n        }\\n        _;\\n    }\\n\\n\\n    //-------------------------Main-------------------------\\n    /**\\n    * @notice Returns staking provider for specified operator\\n    */\\n    function stakingProviderFromOperator(address _operator) public view returns (address) {\\n        return _stakingProviderFromOperator[_operator];\\n    }\\n\\n    /**\\n    * @notice Returns operator for specified staking provider\\n    */\\n    function getOperatorFromStakingProvider(address _stakingProvider) public view returns (address) {\\n        return stakingProviderInfo[_stakingProvider].operator;\\n    }\\n\\n    /**\\n    * @notice Get all tokens delegated to the staking provider\\n    */\\n    function authorizedStake(address _stakingProvider) public view returns (uint96) {\\n        (uint96 tStake, uint96 keepInTStake, uint96 nuInTStake) = tStaking.stakes(_stakingProvider);\\n        return tStake + keepInTStake + nuInTStake;\\n    }\\n\\n    /**\\n    * @notice Get the value of authorized tokens for active providers as well as providers and their authorized tokens\\n    * @param _startIndex Start index for looking in providers array\\n    * @param _maxStakingProviders Max providers for looking, if set 0 then all will be used\\n    * @return allAuthorizedTokens Sum of authorized tokens for active providers\\n    * @return activeStakingProviders Array of providers and their authorized tokens.\\n    * Providers addresses stored as uint256\\n    * @dev Note that activeStakingProviders[0] is an array of uint256, but you want addresses.\\n    * Careful when used directly!\\n    */\\n    function getActiveStakingProviders(uint256 _startIndex, uint256 _maxStakingProviders)\\n        external view returns (uint256 allAuthorizedTokens, uint256[2][] memory activeStakingProviders)\\n    {\\n        uint256 endIndex = stakingProviders.length;\\n        require(_startIndex \\u003c endIndex, \\\"Wrong start index\\\");\\n        if (_maxStakingProviders != 0 \\u0026\\u0026 _startIndex + _maxStakingProviders \\u003c endIndex) {\\n            endIndex = _startIndex + _maxStakingProviders;\\n        }\\n        activeStakingProviders = new uint256[2][](endIndex - _startIndex);\\n        allAuthorizedTokens = 0;\\n\\n        uint256 resultIndex = 0;\\n        for (uint256 i = _startIndex; i \\u003c endIndex; i++) {\\n            address stakingProvider = stakingProviders[i];\\n            StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n            uint256 eligibleAmount = authorizedStake(stakingProvider);\\n            if (eligibleAmount \\u003c minAuthorization || !info.operatorConfirmed) {\\n                continue;\\n            }\\n            activeStakingProviders[resultIndex][0] = uint256(uint160(stakingProvider));\\n            activeStakingProviders[resultIndex++][1] = eligibleAmount;\\n            allAuthorizedTokens += eligibleAmount;\\n        }\\n        assembly {\\n            mstore(activeStakingProviders, resultIndex)\\n        }\\n    }\\n\\n    /**\\n    * @notice Returns beneficiary related to the staking provider\\n    */\\n    function getBeneficiary(address _stakingProvider) public view returns (address payable beneficiary) {\\n        (, beneficiary,) = tStaking.rolesOf(_stakingProvider);\\n    }\\n\\n    /**\\n    * @notice Returns true if staking provider has authorized stake to this application\\n    */\\n    function isAuthorized(address _stakingProvider) public view returns (bool) {\\n        return authorizedStake(_stakingProvider) \\u003e= minAuthorization;\\n    }\\n\\n    /**\\n    * @notice Returns true if operator has confirmed address\\n    */\\n    // TODO maybe _stakingProvider instead of _operator as input?\\n    function isOperatorConfirmed(address _operator) public view returns (bool) {\\n        address stakingProvider = _stakingProviderFromOperator[_operator];\\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n        return info.operatorConfirmed;\\n    }\\n\\n    /**\\n    * @notice Return the length of the array of staking providers\\n    */\\n    function getStakingProvidersLength() external view returns (uint256) {\\n        return stakingProviders.length;\\n    }\\n\\n    /**\\n    * @notice Bond operator\\n    * @param _stakingProvider Staking provider address\\n    * @param _operator Operator address. Must be a real address, not a contract\\n    */\\n    function bondOperator(address _stakingProvider, address _operator)\\n        external onlyOwnerOrStakingProvider(_stakingProvider)\\n    {\\n        StakingProviderInfo storage info = stakingProviderInfo[_stakingProvider];\\n        require(_operator != info.operator, \\\"Specified operator is already bonded with this provider\\\");\\n        // If this staker had an operator ...\\n        if (info.operator != address(0)) {\\n            require(\\n                block.timestamp \\u003e= info.operatorStartTimestamp + minOperatorSeconds,\\n                \\\"Not enough time passed to change operator\\\"\\n            );\\n            // Remove the old relation \\\"operator-\\u003estakingProvider\\\"\\n            _stakingProviderFromOperator[info.operator] = address(0);\\n        }\\n\\n        if (_operator != address(0)) {\\n            require(_stakingProviderFromOperator[_operator] == address(0), \\\"Specified operator is already in use\\\");\\n            require(\\n                _operator == _stakingProvider || getBeneficiary(_operator) == address(0),\\n                \\\"Specified operator is a provider\\\"\\n            );\\n            // Set new operator-\\u003estakingProvider relation\\n            _stakingProviderFromOperator[_operator] = _stakingProvider;\\n        }\\n\\n        if (info.operatorStartTimestamp == 0) {\\n            stakingProviders.push(_stakingProvider);\\n        }\\n\\n        // Bond new operator (or unbond if _operator == address(0))\\n        info.operator = _operator;\\n        info.operatorStartTimestamp = block.timestamp;\\n        info.operatorConfirmed = false;\\n        emit OperatorBonded(_stakingProvider, _operator, block.timestamp);\\n    }\\n\\n    /**\\n    * @notice Make a confirmation by operator\\n    */\\n    function confirmOperatorAddress() external {\\n        address stakingProvider = _stakingProviderFromOperator[msg.sender];\\n        require(isAuthorized(stakingProvider), \\\"No stake associated with the operator\\\");\\n        StakingProviderInfo storage info = stakingProviderInfo[stakingProvider];\\n        require(!info.operatorConfirmed, \\\"Operator address is already confirmed\\\");\\n        require(msg.sender == tx.origin, \\\"Only operator with real address can make a confirmation\\\");\\n        info.operatorConfirmed = true;\\n        emit OperatorConfirmed(stakingProvider, msg.sender);\\n    }\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"_tStaking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minAuthorization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOperatorSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"}],\"name\":\"OperatorBonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorConfirmed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"}],\"name\":\"authorizedStake\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"bondOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOperatorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakingProviders\",\"type\":\"uint256\"}],\"name\":\"getActiveStakingProviders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allAuthorizedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"activeStakingProviders\",\"type\":\"uint256[2][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"}],\"name\":\"getOperatorFromStakingProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingProvidersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingProvider\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isOperatorConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAuthorization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOperatorSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"stakingProviderFromOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingProviderInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"operatorConfirmed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"operatorStartTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tStaking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SimplePREApplication", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000001b67b1194c75264d06f808a921228a95c765dd7000000000000000000000000000000000000000000000878678326eac90000000000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cf3907256bc7442320d23aeeb9efa79bf3b43e1337e35041f54971381ca37e58"}]}