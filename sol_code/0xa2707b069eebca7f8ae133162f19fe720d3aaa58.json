{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: SafeBoxInterface.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\nabstract contract SafeBoxInterface {\r\n    function VERSION() public pure virtual returns (uint8);\r\n\r\n    function typeOfContract() public pure virtual returns (bytes32);\r\n\r\n    function singleTransfer(\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        address _to\r\n    ) external virtual;\r\n}\r\n\r\n// File: VaultCoreInterface.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\nabstract contract VaultCoreInterface {\r\n    function VERSION() public pure virtual returns (uint8);\r\n\r\n    function typeOfContract() public pure virtual returns (bytes32);\r\n\r\n    function approveToken(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n        virtual;\r\n}\r\n\r\n// File: RoyaltyRegistryInterface.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * Interface to the RoyaltyRegistry responsible for looking payout addresses\r\n */\r\nabstract contract RoyaltyRegistryInterface {\r\n    function getAddress(address custodial)\r\n        external\r\n        view\r\n        virtual\r\n        returns (address);\r\n\r\n    function getMediaCustomPercentage(uint256 mediaId, address tokenAddress)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint16);\r\n\r\n    function getExternalTokenPercentage(uint256 tokenId, address tokenAddress)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint16, uint16);\r\n\r\n    function typeOfContract() public pure virtual returns (string calldata);\r\n\r\n    function VERSION() public pure virtual returns (uint8);\r\n}\r\n\r\n// File: PaymentsBufferInterface.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * Interface to move funds to PaymentsBuffer for owner to claim it later.\r\n */\r\nabstract contract PaymentsBufferInterface {\r\n    function typeOfContract() public pure virtual returns (bytes32);\r\n\r\n    function add(address _to) external payable virtual;\r\n\r\n    function withdraw() external payable virtual;\r\n}\r\n\r\n// File: DigitalMediaBurnInterfaceV3.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * Interface to the DigitalMediaCore responsible for burning tokens\r\n */\r\nabstract contract DigitalMediaBurnInterfaceV3 {\r\n    struct PayoutInfo {\r\n        address user;\r\n        uint256 amount;\r\n    }\r\n\r\n    function burn(uint256 _tokenId) external virtual;\r\n\r\n    function burnDigitalMedia(uint256 _digitalMedia) external virtual;\r\n\r\n    function getDigitalMediaForSale(uint256 _digitalMediaId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (\r\n            address,\r\n            bool,\r\n            uint16\r\n        );\r\n\r\n    function getDigitalMediaRelease(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint32, uint256);\r\n\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\r\n        external\r\n        view\r\n        virtual\r\n        returns (PayoutInfo[] memory);\r\n\r\n    function saleInfo(uint256 _tokenId, uint256 _salePrice)\r\n        external\r\n        view\r\n        virtual\r\n        returns (PayoutInfo[] memory);\r\n}\r\n\r\n// File: DigitalMediaBurnInterfaceV2.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * Interface to the DigitalMediaCore responsible for burning tokens\r\n */\r\nabstract contract DigitalMediaBurnInterfaceV2 {\r\n    function burn(uint256 _tokenId) external virtual;\r\n\r\n    function burnToken(uint256 _tokenId) external virtual;\r\n\r\n    function burnDigitalMedia(uint256 _digitalMedia) external virtual;\r\n\r\n    function getDigitalMedia(uint256 _digitalMediaId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256,\r\n            uint32,\r\n            uint32,\r\n            uint256,\r\n            address,\r\n            string calldata\r\n        );\r\n\r\n    function getDigitalMediaRelease(uint256 _tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256,\r\n            uint32,\r\n            uint256\r\n        );\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: WithdrawFundsControl.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\ncontract WithdrawFundsControl is Ownable, Pausable {\r\n    // List of approved on withdraw addresses\r\n    mapping(address => uint256) public approvedWithdrawAddresses;\r\n    bool public isInitialWithdrawAddressAdded = false;\r\n\r\n    // Full week wait period before an approved withdraw address becomes active\r\n    uint256 public constant withdrawApprovalWaitPeriod = 1 days;\r\n\r\n    event WithdrawAddressAdded(address withdrawAddress);\r\n    event WithdrawAddressRemoved(address widthdrawAddress);\r\n\r\n    /**\r\n     * Add a new approved on behalf of user address.\r\n     */\r\n    function addApprovedWithdrawAddress(address _withdrawAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        approvedWithdrawAddresses[_withdrawAddress] = block.timestamp;\r\n        emit WithdrawAddressAdded(_withdrawAddress);\r\n    }\r\n\r\n    /*\r\n     * Add new withdrawAddress for immediate use. This is an internal only Fn that is called\r\n     * only when the contract is deployed.\r\n     */\r\n    function addApprovedWithdrawAddressImmediately(address _withdrawAddress)\r\n        internal\r\n        onlyOwner\r\n    {\r\n        if (_withdrawAddress != address(0)) {\r\n            // set the date to one in past so that address is active immediately.\r\n            approvedWithdrawAddresses[_withdrawAddress] =\r\n                block.timestamp -\r\n                withdrawApprovalWaitPeriod -\r\n                1;\r\n            emit WithdrawAddressAdded(_withdrawAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an approved on bhealf of user address.\r\n     */\r\n    function removeApprovedWithdrawAddress(address _withdrawAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        delete approvedWithdrawAddresses[_withdrawAddress];\r\n        emit WithdrawAddressRemoved(_withdrawAddress);\r\n    }\r\n\r\n    function addApprovedWithdrawAddressAfterDeploy(address _withdrawAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            isInitialWithdrawAddressAdded == false,\r\n            \"Initial withdraw address already added\"\r\n        );\r\n        addApprovedWithdrawAddressImmediately(_withdrawAddress);\r\n        isInitialWithdrawAddressAdded = true;\r\n    }\r\n\r\n    /**\r\n     * Checks that a given withdraw address ia approved and is past it's required\r\n     * wait time.\r\n     */\r\n    function isApprovedWithdrawAddress(address _withdrawAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 approvalTime = approvedWithdrawAddresses[_withdrawAddress];\r\n        require(approvalTime > 0, \"withdraw address is not registered\");\r\n        return block.timestamp - approvalTime > withdrawApprovalWaitPeriod;\r\n    }\r\n}\r\n\r\n// File: OBOControl.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\ncontract OBOControl is Ownable {\r\n    address public oboAdmin;\r\n    uint256 public constant newAddressWaitPeriod = 1 days;\r\n    bool public canAddOBOImmediately = true;\r\n\r\n    // List of approved on behalf of users.\r\n    mapping(address => uint256) public approvedOBOs;\r\n\r\n    event NewOBOAddressEvent(address OBOAddress, bool action);\r\n\r\n    event NewOBOAdminAddressEvent(address oboAdminAddress);\r\n\r\n    modifier onlyOBOAdmin() {\r\n        require(\r\n            owner() == _msgSender() || oboAdmin == _msgSender(),\r\n            \"not oboAdmin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setOBOAdmin(address _oboAdmin) external onlyOwner {\r\n        oboAdmin = _oboAdmin;\r\n        emit NewOBOAdminAddressEvent(_oboAdmin);\r\n    }\r\n\r\n    /**\r\n     * Add a new approvedOBO address. The address can be used after wait period.\r\n     */\r\n    function addApprovedOBO(address _oboAddress) external onlyOBOAdmin {\r\n        require(_oboAddress != address(0), \"cant set to 0x\");\r\n        require(approvedOBOs[_oboAddress] == 0, \"already added\");\r\n        approvedOBOs[_oboAddress] = block.timestamp;\r\n        emit NewOBOAddressEvent(_oboAddress, true);\r\n    }\r\n\r\n    /**\r\n     * Removes an approvedOBO immediately.\r\n     */\r\n    function removeApprovedOBO(address _oboAddress) external onlyOBOAdmin {\r\n        delete approvedOBOs[_oboAddress];\r\n        emit NewOBOAddressEvent(_oboAddress, false);\r\n    }\r\n\r\n    /*\r\n     * Add OBOAddress for immediate use. This is an internal only Fn that is called\r\n     * only when the contract is deployed.\r\n     */\r\n    function addApprovedOBOImmediately(address _oboAddress) internal {\r\n        require(_oboAddress != address(0), \"addr(0)\");\r\n        // set the date to one in past so that address is active immediately.\r\n        approvedOBOs[_oboAddress] = block.timestamp - newAddressWaitPeriod - 1;\r\n        emit NewOBOAddressEvent(_oboAddress, true);\r\n    }\r\n\r\n    function addApprovedOBOAfterDeploy(address _oboAddress)\r\n        external\r\n        onlyOBOAdmin\r\n    {\r\n        require(canAddOBOImmediately == true, \"disabled\");\r\n        addApprovedOBOImmediately(_oboAddress);\r\n    }\r\n\r\n    function blockImmediateOBO() external onlyOBOAdmin {\r\n        canAddOBOImmediately = false;\r\n    }\r\n\r\n    /*\r\n     * Helper function to verify is a given address is a valid approvedOBO address.\r\n     */\r\n    function isValidApprovedOBO(address _oboAddress)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 createdAt = approvedOBOs[_oboAddress];\r\n        if (createdAt == 0) {\r\n            return false;\r\n        }\r\n        return block.timestamp - createdAt > newAddressWaitPeriod;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make the obo calls only callable by approved addressess\r\n     */\r\n    modifier isApprovedOBO() {\r\n        require(isValidApprovedOBO(msg.sender), \"unauthorized OBO user\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: DigitalMediaSaleBase.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DigitalMediaSaleBase is OBOControl, Pausable {\r\n    uint16 public royaltyPercentage = 1000;\r\n    // reserving 0 with BadContract so that we can verify membership of a mapping.\r\n    enum ContractType {\r\n        BadContract,\r\n        MakersPlaceV2,\r\n        MakersPlaceV3\r\n    }\r\n    // Mapping of token contract address to bool indicated approval.\r\n    mapping(address => ContractType) public approvedTokenContracts;\r\n    error InvalidTokenAddress(address tokenAddress);\r\n\r\n    /**\r\n     * Adds a new token contract address to be approved to be called.\r\n     */\r\n    function addApprovedTokenContract(\r\n        address _tokenContractAddress,\r\n        ContractType _contractType\r\n    ) external onlyOwner {\r\n        approvedTokenContracts[_tokenContractAddress] = _contractType;\r\n    }\r\n\r\n    /**\r\n     * Remove an approved token contract address from the list of approved addresses.\r\n     */\r\n    function removeApprovedTokenContract(address _tokenContractAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        delete approvedTokenContracts[_tokenContractAddress];\r\n    }\r\n\r\n    /**\r\n     * Checks that a particular token contract address is a valid MP token contract.\r\n     */\r\n    function _isValidTokenContract(address _tokenContractAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            approvedTokenContracts[_tokenContractAddress] !=\r\n            ContractType.BadContract;\r\n    }\r\n\r\n    /**\r\n     * Returns an ERC721 instance of a token contract address.  Throws otherwise.\r\n     * Only valid and approved token contracts are allowed to be interacted with.\r\n     */\r\n    function _getTokenContract(address _tokenContractAddress)\r\n        internal\r\n        pure\r\n        returns (IERC721)\r\n    {\r\n        // require(_isValidTokenContract(_tokenContractAddress), \"Invalid tcontract\");\r\n        return IERC721(_tokenContractAddress);\r\n    }\r\n\r\n    /**\r\n     * Checks with the ERC-721 token contract the owner of the a token\r\n     */\r\n    function _ownerOf(uint256 _tokenId, address _tokenContractAddress)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        IERC721 tokenContract = _getTokenContract(_tokenContractAddress);\r\n        return tokenContract.ownerOf(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * Checks to ensure that the token owner has approved the escrow contract,\r\n     * or escrowAddress owns the token.\r\n     */\r\n    function _approvedForEscrow(\r\n        address _seller,\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        address _escrowAddress\r\n    ) internal view returns (bool) {\r\n        IERC721 tokenContract = _getTokenContract(_tokenContractAddress);\r\n        // seller is the owner of the token, so checking that first\r\n        return (_seller == _escrowAddress ||\r\n            tokenContract.isApprovedForAll(_seller, _escrowAddress) ||\r\n            tokenContract.getApproved(_tokenId) == _escrowAddress);\r\n    }\r\n\r\n    /**\r\n     * Transfer an ERC-721 token from seller to the buyer.  This is to be called after a purchase is\r\n     * completed.\r\n     */\r\n    function _transferFromTo(\r\n        address _seller,\r\n        address _receiver,\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress\r\n    ) internal {\r\n        IERC721 tokenContract = _getTokenContract(_tokenContractAddress);\r\n        tokenContract.safeTransferFrom(_seller, _receiver, _tokenId);\r\n    }\r\n\r\n    function getDigitalMedia(uint256 _digitalMediaId, address _tokenAddress)\r\n        internal\r\n        view\r\n        returns (\r\n            address creator,\r\n            bool collaborated,\r\n            uint16 royalty\r\n        )\r\n    {\r\n        ContractType cType = approvedTokenContracts[_tokenAddress];\r\n        if (cType == ContractType.MakersPlaceV2) {\r\n            DigitalMediaBurnInterfaceV2 tokenContract = DigitalMediaBurnInterfaceV2(\r\n                    _tokenAddress\r\n                );\r\n            (, , , , creator, ) = tokenContract.getDigitalMedia(\r\n                _digitalMediaId\r\n            );\r\n            collaborated = false;\r\n            royalty = royaltyPercentage;\r\n        } else if (cType == ContractType.MakersPlaceV3) {\r\n            DigitalMediaBurnInterfaceV3 tokenContract = DigitalMediaBurnInterfaceV3(\r\n                    _tokenAddress\r\n                );\r\n            (creator, collaborated, royalty) = tokenContract\r\n                .getDigitalMediaForSale(_digitalMediaId);\r\n        } else {\r\n            revert InvalidTokenAddress({tokenAddress: _tokenAddress});\r\n        }\r\n    }\r\n\r\n    function getReleaseMedia(uint256 _tokenId, address _tokenAddress)\r\n        internal\r\n        view\r\n        returns (uint256 mediaId)\r\n    {\r\n        ContractType cType = approvedTokenContracts[_tokenAddress];\r\n        if (cType == ContractType.MakersPlaceV2) {\r\n            DigitalMediaBurnInterfaceV2 tokenContract = DigitalMediaBurnInterfaceV2(\r\n                    _tokenAddress\r\n                );\r\n            (, , mediaId) = tokenContract.getDigitalMediaRelease(_tokenId);\r\n        } else if (cType == ContractType.MakersPlaceV3) {\r\n            DigitalMediaBurnInterfaceV3 tokenContract = DigitalMediaBurnInterfaceV3(\r\n                    _tokenAddress\r\n                );\r\n            (, mediaId) = tokenContract.getDigitalMediaRelease(_tokenId);\r\n        } else {\r\n            revert InvalidTokenAddress({tokenAddress: _tokenAddress});\r\n        }\r\n    }\r\n}\r\n\r\n// File: CommissionControl.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\ncontract CommissionControl is OBOControl, Pausable {\r\n    enum CommissionType {\r\n        InvalidType,\r\n        saleType,\r\n        reSaleType,\r\n        externalType\r\n    }\r\n    event CommissionPercentageChanged(\r\n        CommissionType commissionType,\r\n        uint16 percentage,\r\n        bool committed\r\n    );\r\n\r\n    // 3 days wait period before new percentage is in effect\r\n    uint256 public constant commissionAddressWaitPeriod = 3 days;\r\n\r\n    struct CommissionStruct {\r\n        uint16 percentage;\r\n        uint16 intermediatePercentage;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    CommissionStruct public saleCommission = CommissionStruct(1500, 0, 0);\r\n    CommissionStruct public reSaleCommission = CommissionStruct(250, 0, 0);\r\n    CommissionStruct public externalSaleCommission = CommissionStruct(0, 0, 0);\r\n    uint256 internal constant HUNDREDPERCENT = 10000;\r\n\r\n    function _getCommisssionStruct(CommissionType _cType)\r\n        internal\r\n        view\r\n        returns (CommissionStruct storage)\r\n    {\r\n        CommissionStruct storage x;\r\n        if (_cType == CommissionType.saleType) {\r\n            x = saleCommission;\r\n        } else if (_cType == CommissionType.reSaleType) {\r\n            x = reSaleCommission;\r\n        } else {\r\n            x = externalSaleCommission;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    /*\r\n     * Change commission percentage for contract. Usually in the range of 80-90%.\r\n     * This change is stored in mapping untill committed. You can only commit\r\n     * after the wait period.\r\n     */\r\n    function changeCommissionPercentage(\r\n        uint16 _percentage,\r\n        CommissionType _cType\r\n    ) external whenNotPaused onlyOwner {\r\n        require(\r\n            _percentage > 0 && _percentage <= HUNDREDPERCENT,\r\n            \"Invalid percentage\"\r\n        );\r\n        CommissionStruct storage commission = _getCommisssionStruct(_cType);\r\n        require(\r\n            commission.intermediatePercentage == 0,\r\n            \"commissionChange exists\"\r\n        );\r\n        commission.intermediatePercentage = _percentage;\r\n        commission.createdAt = block.timestamp;\r\n        emit CommissionPercentageChanged({\r\n            commissionType: _cType,\r\n            percentage: _percentage,\r\n            committed: false\r\n        });\r\n    }\r\n\r\n    function deleteCommissionChange(CommissionType _cType)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        CommissionStruct storage commission = _getCommisssionStruct(_cType);\r\n        commission.intermediatePercentage = 0;\r\n        commission.createdAt = 0;\r\n    }\r\n\r\n    /*\r\n     * Commit a commission percentage change that has already been submitted for change.\r\n     */\r\n    function commitCommissionChange(CommissionType _cType)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        CommissionStruct storage commission = _getCommisssionStruct(_cType);\r\n        require(\r\n            commission.intermediatePercentage > 0,\r\n            \"commissionChange exists\"\r\n        );\r\n        require(\r\n            block.timestamp - commission.createdAt >\r\n                commissionAddressWaitPeriod,\r\n            \"under wait period\"\r\n        );\r\n        commission.percentage = commission.intermediatePercentage;\r\n        commission.intermediatePercentage = 0;\r\n        commission.createdAt = 0;\r\n        emit CommissionPercentageChanged({\r\n            commissionType: _cType,\r\n            percentage: commission.percentage,\r\n            committed: true\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Calculates payout for a given sale / bid price by doing the percentage math.\r\n     */\r\n    function _computePayoutForPrice(\r\n        uint256 salePrice,\r\n        uint256 thisCommissionPercentage\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            (salePrice * ((HUNDREDPERCENT - thisCommissionPercentage))) /\r\n            (HUNDREDPERCENT);\r\n    }\r\n}\r\n\r\n// File: DigitalMediaFixedSale.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DigitalMediaFixedSale is\r\n    DigitalMediaSaleBase,\r\n    CommissionControl,\r\n    WithdrawFundsControl\r\n{\r\n    // constants (no storage used)\r\n    uint256 internal constant changeContractWaitPeriod = 2 days;\r\n\r\n    // storage\r\n    bool public canRoyaltyRegistryChange = true;\r\n\r\n    address internal newSafeBoxAddress;\r\n    uint256 internal newSafeBoxCreatedAt;\r\n    address internal newVaultAddress;\r\n    uint256 internal newVaultCreatedAt;\r\n\r\n    // Keep track of all the bids so that we dont withdraw current bids from this contract.\r\n    // When a bid is accepted we can subtract the bid value from this totalBidAmount.\r\n    // Initializaing variable to zero costs extra gas. by default its zero.\r\n    uint256 public totalBidAmount;\r\n\r\n    /** EVENTS **/\r\n    event SaleCreatedEvent(\r\n        uint256 tokenId,\r\n        address tokenContractAddress,\r\n        bool acceptFiat,\r\n        uint256 priceInWei\r\n    );\r\n\r\n    event SaleSuccessfulEvent(\r\n        uint256 tokenId,\r\n        address tokenContractAddress,\r\n        address buyer,\r\n        address payoutAddress,\r\n        uint256 payoutAmount,\r\n        uint256 priceInWei\r\n    );\r\n\r\n    event OBOSaleEvent(\r\n        uint256 tokenId,\r\n        address tokenContractAddress,\r\n        address buyer,\r\n        uint256 priceInWei\r\n    );\r\n\r\n    event SaleCanceledEvent(uint256 tokenId, address tokenContractAddress);\r\n\r\n    event NewSafeBoxRegistered(address newSafeBoxAddress);\r\n    event NewVaultRegistered(address newVaultAddress);\r\n    event NewVaultInEffect(address newVaultAddress);\r\n    event NewSafeBoxInEffect(address newSafeBoxAddress);\r\n\r\n    struct DigitalMediaSale {\r\n        bool acceptFiat;\r\n        address seller;\r\n        uint256 priceInWei;\r\n        // if commissionPercentage is set its a non-custodial sale.\r\n        // createSaleOBO will set commissionPercentage to zero.\r\n        uint256 commissionPercentage;\r\n    }\r\n\r\n    // Mapping of token contract address to ID to Digital Media Sale object.\r\n    mapping(address => mapping(uint256 => DigitalMediaSale)) public tokenToSale;\r\n    PaymentsBufferInterface public paymentInterface;\r\n    RoyaltyRegistryInterface public royaltyStore;\r\n    SafeBoxInterface public safebox;\r\n    VaultCoreInterface public vaultInterface;\r\n\r\n    constructor(\r\n        address _royaltyRegistryAddress,\r\n        address _safebox,\r\n        address _vaultAddress\r\n    ) {\r\n        setRoyaltyRegistryStore(_royaltyRegistryAddress);\r\n        safebox = _validateSafeBoxAddress(_safebox);\r\n        vaultInterface = _validateVaultAddress(_vaultAddress);\r\n    }\r\n\r\n    function _validateVaultAddress(address _vaultAddress)\r\n        internal\r\n        pure\r\n        returns (VaultCoreInterface)\r\n    {\r\n        require(_vaultAddress != address(0), \"vault can't be 0x\");\r\n        bytes32 vault_type = 0x6d707661756c7400000000000000000000000000000000000000000000000000;\r\n\r\n        VaultCoreInterface vault = VaultCoreInterface(_vaultAddress);\r\n        require(vault.typeOfContract() == vault_type, \"not vault\");\r\n        return vault;\r\n    }\r\n\r\n    function _validateSafeBoxAddress(address _safebox)\r\n        internal\r\n        pure\r\n        returns (SafeBoxInterface)\r\n    {\r\n        // bytes32 safebox_type = bytes32(bytes(\"safebox\"));\r\n        bytes32 safebox_type = 0x73616665426f7800000000000000000000000000000000000000000000000000;\r\n\r\n        SafeBoxInterface sb = SafeBoxInterface(_safebox);\r\n        require(sb.typeOfContract() == safebox_type, \"not safebox\");\r\n        return sb;\r\n    }\r\n\r\n    /*\r\n     * Need to register the new vault address first. Then call setVaultAddress after\r\n     * wait period to set it for good.\r\n     */\r\n    function registerNewVaultAddress(address _vaultAddress) external onlyOwner {\r\n        _validateVaultAddress(_vaultAddress);\r\n        newVaultAddress = _vaultAddress;\r\n        newVaultCreatedAt = block.timestamp;\r\n        emit NewVaultRegistered(_vaultAddress);\r\n    }\r\n\r\n    /*\r\n     * Need to register the new safebox address first. Then call setSafeboxddress after\r\n     * wait period to set it for good.\r\n     */\r\n    function registerNewSafeBoxAddress(address _safebox)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        newSafeBoxAddress = address(_validateSafeBoxAddress(_safebox));\r\n        newSafeBoxCreatedAt = block.timestamp;\r\n        emit NewSafeBoxRegistered(_safebox);\r\n    }\r\n\r\n    /* set the vault for this sale contract. All custodial token owners grant approveAll\r\n     * permission to the vault. The sale contract get approve permission for each token\r\n     * from the vault and transfers it to the final destination in case of sale / bid accept.\r\n     */\r\n    function setVaultAddress(address _vaultAddress) external onlyOwner {\r\n        VaultCoreInterface vault = _validateVaultAddress(_vaultAddress);\r\n        // If we are changing vault address make sure it passes the conditions\r\n        if (address(vaultInterface) != address(0)) {\r\n            // store vault address\r\n            require(_vaultAddress == newVaultAddress, \"_vault != newVault\");\r\n            require(\r\n                block.timestamp - newVaultCreatedAt > changeContractWaitPeriod,\r\n                \"wait\"\r\n            );\r\n        }\r\n        vaultInterface = vault;\r\n        emit NewVaultInEffect(_vaultAddress);\r\n    }\r\n\r\n    function setSafeboxAddress(address _safebox)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        require(_safebox == newSafeBoxAddress, \"_safebox != newSafebox\");\r\n        require(\r\n            block.timestamp - newSafeBoxCreatedAt > changeContractWaitPeriod,\r\n            \"wait\"\r\n        );\r\n        safebox = _validateSafeBoxAddress(_safebox);\r\n        emit NewSafeBoxInEffect(_safebox);\r\n    }\r\n\r\n    function setRoyaltyPercentage(uint16 _newPercentage)\r\n        external\r\n        whenNotPaused\r\n        onlyOwner\r\n    {\r\n        // Royalty can be 30% max\r\n        require(\r\n            _newPercentage >= 0 && _newPercentage <= 3000,\r\n            \"Invalid Royalty\"\r\n        );\r\n        royaltyPercentage = _newPercentage;\r\n    }\r\n\r\n    function setRoyaltyRegistryStore(address _royaltyStore)\r\n        public\r\n        whenNotPaused\r\n        onlyOBOAdmin\r\n    {\r\n        require(canRoyaltyRegistryChange == true, \"no\");\r\n        RoyaltyRegistryInterface candidateRoyaltyStore = RoyaltyRegistryInterface(\r\n                _royaltyStore\r\n            );\r\n        require(candidateRoyaltyStore.VERSION() == 1, \"roylty v!= 1\");\r\n        bytes32 contractType = keccak256(\r\n            abi.encodePacked(candidateRoyaltyStore.typeOfContract())\r\n        );\r\n        // keccak256(abi.encodePacked(\"royaltyRegistry\")) = 0xb590ff355bf2d720a7e957392d3b76fd1adda1832940640bf5d5a7c387fed323\r\n        require(\r\n            contractType ==\r\n                0xb590ff355bf2d720a7e957392d3b76fd1adda1832940640bf5d5a7c387fed323,\r\n            \"not royalty\"\r\n        );\r\n        royaltyStore = candidateRoyaltyStore;\r\n    }\r\n\r\n    function setRoyaltyRegistryForever() external whenNotPaused onlyOwner {\r\n        canRoyaltyRegistryChange = false;\r\n    }\r\n\r\n    /**\r\n     * Removes the sale object and emits SaleCanceledEvent.\r\n     */\r\n    function _cancelSale(uint256 _tokenId, address _tokenContractAddress)\r\n        internal\r\n    {\r\n        _removeSale(_tokenId, _tokenContractAddress);\r\n        emit SaleCanceledEvent(_tokenId, _tokenContractAddress);\r\n    }\r\n\r\n    /**\r\n     * Removes a token from storage.\r\n     */\r\n    function _removeSale(uint256 _tokenId, address _tokenContractAddress)\r\n        internal\r\n    {\r\n        delete tokenToSale[_tokenContractAddress][_tokenId];\r\n    }\r\n\r\n    /**\r\n     * Returns true whether a particular DigitalMediaSale instance is on sale.\r\n     */\r\n    function _isOnSale(DigitalMediaSale storage _sale)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (_sale.priceInWei > 0);\r\n    }\r\n\r\n    /**\r\n     * Cancel sale if sale exists for a token. Safe to call even if sale does not exist.\r\n     */\r\n    function _cancelSaleIfSaleExists(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress\r\n    ) internal {\r\n        DigitalMediaSale storage sale = tokenToSale[_tokenContractAddress][\r\n            _tokenId\r\n        ];\r\n        if (_isOnSale(sale)) {\r\n            _cancelSale(_tokenId, _tokenContractAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the purchase logic of a token.  Checks that only tokens on sale are actually\r\n     * purchaseable, ensures that right amount of ether is sent and also sends back any\r\n     * excess payment to the buyer.\r\n     *\r\n     * This function only handles the purchase capability not the actual transfer\r\n     * of the token itself or emitting event related to purchase.\r\n     *\r\n     * The proceeds remains on the smart contract until ready for withdrawl from the CFO account.\r\n     */\r\n    function _purchase(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        DigitalMediaSale storage sale,\r\n        uint256 _paymentAmount\r\n    ) internal returns (uint256) {\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = sale.priceInWei;\r\n        require(_paymentAmount >= price, \"< price\");\r\n        // Remove the token from being on sale before transferring funds to avoid replay\r\n        _removeSale(_tokenId, _tokenContractAddress);\r\n        uint256 excessPayment = _paymentAmount - price;\r\n\r\n        if (excessPayment > 0) {\r\n            payable(msg.sender).call{value: excessPayment, gas: 5000};\r\n        }\r\n        return price;\r\n    }\r\n\r\n    /* Set PaymentsBuffer interface */\r\n    function registerPaymentsBufferAddress(address _bufferAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(address(paymentInterface) == address(0), \"already set\");\r\n        PaymentsBufferInterface paymentsBuffer = PaymentsBufferInterface(\r\n            _bufferAddress\r\n        );\r\n        require(\r\n            paymentsBuffer.typeOfContract() ==\r\n                0x6d707061796d656e747362756666657200000000000000000000000000000000,\r\n            \"not buffer\"\r\n        );\r\n        paymentInterface = paymentsBuffer;\r\n    }\r\n\r\n    /*\r\n     * Transfer money to an address. If the transfer fails move the funds to\r\n     * PaymentsBuffer contract where the owner of the funds can come and claim it.\r\n     */\r\n    function transferFunds(address _toAddress, uint256 amount) internal {\r\n        (bool sent, ) = _toAddress.call{value: amount, gas: 5000}(\"\");\r\n        if (!sent) {\r\n            require(\r\n                address(paymentInterface) != address(0),\r\n                \"paymentInterface should be set\"\r\n            );\r\n            paymentInterface.add{value: amount}(_toAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Withdraws all the funds to a specified non-zero address.\r\n     */\r\n    function withdrawFunds(address payable _withdrawAddress)\r\n        external\r\n        isApprovedOBO\r\n    {\r\n        require(\r\n            isApprovedWithdrawAddress(_withdrawAddress),\r\n            \"unapproved withdrawAddress\"\r\n        );\r\n        uint256 contractBalance = address(this).balance;\r\n        // We can withdraw all successful sale related funds but not pending bids\r\n        uint256 deductibleBalance = contractBalance - totalBidAmount;\r\n        _withdrawAddress.transfer(deductibleBalance);\r\n    }\r\n\r\n    /**\r\n     * Validate tokenId, tokenAddress and escrow permission for msg.sender\r\n     */\r\n    function validateTokenForEscrow(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress\r\n    ) internal view returns (address) {\r\n        address seller = _ownerOf(_tokenId, _tokenContractAddress);\r\n        require(msg.sender == seller, \"msg.sender != seller\");\r\n        require(\r\n            _approvedForEscrow(\r\n                msg.sender,\r\n                _tokenId,\r\n                _tokenContractAddress,\r\n                address(this)\r\n            ),\r\n            \"approve/All missing\"\r\n        );\r\n        return seller;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: DigitalMediaSaleCore.sol\r\n\r\n\r\n\r\npragma solidity 0.8.16;\r\n\r\n\r\n\r\n\r\ncontract DigitalMediaSaleCore is DigitalMediaFixedSale, ReentrancyGuard {\r\n    using Counters for Counters.Counter;\r\n\r\n    // consts\r\n    uint8 public constant VERSION = 3;\r\n    bytes32 private constant safeboxType =\r\n        0x73616665426f7800000000000000000000000000000000000000000000000000;\r\n\r\n    // storage slots\r\n    Counters.Counter private _bidCounter;\r\n    // tokenIdToBidId[tokenAddress[token_id]] = 2;\r\n    mapping(address => mapping(uint256 => uint256)) tokenIdToBidId;\r\n    mapping(uint256 => TokenBid) bidIdToTokenBid;\r\n\r\n    struct SaleRequest {\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n        bool acceptFiat;\r\n        address tokenAddress;\r\n    }\r\n\r\n    event TokenBidCreatedEvent(\r\n        uint256 tokenId,\r\n        address tokenAddress,\r\n        uint256 bidId,\r\n        uint256 bidPrice,\r\n        address bidder\r\n    );\r\n\r\n    event TokenBidRemovedEvent(\r\n        uint256 tokenId,\r\n        address tokenAddress,\r\n        uint256 bidId,\r\n        bool isBidder\r\n    );\r\n\r\n    event TokenBidAccepted(\r\n        uint256 tokenId,\r\n        address tokenAddress,\r\n        uint256 bidId,\r\n        uint256 bidPrice,\r\n        address bidder,\r\n        address payoutAddress,\r\n        address seller,\r\n        uint256 payoutAmount\r\n    );\r\n\r\n    struct TokenBid {\r\n        address bidder;\r\n        uint256 price;\r\n    }\r\n\r\n    struct OBOAcceptBidStruct {\r\n        address tokenAddress;\r\n        uint256 tokenId;\r\n        uint256 bidId;\r\n        bool useSafebox;\r\n    }\r\n\r\n    constructor(\r\n        address _royaltyRegistryAddress,\r\n        address _safebox,\r\n        address _vault\r\n    ) DigitalMediaFixedSale(_royaltyRegistryAddress, _safebox, _vault) {}\r\n\r\n    /*\r\n     * Compute commission percentage for a given token. Checks if token creator is seller\r\n     * to determine if its a sale or a resale.\r\n     */\r\n    function getCommissionPercentageForToken(\r\n        address _seller,\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress\r\n    ) internal view returns (uint256) {\r\n        // if the tokenContractAddress is of external type return external sale commission\r\n        if (_isValidTokenContract(_tokenContractAddress) == false) {\r\n            (uint16 customCommission, uint16 customRoyalty) = royaltyStore\r\n                .getExternalTokenPercentage(_tokenId, _tokenContractAddress);\r\n            return\r\n                customCommission + customRoyalty > 0\r\n                    ? customCommission + customRoyalty\r\n                    : externalSaleCommission.percentage;\r\n        }\r\n        uint256 digitalMediaId = getReleaseMedia(\r\n            _tokenId,\r\n            _tokenContractAddress\r\n        );\r\n        (address creator, bool collaborated, uint16 royalty) = getDigitalMedia(\r\n            digitalMediaId,\r\n            _tokenContractAddress\r\n        );\r\n        uint256 commissionPercentage;\r\n        if (creator == _seller) {\r\n            // if this media is a collaborated piece dont do payout on chain\r\n            if (collaborated == true) {\r\n                commissionPercentage = 0;\r\n            } else {\r\n                uint16 customPercentage = royaltyStore.getMediaCustomPercentage(\r\n                    digitalMediaId,\r\n                    _tokenContractAddress\r\n                );\r\n                commissionPercentage = customPercentage > 0\r\n                    ? customPercentage\r\n                    : saleCommission.percentage;\r\n            }\r\n        } else {\r\n            // for secondary sales charge commission + royalty\r\n            commissionPercentage = reSaleCommission.percentage + royalty;\r\n        }\r\n        return commissionPercentage;\r\n    }\r\n\r\n    /**\r\n     * Creates a sale.  This end point is used by non-custodial accounts. We create\r\n     * a record of sale. The token will stay with the owner but this contract has\r\n     * approve / approveAll to move the token during purchase.\r\n     */\r\n    function createSale(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        uint256 _priceInWei,\r\n        bool _acceptFiat\r\n    ) external whenNotPaused {\r\n        address seller = validateTokenForEscrow(\r\n            _tokenId,\r\n            _tokenContractAddress\r\n        );\r\n        require(_priceInWei > 0, \"price > 0\");\r\n        // We charge commission for this sale since the token owner / approve\r\n        uint256 commissionPercentage = getCommissionPercentageForToken(\r\n            seller,\r\n            _tokenId,\r\n            _tokenContractAddress\r\n        );\r\n        // is calling this function.\r\n        DigitalMediaSale memory sale = DigitalMediaSale(\r\n            _acceptFiat,\r\n            seller,\r\n            _priceInWei,\r\n            commissionPercentage\r\n        );\r\n        tokenToSale[_tokenContractAddress][_tokenId] = sale;\r\n        emit SaleCreatedEvent(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            _acceptFiat,\r\n            _priceInWei\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Onchain purchase an NFT.\r\n     * Non custodial seller only. Custodial seller is done in DepositFund flow\r\n     */\r\n    function purchase(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        nonReentrant\r\n    {\r\n        require(msg.value > 0, \"msg.value\");\r\n        DigitalMediaSale storage sale = tokenToSale[_tokenContractAddress][\r\n            _tokenId\r\n        ];\r\n        require(_isOnSale(sale), \"no sale\");\r\n        address seller = sale.seller;\r\n        uint256 price = sale.priceInWei;\r\n        uint256 thisCommissionPercentage = sale.commissionPercentage;\r\n        address tokenOwner = _ownerOf(_tokenId, _tokenContractAddress);\r\n        require(seller == tokenOwner, \"seller != tokOwner\");\r\n        require(\r\n            _approvedForEscrow(\r\n                seller,\r\n                _tokenId,\r\n                _tokenContractAddress,\r\n                address(this)\r\n            ),\r\n            \"salecontract not approved\"\r\n        );\r\n        _purchase(_tokenId, _tokenContractAddress, sale, msg.value);\r\n        _transferFromTo(seller, msg.sender, _tokenId, _tokenContractAddress);\r\n        uint256 payoutAmount = 0;\r\n        // if token belongs to MP and has commissionPercentage compute payout\r\n        if (_isValidTokenContract(_tokenContractAddress) == true) {\r\n            if (thisCommissionPercentage > 0) {\r\n                payoutAmount = _computePayoutForPrice(\r\n                    price,\r\n                    thisCommissionPercentage\r\n                );\r\n            }\r\n        } else {\r\n            payoutAmount = _computePayoutForPrice(\r\n                price,\r\n                thisCommissionPercentage\r\n            );\r\n        }\r\n        if (payoutAmount > 0) {\r\n            transferFunds(seller, payoutAmount);\r\n        }\r\n        emit SaleSuccessfulEvent(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            msg.sender,\r\n            seller,\r\n            payoutAmount,\r\n            price\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Custodial purchase. NFT moves to safebox\r\n     * While in safebox, it will be locked up in a wait period\r\n     */\r\n    function purchaseOBO(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n        whenNotPaused\r\n        isApprovedOBO\r\n        nonReentrant\r\n    {\r\n        address seller = _ownerOf(_tokenId, _tokenContractAddress);\r\n        DigitalMediaSale storage sale = tokenToSale[_tokenContractAddress][\r\n            _tokenId\r\n        ];\r\n        require(\r\n            _isOnSale(sale) && seller == sale.seller && sale.acceptFiat == true,\r\n            \"sale not valid\"\r\n        );\r\n        require(\r\n            _approvedForEscrow(\r\n                seller,\r\n                _tokenId,\r\n                _tokenContractAddress,\r\n                address(this)\r\n            ),\r\n            \"sale not approved\"\r\n        );\r\n        uint256 priceInWei = sale.priceInWei;\r\n        _removeSale(_tokenId, _tokenContractAddress);\r\n        _transferFromTo(\r\n            seller,\r\n            address(safebox),\r\n            _tokenId,\r\n            _tokenContractAddress\r\n        );\r\n        emit OBOSaleEvent(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            address(safebox),\r\n            priceInWei\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Cancels a token sale and delete the record of sale. Only token owner\r\n     * can call this Fn.\r\n     */\r\n    function cancelSale(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n    {\r\n        DigitalMediaSale storage sale = tokenToSale[_tokenContractAddress][\r\n            _tokenId\r\n        ];\r\n        require(_isOnSale(sale), \"no sale\");\r\n        require(msg.sender == sale.seller, \"caller is not token owner\");\r\n        _cancelSale(_tokenId, _tokenContractAddress);\r\n    }\r\n\r\n    /**\r\n     * Looks up a token that's on sale.\r\n     */\r\n    function getSale(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n        view\r\n        returns (DigitalMediaSale memory)\r\n    {\r\n        DigitalMediaSale storage sale = tokenToSale[_tokenContractAddress][\r\n            _tokenId\r\n        ];\r\n        require(_isOnSale(sale), \"no sale\");\r\n        return sale;\r\n    }\r\n\r\n    /* Cancel many sales at once. Only ApprovedOBO can call this\r\n     */\r\n    function cancelSalesOBO(SaleRequest[] memory requests)\r\n        external\r\n        isApprovedOBO\r\n    {\r\n        for (uint32 i = 0; i < requests.length; i++) {\r\n            SaleRequest memory request = requests[i];\r\n            DigitalMediaSale storage sale = tokenToSale[request.tokenAddress][\r\n                request.tokenId\r\n            ];\r\n            if (_isOnSale(sale) == true) {\r\n                _cancelSale(request.tokenId, request.tokenAddress);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**********************\r\n     *       BIDDING       *\r\n     **********************/\r\n\r\n    /**\r\n     * Function to put a bid on an approved ERC721 contract token. This function\r\n     * stores only the current bid and the bid value in the contract. Any one can\r\n     * bid on any token. Make sure you are bidding over the current bid price.\r\n     */\r\n    function bidOnToken(uint256 _tokenId, address _tokenContractAddress)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        nonReentrant\r\n    {\r\n        uint256 bidPrice = msg.value;\r\n        require(bidPrice > 0, \"send msg.value\");\r\n        IERC721 tokenContract = _getTokenContract(_tokenContractAddress);\r\n        require(tokenContract.ownerOf(_tokenId) != address(0), \"inv tokenId\");\r\n        // Check if the current bid id exists for tokenId\r\n        uint256 currentBidId = tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        if (currentBidId != 0) {\r\n            TokenBid storage currentBid = bidIdToTokenBid[currentBidId];\r\n            require(bidPrice > currentBid.price, \"< current bid\");\r\n            address oldBidder = currentBid.bidder;\r\n            uint256 oldBidPrice = currentBid.price;\r\n            // After backing up the old bid delete them to save gas.\r\n            delete tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n            delete bidIdToTokenBid[currentBidId];\r\n            totalBidAmount = totalBidAmount - oldBidPrice;\r\n            // Return the old bid to the old bidder or to buffer\r\n            transferFunds(oldBidder, oldBidPrice);\r\n        }\r\n        uint256 bidId = _getNextBidId();\r\n        bidIdToTokenBid[bidId] = TokenBid({\r\n            bidder: msg.sender,\r\n            price: bidPrice\r\n        });\r\n        tokenIdToBidId[_tokenContractAddress][_tokenId] = bidId;\r\n        totalBidAmount = totalBidAmount + bidPrice;\r\n        // msg.value is automatically transferred to the contract.\r\n        // No need to explicity move the money\r\n        // https://programtheblockchain.com/posts/2017/12/15/writing-a-contract-that-handles-ether/\r\n        emit TokenBidCreatedEvent(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            bidId,\r\n            bidPrice,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * For a given approved ERC721 token, get the current bid\r\n     */\r\n    function getCurrentBidForToken(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 bidId,\r\n            address bidder,\r\n            uint256 price\r\n        )\r\n    {\r\n        uint256 currentBidId = tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        if (currentBidId == 0) {\r\n            return (0, address(0), 0);\r\n        } else {\r\n            TokenBid storage currentBid = bidIdToTokenBid[currentBidId];\r\n            return (currentBidId, currentBid.bidder, currentBid.price);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel the current bid for an approved ERC721 token. Only the current bidder\r\n     * or the approvedOBO can call this function. Cancelling the bid will move the\r\n     * funds back to the bidder. A token can be on sale which means the owner will be\r\n     * the sale contract. So we decided to make this approvedOBO call.\r\n     */\r\n    function cancelBid(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        uint256 _bidId\r\n    ) external nonReentrant {\r\n        uint256 currentBidId = tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        require(currentBidId != 0, \"No bid\");\r\n        require(currentBidId == _bidId, \"bidId not current\");\r\n        TokenBid storage currentBid = bidIdToTokenBid[currentBidId];\r\n        require(\r\n            currentBid.bidder == msg.sender ||\r\n                isValidApprovedOBO(msg.sender) ||\r\n                msg.sender == _ownerOf(_tokenId, _tokenContractAddress),\r\n            \"msg.sender not authorized\"\r\n        );\r\n        bool isBidder = (currentBid.bidder == msg.sender);\r\n        uint256 price = currentBid.price;\r\n        address bidderAddress = currentBid.bidder;\r\n        delete tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        delete bidIdToTokenBid[currentBidId];\r\n        totalBidAmount = totalBidAmount - price;\r\n        transferFunds(bidderAddress, price);\r\n        emit TokenBidRemovedEvent(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            currentBidId,\r\n            isBidder\r\n        );\r\n    }\r\n\r\n    function _getAndDeleteCurrentBid(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        uint256 _bidId\r\n    ) internal returns (address bidder, uint256 bidPrice) {\r\n        uint256 currentBidId = tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        require(currentBidId != 0, \"No bid\");\r\n        require(currentBidId == _bidId, \"bidId not current\");\r\n        TokenBid storage currentBid = bidIdToTokenBid[currentBidId];\r\n        bidder = currentBid.bidder;\r\n        bidPrice = currentBid.price;\r\n\r\n        // Delete the bid to avoid re-entrancy attack\r\n        delete tokenIdToBidId[_tokenContractAddress][_tokenId];\r\n        delete bidIdToTokenBid[currentBidId];\r\n        totalBidAmount = totalBidAmount - bidPrice;\r\n\r\n        _cancelSaleIfSaleExists(_tokenId, _tokenContractAddress);\r\n        return (bidder, bidPrice);\r\n    }\r\n\r\n    /**\r\n     * Accept the current Bid on a approved ERC721 token. Only the token owner can call\r\n     * this function. The token is immediately transferred to the buyer and payout is\r\n     * performed.\r\n     */\r\n    function acceptBid(\r\n        uint256 _tokenId,\r\n        address _tokenContractAddress,\r\n        uint256 _bidId\r\n    ) external whenNotPaused nonReentrant {\r\n        address seller = _ownerOf(_tokenId, _tokenContractAddress);\r\n        require(msg.sender == seller, \"msg.sender != seller\");\r\n        require(\r\n            _approvedForEscrow(\r\n                msg.sender,\r\n                _tokenId,\r\n                _tokenContractAddress,\r\n                address(this)\r\n            ),\r\n            \"approve/All missing\"\r\n        );\r\n        (address currentBidder, uint256 bidPrice) = _getAndDeleteCurrentBid(\r\n            _tokenId,\r\n            _tokenContractAddress,\r\n            _bidId\r\n        );\r\n        _transferFromTo(seller, currentBidder, _tokenId, _tokenContractAddress);\r\n        uint256 thisCommissionPercentage = getCommissionPercentageForToken(\r\n            seller,\r\n            _tokenId,\r\n            _tokenContractAddress\r\n        );\r\n        // Perform payout since seller is not a custodial account and can accept payment\r\n        // This endpoint is called only by the tokenOwner. We decided if the token owner\r\n        // took the pain to call this endpoint we will charge a commission based\r\n        // on if its sold by creator or other.\r\n        uint256 payoutAmount = 0;\r\n        if (_isValidTokenContract(_tokenContractAddress) == true) {\r\n            if (thisCommissionPercentage > 0) {\r\n                payoutAmount = _computePayoutForPrice(\r\n                    bidPrice,\r\n                    thisCommissionPercentage\r\n                );\r\n            }\r\n        } else {\r\n            payoutAmount = _computePayoutForPrice(\r\n                bidPrice,\r\n                thisCommissionPercentage\r\n            );\r\n        }\r\n        if (payoutAmount > 0) {\r\n            transferFunds(seller, payoutAmount);\r\n        }\r\n        emit TokenBidAccepted({\r\n            tokenId: _tokenId,\r\n            tokenAddress: _tokenContractAddress,\r\n            bidId: _bidId,\r\n            bidPrice: bidPrice,\r\n            bidder: currentBidder,\r\n            payoutAddress: seller,\r\n            seller: seller,\r\n            payoutAmount: payoutAmount\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Accept the current Bid on a approved ERC721 token. Only the master accounts with\r\n     * isApprovedOBO permission can call this function. Pulls the NFT from SafeBox\r\n     * and transfers to the bidder. No payout is performed in this contract. Its all offline.\r\n     * Goes to safebox for a lockup period, until credit card is resolved.\r\n     * Flow: alice safebox nft -> bob bids onchain -> alice accepts bid -> nights watch calls SaleCore.acceptBidOBO  -> pulls it from SafeBox -> NFT to Bob\r\n     */\r\n    function acceptBidsOBO(OBOAcceptBidStruct[] memory _requests)\r\n        external\r\n        whenNotPaused\r\n        isApprovedOBO\r\n        nonReentrant\r\n    {\r\n        for (uint256 i = 0; i < _requests.length; i++) {\r\n            address tokenAddress = _requests[i].tokenAddress;\r\n            uint256 tokenId = _requests[i].tokenId;\r\n            uint256 bidId = _requests[i].bidId;\r\n            bool useSafebox = _requests[i].useSafebox;\r\n            address seller = _ownerOf(tokenId, tokenAddress);\r\n\r\n            (address currentBidder, uint256 bidPrice) = _getAndDeleteCurrentBid(\r\n                tokenId,\r\n                tokenAddress,\r\n                bidId\r\n            );\r\n\r\n            if (useSafebox) {\r\n                safebox.singleTransfer(tokenAddress, tokenId, currentBidder);\r\n            } else {\r\n                vaultInterface.approveToken(tokenId, tokenAddress);\r\n                _transferFromTo(seller, currentBidder, tokenId, tokenAddress);\r\n            }\r\n\r\n            emit TokenBidAccepted({\r\n                tokenId: tokenId,\r\n                tokenAddress: tokenAddress,\r\n                bidId: bidId,\r\n                bidPrice: bidPrice,\r\n                bidder: currentBidder,\r\n                payoutAddress: address(0),\r\n                seller: seller,\r\n                payoutAmount: 0\r\n            });\r\n        }\r\n    }\r\n\r\n    /*\r\n     * An internal function to maintain a sequential identifier for bids\r\n     */\r\n    function _getNextBidId() private returns (uint256) {\r\n        _bidCounter.increment();\r\n        return _bidCounter.current();\r\n    }\r\n\r\n    // pause (idempotent)\r\n    function pause() external onlyOwner {\r\n        if (!paused()) {\r\n            _pause();\r\n        }\r\n    }\r\n\r\n    // unpause (idempotent)\r\n    function unpause() external onlyOwner {\r\n        if (paused()) {\r\n            _unpause();\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public view override onlyOwner {\r\n        revert(\"no\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safebox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"InvalidTokenAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum CommissionControl.CommissionType\",\"name\":\"commissionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"percentage\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"committed\",\"type\":\"bool\"}],\"name\":\"CommissionPercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"OBOAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"action\",\"type\":\"bool\"}],\"name\":\"NewOBOAddressEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oboAdminAddress\",\"type\":\"address\"}],\"name\":\"NewOBOAdminAddressEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSafeBoxAddress\",\"type\":\"address\"}],\"name\":\"NewSafeBoxInEffect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSafeBoxAddress\",\"type\":\"address\"}],\"name\":\"NewSafeBoxRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVaultAddress\",\"type\":\"address\"}],\"name\":\"NewVaultInEffect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVaultAddress\",\"type\":\"address\"}],\"name\":\"NewVaultRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"OBOSaleEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"SaleCanceledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"acceptFiat\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"SaleCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"SaleSuccessfulEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payoutAmount\",\"type\":\"uint256\"}],\"name\":\"TokenBidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"TokenBidCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBidder\",\"type\":\"bool\"}],\"name\":\"TokenBidRemovedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"widthdrawAddress\",\"type\":\"address\"}],\"name\":\"WithdrawAddressRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useSafebox\",\"type\":\"bool\"}],\"internalType\":\"struct DigitalMediaSaleCore.OBOAcceptBidStruct[]\",\"name\":\"_requests\",\"type\":\"tuple[]\"}],\"name\":\"acceptBidsOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"addApprovedOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"addApprovedOBOAfterDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"enum DigitalMediaSaleBase.ContractType\",\"name\":\"_contractType\",\"type\":\"uint8\"}],\"name\":\"addApprovedTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"addApprovedWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"addApprovedWithdrawAddressAfterDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedOBOs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTokenContracts\",\"outputs\":[{\"internalType\":\"enum DigitalMediaSaleBase.ContractType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedWithdrawAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"bidOnToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockImmediateOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canAddOBOImmediately\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canRoyaltyRegistryChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bidId\",\"type\":\"uint256\"}],\"name\":\"cancelBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"cancelSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"acceptFiat\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct DigitalMediaSaleCore.SaleRequest[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"name\":\"cancelSalesOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_percentage\",\"type\":\"uint16\"},{\"internalType\":\"enum CommissionControl.CommissionType\",\"name\":\"_cType\",\"type\":\"uint8\"}],\"name\":\"changeCommissionPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionAddressWaitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CommissionControl.CommissionType\",\"name\":\"_cType\",\"type\":\"uint8\"}],\"name\":\"commitCommissionChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_acceptFiat\",\"type\":\"bool\"}],\"name\":\"createSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CommissionControl.CommissionType\",\"name\":\"_cType\",\"type\":\"uint8\"}],\"name\":\"deleteCommissionChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"externalSaleCommission\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"percentage\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"intermediatePercentage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"getCurrentBidForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bidId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"getSale\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"acceptFiat\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionPercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct DigitalMediaFixedSale.DigitalMediaSale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialWithdrawAddressAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"isValidApprovedOBO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newAddressWaitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oboAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentInterface\",\"outputs\":[{\"internalType\":\"contract PaymentsBufferInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"purchaseOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reSaleCommission\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"percentage\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"intermediatePercentage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safebox\",\"type\":\"address\"}],\"name\":\"registerNewSafeBoxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"registerNewVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bufferAddress\",\"type\":\"address\"}],\"name\":\"registerPaymentsBufferAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oboAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedOBO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyPercentage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyStore\",\"outputs\":[{\"internalType\":\"contract RoyaltyRegistryInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safebox\",\"outputs\":[{\"internalType\":\"contract SafeBoxInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleCommission\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"percentage\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"intermediatePercentage\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oboAdmin\",\"type\":\"address\"}],\"name\":\"setOBOAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newPercentage\",\"type\":\"uint16\"}],\"name\":\"setRoyaltyPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRoyaltyRegistryForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyStore\",\"type\":\"address\"}],\"name\":\"setRoyaltyRegistryStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safebox\",\"type\":\"address\"}],\"name\":\"setSafeboxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"acceptFiat\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultInterface\",\"outputs\":[{\"internalType\":\"contract VaultCoreInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawApprovalWaitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DigitalMediaSaleCore", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000913add08c2791fa3fff4b95e94bf9054d3ee4052000000000000000000000000035da52e7aa085f7e71764c0c8a1ce6690e3dfef000000000000000000000000b7bc86cb0183af5853274ae4e20d36de387c4a64", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d7c38cbad5ad17b49ea6948f1562d9edb92c34b863a5a6774ff9592c3b4a1066"}]}