{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract OwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract Ownable is OwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    function transferOwnership(\r\n        address _newOwner,\r\n        bool _direct,\r\n        bool _renounce\r\n    ) external onlyOwner {\r\n        if (_direct) {\r\n            require(_newOwner != address(0) || _renounce, \"zero address\");\r\n\r\n            emit OwnershipTransferred(owner, _newOwner);\r\n            owner = _newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            pendingOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    function claimOwnership() external {\r\n        address _pendingOwner = pendingOwner;\r\n        require(msg.sender == _pendingOwner, \"caller != pending owner\");\r\n\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _setOwner(address newOwner) internal {\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Parameterized is Ownable {\r\n    uint256 internal constant DAY = 1 days;\r\n    uint256 internal constant WEEK = 7 days;\r\n    uint256 internal constant MONTH = 30 days;\r\n\r\n    struct StakeParameters {\r\n        uint256 value;\r\n    }\r\n\r\n    // time to wait for unstake\r\n    StakeParameters public timeToUnstake;\r\n\r\n    // fee for premature unstake\r\n    // value 1 = 1%\r\n    StakeParameters public unstakeFee;\r\n\r\n    // reward recalculation period length\r\n    StakeParameters public periodLength;\r\n\r\n    function _minusFee(uint256 val) internal view returns (uint256) {\r\n        return val - ((val * unstakeFee.value) / 100);\r\n    }\r\n\r\n    function updateFee(uint256 val) external onlyOwner {\r\n        unstakeFee.value = val;\r\n    }\r\n\r\n    function updateTimeToUnstake(uint256 val) external onlyOwner {\r\n        timeToUnstake.value = val;\r\n    }\r\n\r\n    function updatePeriodLength(uint256 val) external onlyOwner {\r\n        periodLength.value = val;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 amount) external returns (bool);\r\n\r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n\r\n    // EIP 2612\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: Transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: TransferFrom failed\");\r\n    }\r\n\r\n    function safeTransferFromDeluxe(IERC20 token, address from, uint256 amount) internal returns (uint256) {\r\n        uint256 preBalance = token.balanceOf(address(this));\r\n        safeTransferFrom(token, from, amount);\r\n        uint256 postBalance = token.balanceOf(address(this));\r\n        return postBalance - preBalance;\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e36 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\ncontract Staking is ReentrancyGuard, Parameterized {\r\n    using StableMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // staking token address\r\n    address public stakingToken;\r\n    // rewards token address\r\n    address public rewardsToken;\r\n    // fee collecting address\r\n    address public feeCollector;\r\n\r\n    // timestamp for current period finish\r\n    uint256 public periodFinish;\r\n    // rewardRate for the rest of the period\r\n    uint256 public rewardRate;\r\n    // last time any user took action\r\n    uint256 public lastUpdateTime;\r\n    // accumulated per token reward since the beginning of time\r\n    uint256 public rewardPerTokenStored;\r\n    // amount of tokens that is used in reward per token calculation\r\n    uint256 public stakedTokens;\r\n\r\n    struct Stake {\r\n        uint256 stakeStart; // timestamp of stake creation\r\n        uint256 rewardPerTokenPaid; // user accumulated per token rewards\r\n        uint256 tokens; // total tokens staked by user\r\n        uint256 rewards; // current not-claimed rewards from last update\r\n        uint256 withdrawalPossibleAt; // timestamp after which stake can be removed without fee\r\n        bool isWithdrawing; // true = user call to remove stake\r\n    }\r\n\r\n    // each holder have one stake\r\n    mapping(address => Stake) public tokenStake;\r\n\r\n    event Claimed(address indexed user, uint256 amount);\r\n    event StakeAdded(address indexed user, uint256 amount);\r\n    event StakeRemoveRequested(address indexed user);\r\n    event StakeRemoved(address indexed user, uint256 amount);\r\n    event Recalculation(uint256 reward);\r\n\r\n    /**\r\n     * One time initialization function\r\n     * @param _stakingToken staking token address\r\n     * @param _rewardsToken rewards token address\r\n     * @param _feeCollector fee collecting address\r\n     */\r\n    function init(\r\n        address _stakingToken,\r\n        address _rewardsToken,\r\n        address _feeCollector\r\n    ) external onlyOwner {\r\n        require(_stakingToken != address(0), \"_stakingToken address cannot be 0\");\r\n        require(_rewardsToken != address(0), \"_rewardsToken address cannot be 0\");\r\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\r\n        require(stakingToken == address(0), \"init already done\");\r\n        stakingToken = _stakingToken;\r\n        rewardsToken = _rewardsToken;\r\n        feeCollector = _feeCollector;\r\n\r\n        timeToUnstake.value = 3 * DAY;\r\n        unstakeFee.value = 20;\r\n        periodLength.value = 6 * MONTH;\r\n    }\r\n\r\n    function setFeeCollector(address _feeCollector) external onlyOwner {\r\n        require(_feeCollector != address(0), \"_feeCollector address cannot be 0\");\r\n        feeCollector = _feeCollector;\r\n    }\r\n\r\n    /**\r\n     * Updates the reward for a given address,\r\n     *      before executing function\r\n     * @param _account address for which rewards will be updated\r\n     */\r\n    modifier updateReward(address _account) {\r\n        _updateReward(_account);\r\n        _;\r\n    }\r\n\r\n    modifier hasStake() {\r\n        require(tokenStake[msg.sender].tokens > 0, \"nothing staked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * checks if the msg.sender can withdraw requested unstake\r\n     */\r\n    modifier canUnstake() {\r\n        require(_canUnstake(), \"cannot unstake\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * checks if for the msg.sender there is possibility to\r\n     *      withdraw staked tokens without fee.\r\n     */\r\n    modifier cantUnstake() {\r\n        require(!_canUnstake(), \"unstake first\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Updates reward\r\n     * @param _account address for which rewards will be updated\r\n     */\r\n    function _updateReward(address _account) internal {\r\n        uint256 newRewardPerTokenStored = currentRewardPerTokenStored();\r\n        // if statement protects against loss in initialization case\r\n        if (newRewardPerTokenStored > 0) {\r\n            rewardPerTokenStored = newRewardPerTokenStored;\r\n            lastUpdateTime = lastTimeRewardApplicable();\r\n\r\n            // setting of personal vars based on new globals\r\n            if (_account != address(0)) {\r\n                Stake storage s = tokenStake[_account];\r\n                if (!s.isWithdrawing) {\r\n                    s.rewards = _earned(_account);\r\n                    s.rewardPerTokenPaid = newRewardPerTokenStored;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add tokens to staking contract\r\n     * @param _amount of tokens to stake\r\n     */\r\n    function addStake(uint256 _amount) external {\r\n        _addStake(msg.sender, _amount);\r\n        emit StakeAdded(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Add tokens to staking contract by using permit to set allowance\r\n     * @param _amount of tokens to stake\r\n     * @param _deadline of permit signature\r\n     * @param _approveMax allowance for the token\r\n     */\r\n    function addStakeWithPermit(\r\n        uint256 _amount,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        uint256 value = _approveMax ? type(uint256).max : _amount;\r\n        IERC20(stakingToken).permit(msg.sender, address(this), value, _deadline, v, r, s);\r\n        _addStake(msg.sender, _amount);\r\n        emit StakeAdded(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Internal add stake function\r\n     * @param _account staking tokens are credited to this address\r\n     * @param _amount of staked tokens\r\n     */\r\n    function _addStake(address _account, uint256 _amount) internal nonReentrant updateReward(_account) {\r\n        require(_amount > 0, \"zero amount\");\r\n        Stake storage ts = tokenStake[_account];\r\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\r\n\r\n        // check for fee-on-transfer and proceed with received amount\r\n        _amount = _transferFrom(stakingToken, msg.sender, _amount);\r\n\r\n        if (ts.stakeStart == 0) {\r\n            // new stake\r\n            ts.stakeStart = block.timestamp;\r\n        }\r\n\r\n        // update account stake data\r\n        ts.tokens += _amount;\r\n        // update staking data\r\n        stakedTokens += _amount;\r\n    }\r\n\r\n    function claim() external {\r\n        _claim(msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Internal claim function. First updates rewards\r\n     *      and then transfers.\r\n     * @param _account claim rewards for this address\r\n     * @param _recipient claimed tokens are sent to this address\r\n     */\r\n    function _claim(address _account, address _recipient) internal nonReentrant hasStake updateReward(_account) {\r\n        uint256 rewards = tokenStake[_account].rewards;\r\n        require(rewards > 0, \"nothing to claim\");\r\n\r\n        delete tokenStake[_account].rewards;\r\n        _transfer(rewardsToken, _recipient, rewards);\r\n\r\n        emit Claimed(_account, rewards);\r\n    }\r\n\r\n    /**\r\n     * Request unstake for deposited tokens. Marks user token stake as withdrawing,\r\n     *      and start withdrawing period.\r\n     */\r\n    function requestUnstake() external {\r\n        _requestUnstake(msg.sender);\r\n        emit StakeRemoveRequested(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Internal request unstake function. Update rewards for the user first.\r\n     * @param _account User address\r\n     */\r\n    function _requestUnstake(address _account) internal hasStake() updateReward(_account) {\r\n        Stake storage ts = tokenStake[_account];\r\n        require(!ts.isWithdrawing, \"cannot when withdrawing\");\r\n\r\n        // update account stake data\r\n        ts.isWithdrawing = true;\r\n        ts.withdrawalPossibleAt = block.timestamp + timeToUnstake.value;\r\n        // update pool staking data\r\n        stakedTokens -= ts.tokens;\r\n    }\r\n\r\n    function unstake() external nonReentrant hasStake canUnstake {\r\n        _unstake(false);\r\n    }\r\n\r\n    function unstakeWithFee() external nonReentrant hasStake cantUnstake {\r\n        _unstake(true);\r\n    }\r\n\r\n    function _unstake(bool withFee) private {\r\n        Stake memory ts = tokenStake[msg.sender];\r\n        uint256 tokens;\r\n        uint256 rewards;\r\n        uint256 fee;\r\n\r\n        if (ts.isWithdrawing) {\r\n            tokens = withFee ? _minusFee(ts.tokens) : ts.tokens;\r\n            fee = withFee ? (ts.tokens - tokens) : 0;\r\n            rewards = ts.rewards;\r\n\r\n            emit StakeRemoved(msg.sender, ts.tokens);\r\n            delete tokenStake[msg.sender];\r\n        }\r\n\r\n        if (tokens > 0) {\r\n            _transfer(stakingToken, msg.sender, tokens);\r\n            if (fee > 0) {\r\n                _transfer(stakingToken, feeCollector, fee);\r\n            }\r\n        }\r\n\r\n        if (rewards > 0) {\r\n            _transfer(rewardsToken, msg.sender, rewards);\r\n            emit Claimed(msg.sender, rewards);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the last applicable timestamp for this reward period\r\n     */\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return StableMath.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    /**\r\n     * Calculates the amount of unclaimed rewards per token since last update,\r\n     *      and sums with stored to give the new cumulative reward per token\r\n     * @return 'Reward' per staked token\r\n     */\r\n    function currentRewardPerTokenStored() public view returns (uint256) {\r\n        // If there is no staked tokens, avoid div(0)\r\n        if (stakedTokens == 0) {\r\n            return (rewardPerTokenStored);\r\n        }\r\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\r\n        uint256 timeDelta = lastTimeRewardApplicable() - lastUpdateTime;\r\n        uint256 rewardUnitsToDistribute = rewardRate * timeDelta;\r\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / stakedTokens\r\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedTokens);\r\n        // return summed rate\r\n        return (rewardPerTokenStored + unitsToDistributePerToken);\r\n    }\r\n\r\n    /**\r\n    * Aligns staking and reward pool tokens.\r\n    */\r\n    function notifyRewards(uint256 m) external onlyOwner {\r\n        uint256 timeDelta = lastTimeRewardApplicable() - lastUpdateTime;\r\n        uint256 rewardUnitsToDistribute = rewardRate * timeDelta;\r\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedTokens);\r\n        if (m==0 || m == 1)\r\n            _transfer(stakingToken, feeCollector, IERC20(stakingToken).balanceOf(address(this)));\r\n        if (m==0 || m == 2)\r\n            _transfer(rewardsToken, feeCollector, IERC20(rewardsToken).balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * Calculates the amount of unclaimed rewards a user has earned\r\n     * @param _account user address\r\n     * @return Total reward amount earned\r\n     */\r\n    function _earned(address _account) internal view returns (uint256) {\r\n        Stake memory ts = tokenStake[_account];\r\n        if (ts.isWithdrawing) return ts.rewards;\r\n\r\n        // current rate per token - rate user previously received\r\n        uint256 userRewardDelta = currentRewardPerTokenStored() - ts.rewardPerTokenPaid;\r\n        uint256 userNewReward = ts.tokens.mulTruncate(userRewardDelta);\r\n\r\n        // add to previous rewards\r\n        return (ts.rewards + userNewReward);\r\n    }\r\n\r\n    /**\r\n     * Calculates the claimable amounts for token stake from rewards\r\n     * @param _account user address\r\n     */\r\n    function claimable(address _account) external view returns (uint256) {\r\n        return _earned(_account);\r\n    }\r\n\r\n    /**\r\n     * internal view to check if msg.sender can unstake\r\n     * @return true if user requested unstake and time for unstake has passed\r\n     */\r\n    function _canUnstake() private view returns (bool) {\r\n        return (tokenStake[msg.sender].isWithdrawing && block.timestamp >= tokenStake[msg.sender].withdrawalPossibleAt);\r\n    }\r\n\r\n    /**\r\n     * external view to check if address can stake tokens\r\n     * @return true if user can stake tokens\r\n     */\r\n    function canStakeTokens(address _account) external view returns (bool) {\r\n        return !tokenStake[_account].isWithdrawing;\r\n    }\r\n\r\n    function canUnstakeTokensWithoutFee() external view returns(bool) {\r\n        return _canUnstake();\r\n    }\r\n\r\n    /**\r\n     * Notifies the contract that new rewards have been added.\r\n     *      Calculates an updated rewardRate based on the rewards in period.\r\n     * @param _reward Units of rewardsToken that have been added to the token pool\r\n     */\r\n    function addRewards(uint256 _reward) external onlyOwner updateReward(address(0)) {\r\n        uint256 currentTime = block.timestamp;\r\n\r\n        // pull tokens\r\n        _transferFrom(rewardsToken, msg.sender, _reward);\r\n\r\n        // If previous period over, reset rewardRate\r\n        if (currentTime >= periodFinish) {\r\n            rewardRate = _reward / periodLength.value;\r\n        }\r\n        // If additional reward to existing period, calc sum\r\n        else {\r\n            uint256 remaining = periodFinish - currentTime;\r\n\r\n            uint256 leftoverReward = remaining * rewardRate;\r\n            rewardRate = (_reward + leftoverReward) / periodLength.value;\r\n        }\r\n\r\n        lastUpdateTime = currentTime;\r\n        periodFinish = currentTime + periodLength.value;\r\n\r\n        emit Recalculation(_reward);\r\n    }\r\n\r\n    function clearStuckBalance() external {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _token,\r\n        address _from,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        return IERC20(_token).safeTransferFromDeluxe(_from, _amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        IERC20(_token).safeTransfer(_to, _amount);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Recalculation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"StakeRemoveRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addStakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"canStakeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUnstakeTokensWithoutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"notifyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPossibleAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWithFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updatePeriodLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateTimeToUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://345833f2c9bf76d7716611b11971ac4234c3b6b7a38fbbb17a868fcacc418d19"}]}