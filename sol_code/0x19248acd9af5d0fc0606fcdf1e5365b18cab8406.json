{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: 3dCat/3dCat.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// ERC721A Contracts v4.2.2\r\n// Creator: Chiru Labs\r\n\r\n// ERC721A Contracts v4.2.2\r\n// Creator: Chiru Labs\r\n\r\n/**\r\n * @dev Interface of ERC721A.\r\n */\r\ninterface IERC721A {\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    /**\r\n     * Cannot query the balance for the zero address.\r\n     */\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /**\r\n     * Cannot mint to the zero address.\r\n     */\r\n    error MintToZeroAddress();\r\n\r\n    /**\r\n     * The quantity of tokens minted must be more than zero.\r\n     */\r\n    error MintZeroQuantity();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token must be owned by `from`.\r\n     */\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /**\r\n     * Cannot safely transfer to a contract that does not implement the\r\n     * ERC721Receiver interface.\r\n     */\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /**\r\n     * Cannot transfer to the zero address.\r\n     */\r\n    error TransferToZeroAddress();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error URIQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\r\n     */\r\n    error MintERC2309QuantityExceedsLimit();\r\n\r\n    /**\r\n     * The `extraData` cannot be set on an unintialized ownership slot.\r\n     */\r\n    error OwnershipNotInitializedForExtraData();\r\n\r\n    // =============================================================\r\n    //                            STRUCTS\r\n    // =============================================================\r\n\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Stores the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\r\n        uint24 extraData;\r\n    }\r\n\r\n    // =============================================================\r\n    //                         TOKEN COUNTERS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                            IERC721\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables\r\n     * (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\r\n     * checking first that contract recipients are aware of the ERC721 protocol\r\n     * to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move\r\n     * this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\r\n     * whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    // =============================================================\r\n    //                           IERC2309\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\r\n     * (inclusive) is transferred from `from` to `to`, as defined in the\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\r\n     *\r\n     * See {_mintERC2309} for more details.\r\n     */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\r\n}\r\n\r\n/**\r\n * @dev Interface of ERC721 token receiver.\r\n */\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721A\r\n *\r\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\r\n * Non-Fungible Token Standard, including the Metadata extension.\r\n * Optimized for lower gas during batch mints.\r\n *\r\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\r\n * starting from `_startTokenId()`.\r\n *\r\n * Assumptions:\r\n *\r\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\ncontract ERC721A is IERC721A {\r\n    // Reference type for token approval.\r\n    struct TokenApprovalRef {\r\n        address value;\r\n    }\r\n\r\n    // =============================================================\r\n    //                           CONSTANTS\r\n    // =============================================================\r\n\r\n    // Mask of an entry in packed address data.\r\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n\r\n    // The bit position of `numberMinted` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\r\n\r\n    // The bit position of `numberBurned` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\r\n\r\n    // The bit position of `aux` in packed address data.\r\n    uint256 private constant _BITPOS_AUX = 192;\r\n\r\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\r\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n\r\n    // The bit position of `startTimestamp` in packed ownership.\r\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\r\n\r\n    // The bit mask of the `burned` bit in packed ownership.\r\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\r\n\r\n    // The bit position of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\r\n\r\n    // The bit mask of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n\r\n    // The bit position of `extraData` in packed ownership.\r\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\r\n\r\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\r\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\r\n\r\n    // The mask of the lower 160 bits for addresses.\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n\r\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\r\n    // This limit is to prevent overflows on the address data entries.\r\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\r\n    // is required to cause an overflow, which is unrealistic.\r\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\r\n\r\n    // The `Transfer` event signature is given by:\r\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    // =============================================================\r\n    //                            STORAGE\r\n    // =============================================================\r\n\r\n    // The next token ID to be minted.\r\n    uint256 private _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 private _burnCounter;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned.\r\n    // See {_packedOwnershipOf} implementation for details.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..159]   `addr`\r\n    // - [160..223] `startTimestamp`\r\n    // - [224]      `burned`\r\n    // - [225]      `nextInitialized`\r\n    // - [232..255] `extraData`\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n\r\n    // Mapping owner address to address data.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..63]    `balance`\r\n    // - [64..127]  `numberMinted`\r\n    // - [128..191] `numberBurned`\r\n    // - [192..255] `aux`\r\n    mapping(address => uint256) private _packedAddressData;\r\n\r\n    // Mapping from token ID to approved address.\r\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // =============================================================\r\n    //                          CONSTRUCTOR\r\n    // =============================================================\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    // =============================================================\r\n    //                   TOKEN COUNTING OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than `_currentIndex - _startTokenId()` times.\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\r\n        // and it is initialized to `_startTokenId()`.\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens burned.\r\n     */\r\n    function _totalBurned() internal view virtual returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    // =============================================================\r\n    //                    ADDRESS DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens minted by `owner`.\r\n     */\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens burned by or on behalf of `owner`.\r\n     */\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     */\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\r\n    }\r\n\r\n    /**\r\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     * If there are multiple variables, please pack them into a uint64.\r\n     */\r\n    function _setAux(address owner, uint64 aux) internal virtual {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        // Cast `aux` with assembly to avoid redundant masking.\r\n        assembly {\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        // The interface IDs are constants representing the first 4 bytes\r\n        // of the XOR of all function selectors in the interface.\r\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\r\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return '';\r\n    }\r\n\r\n    // =============================================================\r\n    //                     OWNERSHIPS OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around over time.\r\n     */\r\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\r\n     */\r\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\r\n     */\r\n    function _initializeOwnershipAt(uint256 index) internal virtual {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the packed ownership data of `tokenId`.\r\n     */\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & _BITMASK_BURNED == 0) {\r\n                        // Invariant:\r\n                        // There will always be an initialized ownership slot\r\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\r\n                        // before an unintialized ownership slot\r\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\r\n                        // Hence, `curr` will not underflow.\r\n                        //\r\n                        // We can directly compare the packed value.\r\n                        // If the address is zero, packed will be zero.\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\r\n     */\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & _BITMASK_BURNED != 0;\r\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Packs ownership data into a single uint256.\r\n     */\r\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\r\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\r\n     */\r\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\r\n        // For branchless setting of the `nextInitialized` flag.\r\n        assembly {\r\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\r\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      APPROVAL OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId].value = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId].value;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted. See {_mint}.\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex && // If within bounds,\r\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\r\n     */\r\n    function _isSenderApprovedOrOwner(\r\n        address approvedAddress,\r\n        address owner,\r\n        address msgSender\r\n    ) private pure returns (bool result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\r\n            // `msgSender == owner || msgSender == approvedAddress`.\r\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\r\n     */\r\n    function _getApprovedSlotAndAddress(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256 approvedAddressSlot, address approvedAddress)\r\n    {\r\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\r\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\r\n        assembly {\r\n            approvedAddressSlot := tokenApproval.slot\r\n            approvedAddress := sload(approvedAddressSlot)\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      TRANSFER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        // The nested ifs save around 20+ gas over a compound boolean condition.\r\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // We can directly increment and decrement the balances.\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            // Updates:\r\n            // - `address` to the next owner.\r\n            // - `startTimestamp` to the timestamp of transfering.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        transferFrom(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token IDs\r\n     * are about to be transferred. This includes minting.\r\n     * And also called before burning one token.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token IDs\r\n     * have been transferred. This includes minting.\r\n     * And also called after one token has been burned.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` has been minted for `to`.\r\n     * - When `to` is zero, `tokenId` has been burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\r\n     *\r\n     * `from` - Previous owner of the given token ID.\r\n     * `to` - Target address that will receive the token.\r\n     * `tokenId` - Token ID to be transferred.\r\n     * `_data` - Optional data to send along with the call.\r\n     *\r\n     * Returns whether the call correctly returned the expected magic value.\r\n     */\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                        MINT OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _mint(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\r\n        // `tokenId` has a maximum limit of 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            uint256 toMasked;\r\n            uint256 end = startTokenId + quantity;\r\n\r\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\r\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\r\n            // The assembly, together with the surrounding Solidity code, have been\r\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\r\n            assembly {\r\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n                toMasked := and(to, _BITMASK_ADDRESS)\r\n                // Emit the `Transfer` event.\r\n                log4(\r\n                    0, // Start of data (0, since no data).\r\n                    0, // End of data (0, since no data).\r\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                    0, // `address(0)`.\r\n                    toMasked, // `to`.\r\n                    startTokenId // `tokenId`.\r\n                )\r\n\r\n                for {\r\n                    let tokenId := add(startTokenId, 1)\r\n                } iszero(eq(tokenId, end)) {\r\n                    tokenId := add(tokenId, 1)\r\n                } {\r\n                    // Emit the `Transfer` event. Similar to above.\r\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\r\n                }\r\n            }\r\n            if (toMasked == 0) revert MintToZeroAddress();\r\n\r\n            _currentIndex = end;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * This function is intended for efficient minting only during contract creation.\r\n     *\r\n     * It emits only one {ConsecutiveTransfer} as defined in\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\r\n     * instead of a sequence of {Transfer} event(s).\r\n     *\r\n     * Calling this function outside of contract creation WILL make your contract\r\n     * non-compliant with the ERC721 standard.\r\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\r\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {ConsecutiveTransfer} event.\r\n     */\r\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\r\n\r\n            _currentIndex = startTokenId + quantity;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * See {_mint}.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, quantity);\r\n\r\n        unchecked {\r\n            if (to.code.length != 0) {\r\n                uint256 end = _currentIndex;\r\n                uint256 index = end - quantity;\r\n                do {\r\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (index < end);\r\n                // Reentrancy protection.\r\n                if (_currentIndex != end) revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\r\n     */\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    // =============================================================\r\n    //                        BURN OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Equivalent to `_burn(tokenId, false)`.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (approvalCheck) {\r\n            // The nested ifs save around 20+ gas over a compound boolean condition.\r\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance -= 1`.\r\n            // - `numberBurned += 1`.\r\n            //\r\n            // We can directly decrement the balance, and increment the number burned.\r\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\r\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            // Updates:\r\n            // - `address` to the last owner.\r\n            // - `startTimestamp` to the timestamp of burning.\r\n            // - `burned` to `true`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                from,\r\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                     EXTRA DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Directly sets the extra data for the ownership data `index`.\r\n     */\r\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\r\n        uint256 packed = _packedOwnerships[index];\r\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\r\n        uint256 extraDataCasted;\r\n        // Cast `extraData` with assembly to avoid redundant masking.\r\n        assembly {\r\n            extraDataCasted := extraData\r\n        }\r\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\r\n        _packedOwnerships[index] = packed;\r\n    }\r\n\r\n    /**\r\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\r\n     * Intended to be overridden by the cosumer contract.\r\n     *\r\n     * `previousExtraData` - the value of `extraData` before transfer.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _extraData(\r\n        address from,\r\n        address to,\r\n        uint24 previousExtraData\r\n    ) internal view virtual returns (uint24) {}\r\n\r\n    /**\r\n     * @dev Returns the next extra data for the packed ownership data.\r\n     * The returned result is shifted into position.\r\n     */\r\n    function _nextExtraData(\r\n        address from,\r\n        address to,\r\n        uint256 prevOwnershipPacked\r\n    ) private view returns (uint256) {\r\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\r\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\r\n    }\r\n\r\n    // =============================================================\r\n    //                       OTHER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the message sender (defaults to `msg.sender`).\r\n     *\r\n     * If you are writing GSN compatible contracts, you need to override this function.\r\n     */\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a uint256 to its ASCII string decimal representation.\r\n     */\r\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit),\r\n            // but we allocate 0x80 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 32-byte word to store the length,\r\n            // and 3 32-byte words to store a maximum of 78 digits. Total: 0x20 + 3 * 0x20 = 0x80.\r\n            str := add(mload(0x40), 0x80)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, str)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     *\r\n     * Format of the revert message is described in {_checkRole}.\r\n     *\r\n     * _Available since v4.6._\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(account),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\r\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\r\n     * initialization.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized < type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\r\n     * consuming from one or the other at each step according to the instructions given by\r\n     * `proofFlags`.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\r\n\r\n/**\r\n * @dev Interface for the NFT Royalty Standard.\r\n *\r\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\r\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\r\n *\r\n * _Available since v4.5._\r\n */\r\ninterface IERC2981 is IERC165 {\r\n    /**\r\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\r\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\r\n     */\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\r\n *\r\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\r\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\r\n *\r\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\r\n * fee is specified in basis points by default.\r\n *\r\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\r\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\r\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\r\n *\r\n * _Available since v4.5._\r\n */\r\n\r\nabstract contract ERC2981 is IERC165, IERC2981 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC2981).interfaceId;\r\n    }\r\n}\r\n\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n\r\n            } {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(\r\n                    out,\r\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\r\n                )\r\n                out := shl(8, out)\r\n                out := add(\r\n                    out,\r\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\r\n                )\r\n                out := shl(8, out)\r\n                out := add(\r\n                    out,\r\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\r\n                )\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n\r\ncontract NFTCollection is ERC721A, ERC2981, AccessControl, Initializable {\r\n    using Address for address payable;\r\n    using Strings for uint256;\r\n\r\n    /// Fixed at deployment time\r\n    struct DeploymentConfig {\r\n        // Name of the NFT contract.\r\n        string name;\r\n        // Symbol of the NFT contract.\r\n        string symbol;\r\n        // The contract owner address. If you wish to own the contract, then set it as your wallet address.\r\n        // This is also the wallet that can manage the contract on NFT marketplaces. Use `transferOwnership()`\r\n        // to update the contract owner.\r\n        address owner;\r\n        // The maximum number of tokens that can be minted in this collection.\r\n        uint256 maxSupply;\r\n        // The number of free token mints reserved for the contract owner\r\n        uint256 reservedSupply;\r\n        // Treasury address is the address where minting fees can be withdrawn to.\r\n        // Use `withdrawFees()` to transfer the entire contract balance to the treasury address.\r\n        address payable treasuryAddress;\r\n    }\r\n\r\n    /// Updatable by admins and owner\r\n    struct RuntimeConfig {\r\n        // Metadata base URI for tokens, NFTs minted in this contract will have metadata URI of `baseURI` + `tokenID`.\r\n        // Set this to reveal token metadata.\r\n        string baseURI;\r\n        // If true, the base URI of the NFTs minted in the specified contract can be updated after minting (token URIs\r\n        // are not frozen on the contract level). This is useful for revealing NFTs after the drop. If false, all the\r\n        // NFTs minted in this contract are frozen by default which means token URIs are non-updatable.\r\n        bool metadataUpdatable;\r\n        /// The maximum number of tokens the user can mint per transaction.\r\n        uint256 tokensPerMint;\r\n        // Minting price per token for public minting\r\n        uint256 publicMintPrice;\r\n        // Flag for freezing the public mint price\r\n        bool publicMintPriceFrozen;\r\n        // Minting price per token for presale minting\r\n        uint256 presaleMintPrice;\r\n        // Flag for freezing the presale mint price\r\n        bool presaleMintPriceFrozen;\r\n        // Starting timestamp for public minting.\r\n        uint256 publicMintStart;\r\n        // Starting timestamp for whitelisted/presale minting.\r\n        uint256 presaleMintStart;\r\n        // Pre-reveal token URI for placholder metadata. This will be returned for all token IDs until a `baseURI`\r\n        // has been set.\r\n        string prerevealTokenURI;\r\n        // Root of the Merkle tree of whitelisted addresses. This is used to check if a wallet has been whitelisted\r\n        // for presale minting.\r\n        bytes32 presaleMerkleRoot;\r\n        // Secondary market royalties in basis points (100 bps = 1%)\r\n        uint256 royaltiesBps;\r\n        // Address for royalties\r\n        address royaltiesAddress;\r\n    }\r\n\r\n    struct ContractInfo {\r\n        uint256 version;\r\n        DeploymentConfig deploymentConfig;\r\n        RuntimeConfig runtimeConfig;\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /*************\r\n     * Constants *\r\n     *************/\r\n\r\n    /// Contract version, semver-style uint X_YY_ZZ\r\n    uint256 public constant VERSION = 1_03_00;\r\n\r\n    /// Admin role\r\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n\r\n    // Basis for calculating royalties.\r\n    // This has to be 10k for royaltiesBps to be in basis points.\r\n    uint16 public constant ROYALTIES_BASIS = 10000;\r\n\r\n    /********************\r\n     * Public variables *\r\n     ********************/\r\n\r\n    /// The number of tokens remaining in the reserve\r\n    /// @dev Managed by the contract\r\n    uint256 public reserveRemaining;\r\n\r\n    /***************************\r\n     * Contract initialization *\r\n     ***************************/\r\n\r\n    constructor() ERC721A(\"\", \"\") {\r\n        _preventInitialization = true;\r\n    }\r\n\r\n    /// Contract initializer\r\n    function initialize(\r\n        DeploymentConfig memory deploymentConfig,\r\n        RuntimeConfig memory runtimeConfig\r\n    ) public initializer {\r\n        require(!_preventInitialization, \"Cannot be initialized\");\r\n        _validateDeploymentConfig(deploymentConfig);\r\n\r\n        _grantRole(ADMIN_ROLE, msg.sender);\r\n        _transferOwnership(deploymentConfig.owner);\r\n\r\n        _deploymentConfig = deploymentConfig;\r\n        _runtimeConfig = runtimeConfig;\r\n\r\n        reserveRemaining = deploymentConfig.reservedSupply;\r\n    }\r\n\r\n    /****************\r\n     * User actions *\r\n     ****************/\r\n\r\n    /// Mint tokens\r\n    function mint(uint256 amount)\r\n        external\r\n        payable\r\n        paymentProvided(amount * _runtimeConfig.publicMintPrice)\r\n    {\r\n        require(mintingActive(), \"Minting has not started yet\");\r\n\r\n        _mintTokens(msg.sender, amount);\r\n    }\r\n\r\n    /// Mint tokens if the wallet has been whitelisted\r\n    function presaleMint(uint256 amount, bytes32[] calldata proof)\r\n        external\r\n        payable\r\n        paymentProvided(amount * _runtimeConfig.presaleMintPrice)\r\n    {\r\n        require(presaleActive(), \"Presale has not started yet\");\r\n        require(\r\n            isWhitelisted(msg.sender, proof),\r\n            \"Not whitelisted for presale\"\r\n        );\r\n\r\n        _presaleMinted[msg.sender] = true;\r\n        _mintTokens(msg.sender, amount);\r\n    }\r\n\r\n    /******************\r\n     * View functions *\r\n     ******************/\r\n\r\n    /// Check if public minting is active\r\n    function mintingActive() public view returns (bool) {\r\n        // We need to rely on block.timestamp since it's\r\n        // asier to configure across different chains\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return block.timestamp > _runtimeConfig.publicMintStart;\r\n    }\r\n\r\n    /// Check if presale minting is active\r\n    function presaleActive() public view returns (bool) {\r\n        // We need to rely on block.timestamp since it's\r\n        // easier to configure across different chains\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return block.timestamp > _runtimeConfig.presaleMintStart;\r\n    }\r\n\r\n    /// Get the number of tokens still available for minting\r\n    function availableSupply() public view returns (uint256) {\r\n        return _deploymentConfig.maxSupply - totalSupply() - reserveRemaining;\r\n    }\r\n\r\n    /// Check if the wallet is whitelisted for the presale\r\n    function isWhitelisted(address wallet, bytes32[] calldata proof)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(!_presaleMinted[wallet], \"Already minted\");\r\n\r\n        bytes32 leaf = keccak256(abi.encodePacked(wallet));\r\n\r\n        return\r\n            MerkleProof.verify(proof, _runtimeConfig.presaleMerkleRoot, leaf);\r\n    }\r\n\r\n    /// \u5224\u65ad\u662f\u5426\u5df2\u7ecfpresaleMint address\r\n    function didPresaleMinted(address wallet) public view returns (bool) {\r\n        return _presaleMinted[wallet];\r\n    }\r\n\r\n    /// Contract owner address\r\n    /// @dev Required for easy integration with OpenSea\r\n    function owner() public view returns (address) {\r\n        return _deploymentConfig.owner;\r\n    }\r\n\r\n    /*******************\r\n     * Access controls *\r\n     *******************/\r\n\r\n    /// Transfer contract ownership\r\n    function transferOwnership(address newOwner)\r\n        external\r\n        onlyRole(DEFAULT_ADMIN_ROLE)\r\n    {\r\n        require(newOwner != _deploymentConfig.owner, \"Already the owner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /// Transfer contract ownership\r\n    function transferAdminRights(address to) external onlyRole(ADMIN_ROLE) {\r\n        require(!hasRole(ADMIN_ROLE, to), \"Already an admin\");\r\n        require(msg.sender != _deploymentConfig.owner, \"Use transferOwnership\");\r\n\r\n        _revokeRole(ADMIN_ROLE, msg.sender);\r\n        _grantRole(ADMIN_ROLE, to);\r\n    }\r\n\r\n    /*****************\r\n     * Admin actions *\r\n     *****************/\r\n\r\n    /// Mint a token from the reserve\r\n    function reserveMint(address to, uint256 amount)\r\n        external\r\n        onlyRole(ADMIN_ROLE)\r\n    {\r\n        require(amount <= reserveRemaining, \"Not enough reserved\");\r\n\r\n        reserveRemaining -= amount;\r\n        _mintTokens(to, amount);\r\n    }\r\n\r\n    /// Get full contract information\r\n    /// @dev Convenience helper\r\n    function getInfo() external view returns (ContractInfo memory info) {\r\n        info.version = VERSION;\r\n        info.deploymentConfig = _deploymentConfig;\r\n        info.runtimeConfig = _runtimeConfig;\r\n    }\r\n\r\n    /// Update contract configuration\r\n    /// @dev Callable by admin roles only\r\n    function updateConfig(RuntimeConfig calldata newConfig)\r\n        external\r\n        onlyRole(ADMIN_ROLE)\r\n    {\r\n        _validateRuntimeConfig(newConfig);\r\n        _runtimeConfig = newConfig;\r\n    }\r\n\r\n    /// Withdraw minting fees to the treasury address\r\n    /// @dev Callable by admin roles only\r\n    function withdrawFees() external onlyRole(ADMIN_ROLE) {\r\n        _deploymentConfig.treasuryAddress.sendValue(address(this).balance);\r\n    }\r\n\r\n    /*************\r\n     * Internals *\r\n     *************/\r\n\r\n    /// Contract configuration\r\n    RuntimeConfig internal _runtimeConfig;\r\n    DeploymentConfig internal _deploymentConfig;\r\n\r\n    /// Flag for disabling initalization for template contracts\r\n    bool internal _preventInitialization;\r\n\r\n    /// Mapping for tracking presale mint status\r\n    mapping(address => bool) internal _presaleMinted;\r\n\r\n    /// @dev Internal function for performing token mints\r\n    function _mintTokens(address to, uint256 amount) internal {\r\n        require(amount <= _runtimeConfig.tokensPerMint, \"Amount too large\");\r\n        require(amount <= availableSupply(), \"Not enough tokens left\");\r\n\r\n        _safeMint(to, amount);\r\n    }\r\n\r\n    /// Validate deployment config\r\n    function _validateDeploymentConfig(DeploymentConfig memory config)\r\n        internal\r\n        pure\r\n    {\r\n        require(config.maxSupply > 0, \"Maximum supply must be non-zero\");\r\n        require(\r\n            config.treasuryAddress != address(0),\r\n            \"Treasury address cannot be null\"\r\n        );\r\n        require(config.owner != address(0), \"Contract must have an owner\");\r\n        require(\r\n            config.reservedSupply <= config.maxSupply,\r\n            \"Reserve greater than supply\"\r\n        );\r\n    }\r\n\r\n    /// Validate a runtime configuration change\r\n    function _validateRuntimeConfig(RuntimeConfig calldata config)\r\n        internal\r\n        view\r\n    {\r\n        // Can't set royalties to more than 100%\r\n        require(config.royaltiesBps <= ROYALTIES_BASIS, \"Royalties too high\");\r\n        require(config.tokensPerMint > 0, \"Tokens per mint must be non-zero\");\r\n\r\n        // Validate mint price changes\r\n        _validatePublicMintPrice(config);\r\n        _validatePresaleMintPrice(config);\r\n\r\n        // Validate metadata changes\r\n        _validateMetadata(config);\r\n    }\r\n\r\n    function _validatePublicMintPrice(RuntimeConfig calldata config)\r\n        internal\r\n        view\r\n    {\r\n        // As long as public mint price is not frozen, all changes are valid\r\n        if (!_runtimeConfig.publicMintPriceFrozen) return;\r\n\r\n        // Can't change public mint price once frozen\r\n        require(\r\n            _runtimeConfig.publicMintPrice == config.publicMintPrice,\r\n            \"publicMintPrice is frozen\"\r\n        );\r\n\r\n        // Can't unfreeze public mint price\r\n        require(\r\n            config.publicMintPriceFrozen,\r\n            \"publicMintPriceFrozen is frozen\"\r\n        );\r\n    }\r\n\r\n    function _validatePresaleMintPrice(RuntimeConfig calldata config)\r\n        internal\r\n        view\r\n    {\r\n        // As long as presale mint price is not frozen, all changes are valid\r\n        if (!_runtimeConfig.presaleMintPriceFrozen) return;\r\n\r\n        // Can't change presale mint price once frozen\r\n        require(\r\n            _runtimeConfig.presaleMintPrice == config.presaleMintPrice,\r\n            \"presaleMintPrice is frozen\"\r\n        );\r\n\r\n        // Can't unfreeze presale mint price\r\n        require(\r\n            config.presaleMintPriceFrozen,\r\n            \"presaleMintPriceFrozen is frozen\"\r\n        );\r\n    }\r\n\r\n    function _validateMetadata(RuntimeConfig calldata config) internal view {\r\n        // If metadata is updatable, we don't have any other limitations\r\n        if (_runtimeConfig.metadataUpdatable) return;\r\n\r\n        // If it isn't, we can't allow the flag to change anymore\r\n        require(!config.metadataUpdatable, \"Cannot unfreeze metadata\");\r\n\r\n        // We also can't allow base URI to change\r\n        require(\r\n            keccak256(abi.encodePacked(_runtimeConfig.baseURI)) ==\r\n                keccak256(abi.encodePacked(config.baseURI)),\r\n            \"Metadata is frozen\"\r\n        );\r\n    }\r\n\r\n    /// Internal function without any checks for performing the ownership transfer\r\n    function _transferOwnership(address newOwner) internal {\r\n        address previousOwner = _deploymentConfig.owner;\r\n        _revokeRole(ADMIN_ROLE, previousOwner);\r\n        _revokeRole(DEFAULT_ADMIN_ROLE, previousOwner);\r\n\r\n        _deploymentConfig.owner = newOwner;\r\n        _grantRole(ADMIN_ROLE, newOwner);\r\n        _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\r\n\r\n        emit OwnershipTransferred(previousOwner, newOwner);\r\n    }\r\n\r\n    /// @dev See {IERC165-supportsInterface}.\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721A, AccessControl, ERC2981)\r\n        returns (bool)\r\n    {\r\n        return\r\n            ERC721A.supportsInterface(interfaceId) ||\r\n            AccessControl.supportsInterface(interfaceId) ||\r\n            ERC2981.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// Get the token metadata URI\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(_exists(tokenId), \"Token does not exist\");\r\n\r\n        return\r\n            bytes(_runtimeConfig.baseURI).length > 0\r\n                ? string(\r\n                    abi.encodePacked(_runtimeConfig.baseURI, tokenId.toString())\r\n                )\r\n                : _runtimeConfig.prerevealTokenURI;\r\n    }\r\n\r\n    /// @dev Need name() to support setting it in the initializer instead of constructor\r\n    function name() public view override returns (string memory) {\r\n        return _deploymentConfig.name;\r\n    }\r\n\r\n    /// @dev Need symbol() to support setting it in the initializer instead of constructor\r\n    function symbol() public view override returns (string memory) {\r\n        return _deploymentConfig.symbol;\r\n    }\r\n\r\n    /// @dev ERC2981 token royalty info\r\n    function royaltyInfo(uint256, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount)\r\n    {\r\n        receiver = _runtimeConfig.royaltiesAddress;\r\n        royaltyAmount =\r\n            (_runtimeConfig.royaltiesBps * salePrice) /\r\n            ROYALTIES_BASIS;\r\n    }\r\n\r\n    /// @dev OpenSea contract metadata\r\n    function contractURI() external view returns (string memory) {\r\n        string memory json = Base64.encode(\r\n            bytes(\r\n                string(\r\n                    abi.encodePacked(\r\n                        '{\"seller_fee_basis_points\": ', // solhint-disable-line quotes\r\n                        _runtimeConfig.royaltiesBps.toString(),\r\n                        ', \"fee_recipient\": \"', // solhint-disable-line quotes\r\n                        uint256(uint160(_runtimeConfig.royaltiesAddress))\r\n                            .toHexString(20),\r\n                        '\"}' // solhint-disable-line quotes\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        string memory output = string(\r\n            abi.encodePacked(\"data:application/json;base64,\", json)\r\n        );\r\n\r\n        return output;\r\n    }\r\n\r\n    /// Check if enough payment was provided\r\n    modifier paymentProvided(uint256 payment) {\r\n        require(msg.value >= payment, \"Payment too small\");\r\n        _;\r\n    }\r\n\r\n    /***********************\r\n     * Convenience getters *\r\n     ***********************/\r\n\r\n    function maxSupply() public view returns (uint256) {\r\n        return _deploymentConfig.maxSupply;\r\n    }\r\n\r\n    function reservedSupply() public view returns (uint256) {\r\n        return _deploymentConfig.reservedSupply;\r\n    }\r\n\r\n    function publicMintPrice() public view returns (uint256) {\r\n        return _runtimeConfig.publicMintPrice;\r\n    }\r\n\r\n    function presaleMintPrice() public view returns (uint256) {\r\n        return _runtimeConfig.presaleMintPrice;\r\n    }\r\n\r\n    function tokensPerMint() public view returns (uint256) {\r\n        return _runtimeConfig.tokensPerMint;\r\n    }\r\n\r\n    function treasuryAddress() public view returns (address) {\r\n        return _deploymentConfig.treasuryAddress;\r\n    }\r\n\r\n    function publicMintStart() public view returns (uint256) {\r\n        return _runtimeConfig.publicMintStart;\r\n    }\r\n\r\n    function presaleMintStart() public view returns (uint256) {\r\n        return _runtimeConfig.presaleMintStart;\r\n    }\r\n\r\n    function presaleMerkleRoot() public view returns (bytes32) {\r\n        return _runtimeConfig.presaleMerkleRoot;\r\n    }\r\n\r\n    function baseURI() public view returns (string memory) {\r\n        return _runtimeConfig.baseURI;\r\n    }\r\n\r\n    function metadataUpdatable() public view returns (bool) {\r\n        return _runtimeConfig.metadataUpdatable;\r\n    }\r\n\r\n    function prerevealTokenURI() public view returns (string memory) {\r\n        return _runtimeConfig.prerevealTokenURI;\r\n    }\r\n}\r\n\r\ncontract NFTCollectionContract is NFTCollection {\r\n    constructor(\r\n        DeploymentConfig memory deploymentConfig,\r\n        RuntimeConfig memory runtimeConfig\r\n    ) {\r\n        _preventInitialization = false;\r\n        initialize(deploymentConfig, runtimeConfig);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSupply\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.DeploymentConfig\",\"name\":\"deploymentConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"metadataUpdatable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"publicMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"presaleMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"publicMintStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintStart\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prerevealTokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.RuntimeConfig\",\"name\":\"runtimeConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROYALTIES_BASIS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"didPresaleMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSupply\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.DeploymentConfig\",\"name\":\"deploymentConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"metadataUpdatable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"publicMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"presaleMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"publicMintStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintStart\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prerevealTokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.RuntimeConfig\",\"name\":\"runtimeConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct NFTCollection.ContractInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservedSupply\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.DeploymentConfig\",\"name\":\"deploymentConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"metadataUpdatable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"publicMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"presaleMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"publicMintStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintStart\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prerevealTokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.RuntimeConfig\",\"name\":\"runtimeConfig\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataUpdatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prerevealTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"presaleMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleMintStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reserveMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferAdminRights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"metadataUpdatable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"publicMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"presaleMintPriceFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"publicMintStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"presaleMintStart\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"prerevealTokenURI\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"}],\"internalType\":\"struct NFTCollection.RuntimeConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTCollectionContract", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000001e3f83584ab4cb3c8026066a71ad3c9d2478117b000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000000c70000000000000000000000001e3f83584ab4cb3c8026066a71ad3c9d2478117b000000000000000000000000000000000000000000000000000000000000000a426c61636b4361743344000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005334443617400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000063adb980000000000000000000000000000000000000000000000000000000006306b8a30000000000000000000000000000000000000000000000000000000000000220c0358cc09344703a1002a93e17ab5a3974cde0fd8139cdf4126ee8973f618f6000000000000000000000000000000000000000000000000000000000000001f40000000000000000000000001e3f83584ab4cb3c8026066a71ad3c9d2478117b000000000000000000000000000000000000000000000000000000000000005968747470733a2f2f6261667962656965337837756d3633683578347134673735327a636c32657774327237717a326b32326c3567633461767a627a7161776e707837612e697066732e6e667473746f726167652e6c696e6b2f000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://25ad8e1779cffde03c4800cca6da85f2a9a151a2f16d1c8bb7bcc6e0a0d49855"}]}