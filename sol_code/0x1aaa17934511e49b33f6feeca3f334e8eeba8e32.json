{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"HausPhase_Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport { ReentrancyGuard } from \\\"./lib/solmate/utils/ReentrancyGuard.sol\\\";\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ninterface IERC20 {\\n    function burn(uint256 amount) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function mint(address _to, uint _amount) external;\\n}\\n\\ninterface IERC721 {\\n    function ownerOf(uint256 tokenID) external view returns (address);\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\\ncontract HPStaking is ReentrancyGuard, Ownable, Pausable {\\n    constructor() {\\n        phaseRewardRate[1] = 1000;\\n        phaseRewardRate[2] = 400;\\n        phaseRewardRate[3] = 100;\\n    }\\n    \\n    /////////////////////////////////////////////////////////\\n    /// Global variables\\n    /////////////////////////////////////////////////////////\\n    IERC20 private _hausToken;\\n    IERC721 private _hausPhase;\\n\\n    struct UserInfo {\\n        uint16[] balances;\\n        uint256 lastClaimedReward;\\n        uint256 totalClaimed;\\n    }\\n\\n    mapping (address => UserInfo) private userInfo;\\n    mapping (uint256 => address) private tokenOwner;\\n    mapping (uint256 => uint256) private phaseRewardRate;\\n\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdraw(address indexed user, uint256 amount);\\n    event Claimed(address indexed user, uint256 amount);\\n    event EmergencyWithdraw(address indexed from, uint256 amount);\\n\\n    /////////////////////////////////////////////////////////////////////////////\\n    ///  Stake/withdraw functions\\n    /////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice            Calculates and claims the rewards for the user\\n    function claimRewards() external nonReentrant returns (uint) {\\n        uint lastClaimed = userInfo[msg.sender].lastClaimedReward;\\n        require(lastClaimed > 0, \\\"ClaimRewards: You need to stake first\\\");\\n\\n        uint timeBetweenClaims = block.timestamp - lastClaimed;\\n        uint pendingRewards = timeBetweenClaims * _getRateForUser(msg.sender) / 86400;\\n\\n        userInfo[msg.sender].lastClaimedReward = block.timestamp;\\n        userInfo[msg.sender].totalClaimed += pendingRewards;\\n        _hausToken.mint(msg.sender, pendingRewards);\\n        emit Claimed(msg.sender, pendingRewards);\\n        return pendingRewards;\\n    }\\n\\n    /// @notice             Stakes multiple tokens for the user and claims pending tokens if there is any\\n    /// @param _tokenIds    target tokens\\n    function stakeMultiple(uint16[] calldata _tokenIds) external nonReentrant returns (uint) {\\n        if (userInfo[msg.sender].lastClaimedReward == 0) userInfo[msg.sender].lastClaimedReward = block.timestamp; // If this is the user's first time interacting with the contract, initialize lastClaimedReward to the current timestamp\\n        if (userInfo[msg.sender].balances.length > 0) _handleClaim(_getRateForUser(msg.sender));\\n\\n        emit Staked(msg.sender, _tokenIds.length);\\n        for(uint i; i < _tokenIds.length;) {\\n            _stakeNft(_tokenIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (block.timestamp);\\n    }\\n\\n    /// @notice             Withdraws all owned tokens by user and claim tokens for the user\\n    function withdrawAll() external nonReentrant {\\n        uint16[] memory tokenIds = userInfo[msg.sender].balances;\\n        require(tokenIds.length > 0, \\\"Withdraw: Empty balance\\\");\\n\\n        uint length = tokenIds.length;\\n        _handleClaim(_getRateForUser(msg.sender));\\n        \\n        for(uint i; i < length;) {\\n            _withdrawNft(tokenIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit Withdraw(msg.sender, length);\\n    }\\n\\n    /// @notice             Withdraws multiple tokens for the user and claims pending if there is any\\n    /// @param _tokenIds    Target tokenIDs\\n    function withdrawMultiple(uint16[] calldata _tokenIds) external nonReentrant {\\n        require(userInfo[msg.sender].balances.length > 0, \\\"Withdraw: Empty balance\\\");\\n        _handleClaim(_getRateForUser(msg.sender));\\n\\n        emit Withdraw(msg.sender, _tokenIds.length);\\n        for(uint i; i < _tokenIds.length;) {\\n            _withdrawNft(_tokenIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice      Withdraw staked tokens and give up rewards. Only use in case of emergecies\\n    function emergencyWithdraw() external nonReentrant whenPaused {\\n        uint16[] memory balance = userInfo[msg.sender].balances;\\n        uint256 length = balance.length;\\n        require(length > 0, \\\"Withdraw: Amount must be > 0\\\");\\n\\n        // Reset internal value for user\\n        userInfo[msg.sender].lastClaimedReward = block.timestamp;\\n\\n        emit EmergencyWithdraw(msg.sender, length);\\n        for(uint i; i < length;){\\n            _withdrawNft(balance[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////\\n    ///  Internal functions\\n    /////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice             Internal function to stake a single token for the user\\n    /// @param  _tokenId    Target token\\n    function _stakeNft(uint16 _tokenId) internal {\\n        require(_hausPhase.ownerOf(_tokenId) == msg.sender, \\\"Stake: not owner of token\\\");\\n\\n        userInfo[msg.sender].balances.push(_tokenId);\\n        _hausPhase.transferFrom(msg.sender, address(this), _tokenId);\\n        tokenOwner[_tokenId] = msg.sender;\\n    }\\n\\n    /// @notice             Internal function to withdraw a single token for the user\\n    /// @param _tokenId     Target token\\n    function _withdrawNft(uint16 _tokenId) internal {\\n        require(tokenOwner[_tokenId] == msg.sender, \\\"Withdraw: not owner of token\\\");\\n\\n        _removeElement(userInfo[msg.sender].balances, _tokenId);\\n        delete tokenOwner[_tokenId];\\n        _hausPhase.transferFrom(address(this), msg.sender, _tokenId);\\n    }\\n\\n    /// @notice             Internal function to remove element from the balance array\\n    /// @param _array       target array\\n    /// @param _element     target element of the array\\n    function _removeElement(uint16[] storage _array, uint256 _element) internal {\\n        uint256 length = _array.length;\\n        for (uint256 i; i < length;) {\\n            if (_array[i] == _element) {\\n                _array[i] = _array[_array.length - 1];\\n                _array.pop();\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice             Internal function to get base rate for single token\\n    /// @param _tokenId     Target tokenId\\n    function _getRatePerToken(uint16 _tokenId) internal view returns(uint) {\\n        if (_tokenId >= 0 && _tokenId < 390) {\\n            return phaseRewardRate[1] * 1e18;\\n        } else if (_tokenId > 389 && _tokenId < 3112) {\\n            return phaseRewardRate[2] * 1e18;\\n        } else if (_tokenId > 3111) {\\n            return phaseRewardRate[3] * 1e18;\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n    /// @notice             Internal function to to get base rate for all owned tokens\\n    /// @param _user        Target user\\n    function _getRateForUser(address _user) internal view returns(uint) {\\n        uint16[] memory tokenIds = userInfo[_user].balances;\\n        uint length = tokenIds.length;\\n        uint totalAmount;\\n        for(uint i; i < length;) {\\n            totalAmount += _getRatePerToken(tokenIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return totalAmount;\\n    }\\n\\n    /// @notice             Handles claiming for functions modifying the users state\\n    /// @param _rate        Base rate amount for the user\\n    function _handleClaim(uint _rate) internal {\\n        uint timeBetweenClaims = block.timestamp - userInfo[msg.sender].lastClaimedReward;\\n        uint pendingRewards = timeBetweenClaims * _rate / 86400;\\n\\n        userInfo[msg.sender].lastClaimedReward = block.timestamp;\\n        userInfo[msg.sender].totalClaimed += pendingRewards;\\n        _hausToken.mint(msg.sender, pendingRewards);\\n        emit Claimed(msg.sender, pendingRewards);\\n    }\\n\\n    /// @notice             Internal function to calculate pending rewards for a user\\n    /// @param _user        target user\\n    function _calculateReward(address _user) internal view returns(uint) {\\n        if (userInfo[_user].balances.length == 0) return 0;\\n        uint timeBetweenClaims = block.timestamp - userInfo[_user].lastClaimedReward;\\n        uint pendingRewards = timeBetweenClaims * _getRateForUser(_user) / 86400;\\n        return pendingRewards;\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////\\n    ///  Getter functions\\n    /////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice             Gets total amount of staked tokens in the contract\\n    function getTotalStakedTokens() external view returns(uint) {\\n        return _hausPhase.balanceOf(address(this));\\n    }\\n\\n    /// @notice             Gets total amount of staked tokens by the user\\n    /// @param _user        Target user\\n    function getUserBalance(address _user) external view returns(uint){\\n        return userInfo[_user].balances.length;\\n    }\\n\\n    /// @notice             Gets all tokenIds staked by the user\\n    /// @param _user        Target user\\n    function getUserStakedTokens(address _user) external view returns(uint16[] memory){\\n        return userInfo[_user].balances;\\n    }\\n\\n    /// @notice             Returns the daily reward rate for the user\\n    /// @dev                The rate is returned with decimals, so manage in the frontend accordingly\\n    /// @param _user        Target user\\n    function getUserRewardRate(address _user) external view returns(uint) {\\n        return _getRateForUser(_user);\\n    }\\n\\n    /// @notice             Calculates all pending rewards for a user. More for frontend\\n    /// @param _user        Target user\\n    function calculatePendingRewards(address _user) external view returns(uint) {\\n        return  _calculateReward(_user);\\n    }\\n\\n    /// @notice             Returns the total amount earned from staking (includes pending)\\n    /// @param _user        Target user\\n    function calculateTotalAndPendingRewards(address _user) external view returns(uint) {\\n        return userInfo[_user].totalClaimed + _calculateReward(_user);\\n    }\\n\\n    /// @notice             Returns the amount of tokens each phase version yields daily\\n    /// @param  _version    Version of the hausphase\\n    function getPhaseRewardRate(uint _version) external view returns(uint) {\\n        return phaseRewardRate[_version];\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////\\n    ///  Owner functions\\n    /////////////////////////////////////////////////////////////////////////////\\n\\n    /// @notice                     Sets the hausPhase contract\\n    /// @param _contract            Target ERC721 contract\\n    function setHausPhaseContract(address _contract) external onlyOwner {\\n        _hausPhase = IERC721(_contract);\\n    }\\n\\n    /// @notice                     Sets the hausToken contract\\n    /// @param _contract            Target ERC20 contract\\n    function setHausTokenContract(address _contract) external onlyOwner {\\n        _hausToken = IERC20(_contract);\\n    }\\n\\n    /// @notice                     Set the daily reward rate for hausphases\\n    /// @dev                        Note that changing this value will affect unclaimed rewards for every user\\n    /// @param _phaseVersion        The hausphase version\\n    /// @param _amount              The amount of hausTokens that will accumulate daily              \\n    function setRewardRate(uint _phaseVersion, uint _amount) external onlyOwner {\\n        require(_phaseVersion > 0 && _phaseVersion < 4, \\\"Incorrect phase version\\\");\\n        phaseRewardRate[_phaseVersion] = _amount;\\n    }\\n\\n    /// @notice                     Pause contract.Allows calling emergency withdraw\\n    function pause() external onlyOwner whenNotPaused {\\n        _pause();\\n    }\\n\\n    /// @notice                     Unpause contract\\n    function unpause() external onlyOwner whenPaused {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calculatePendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calculateTotalAndPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getPhaseRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserStakedTokens\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setHausPhaseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setHausTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_phaseVersion\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"stakeMultiple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"withdrawMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HPStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f3efc8cf9a33d0685d7b3c9499e4eb61d3d773f384aac1efe681b244e6289401"}]}