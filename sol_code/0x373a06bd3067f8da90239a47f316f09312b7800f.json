{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Swivel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/Protocols.sol';\\n\\nimport 'src/lib/Hash.sol';\\nimport 'src/lib/Sig.sol';\\nimport 'src/lib/Safe.sol';\\n\\nimport 'src/interfaces/IERC20.sol';\\nimport 'src/interfaces/IERC4626.sol';\\nimport 'src/interfaces/ISwivel.sol';\\nimport 'src/interfaces/IMarketPlace.sol';\\nimport 'src/interfaces/IAave.sol';\\nimport 'src/interfaces/ICompound.sol';\\nimport 'src/interfaces/IEuler.sol';\\nimport 'src/interfaces/ILido.sol';\\nimport 'src/interfaces/IYearn.sol';\\n\\ncontract Swivel is ISwivel {\\n    /// @dev A single custom error capable of indicating a wide range of detected errors by providing\\n    /// an error code value whose string representation is documented <here>, and any possible other values\\n    /// that are pertinent to the error.\\n    error Exception(uint8, uint256, uint256, address, address);\\n    /// @dev maps the key of an order to a boolean indicating if an order was cancelled\\n    mapping(bytes32 => bool) public cancelled;\\n    /// @dev maps the key of an order to an amount representing its taken volume\\n    mapping(bytes32 => uint256) public filled;\\n    /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\\n    mapping(address => uint256) public withdrawals;\\n    /// @dev maps a token address and approved contract tuple to a point in time, a hold, after which an underlying approval can be made\\n    mapping(address => mapping(address => uint256)) public approvals;\\n\\n    string public constant NAME = 'Swivel Finance';\\n    string public constant VERSION = '3.0.0';\\n    uint256 public constant HOLD = 3 days;\\n    /// @dev point in time at which a fee change may take place\\n    uint256 public feeChange;\\n    bytes32 public immutable domain;\\n    address public immutable marketPlace;\\n    address public admin;\\n\\n    /// @dev address of a deployed Aave contract implementing IAave\\n    address public immutable aaveAddr;\\n\\n    uint16 public constant MIN_FEENOMINATOR = 33;\\n    /// @dev holds the fee denominators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\\n    uint16[4] public feenominators = [200, 600, 400, 200];\\n\\n    /// @notice Emitted on order cancellation\\n    event Cancel(bytes32 indexed key, bytes32 hash);\\n    /// @notice Emitted on any initiate*\\n    /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\\n    /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\\n    event Initiate(\\n        bytes32 indexed key,\\n        bytes32 hash,\\n        address indexed maker,\\n        bool vault,\\n        bool exit,\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 filled\\n    );\\n    /// @notice Emitted on any exit*\\n    /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\\n    /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\\n    event Exit(\\n        bytes32 indexed key,\\n        bytes32 hash,\\n        address indexed maker,\\n        bool vault,\\n        bool exit,\\n        address indexed sender,\\n        uint256 amount,\\n        uint256 filled\\n    );\\n    /// @notice Emitted on token withdrawal scheduling\\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\\n    /// @notice Emitted on token approval scheduling\\n    event ScheduleApproval(\\n        address indexed token,\\n        address indexed approved,\\n        uint256 hold\\n    );\\n    /// @notice Emitted on fee change scheduling\\n    event ScheduleFeeChange(uint16[4] proposal, uint256 hold);\\n    /// @notice Emitted on token withdrawal blocking\\n    event BlockWithdrawal(address indexed token);\\n    /// @notice Emitted on token approval blocking\\n    event BlockApproval(address indexed token, address indexed blocked);\\n    /// @notice Emitted on fee change blocking\\n    event BlockFeeChange();\\n    /// @notice Emitted on a change to the fee structure\\n    event ChangeFee(uint256 indexed index, uint256 indexed value);\\n    event SetAdmin(address indexed admin);\\n\\n    /// @param m Deployed MarketPlace contract address\\n    /// @param a Address of a deployed Aave contract implementing our interface\\n    constructor(address m, address a) {\\n        admin = msg.sender;\\n        domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\\n        marketPlace = m;\\n        aaveAddr = a;\\n    }\\n\\n    // ********* INITIATING *************\\n\\n    /// @notice Allows a user to initiate a position\\n    /// @param o Array of offline Swivel.Orders\\n    /// @param a Array of order volume (principal) amounts relative to passed orders\\n    /// @param c Array of Components from valid ECDSA signatures\\n    function initiate(\\n        Hash.Order[] calldata o,\\n        uint256[] calldata a,\\n        Sig.Components[] calldata c\\n    ) external returns (bool) {\\n        // for each order filled, routes the order to the right interaction depending on its params\\n        for (uint256 i; i != o.length; ) {\\n            if (!o[i].exit) {\\n                if (!o[i].vault) {\\n                    initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\\n                } else {\\n                    initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\\n                }\\n            } else {\\n                if (!o[i].vault) {\\n                    initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\\n                } else {\\n                    initiateVaultFillingVaultExit(o[i], a[i], c[i]);\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\\n    /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (premium) being filled by the taker's initiate\\n    /// @param c Components of a valid ECDSA signature\\n    function initiateVaultFillingZcTokenInitiate(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        // checks order signature, order cancellation and order expiry\\n        bytes32 hash = validOrderHash(o, c);\\n\\n        // checks the side, and the amount compared to available\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.premium) {\\n            revert Exception(5, amount, o.premium, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        // transfer underlying tokens\\n        IERC20 uToken = IERC20(o.underlying);\\n        Safe.transferFrom(uToken, msg.sender, o.maker, a);\\n\\n        uint256 principalFilled = (a * o.principal) / o.premium;\\n        Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\\n\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        address cTokenAddr = mPlace.cTokenAddress(\\n            o.protocol,\\n            o.underlying,\\n            o.maturity\\n        );\\n\\n        // perform the actual deposit type transaction, specific to a protocol\\n        if (!deposit(o.protocol, o.underlying, cTokenAddr, principalFilled)) {\\n            revert Exception(6, 0, 0, address(0), address(0));\\n        }\\n\\n        // alert marketplace\\n        if (\\n            !mPlace.custodialInitiate(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                o.maker,\\n                msg.sender,\\n                principalFilled\\n            )\\n        ) {\\n            revert Exception(8, 0, 0, address(0), address(0));\\n        }\\n\\n        // transfer fee in vault notional to swivel (from msg.sender)\\n        uint256 fee = principalFilled / feenominators[2];\\n        if (\\n            !mPlace.transferVaultNotionalFee(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                fee\\n            )\\n        ) {\\n            revert Exception(10, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Initiate(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            principalFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\\n    /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (principal) being filled by the taker's initiate\\n    /// @param c Components of a valid ECDSA signature\\n    function initiateZcTokenFillingVaultInitiate(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.principal) {\\n            revert Exception(5, amount, o.principal, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n\\n        uint256 premiumFilled = (a * o.premium) / o.principal;\\n        Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\\n\\n        // transfer principal + fee in underlying to swivel (from sender)\\n        uint256 fee = premiumFilled / feenominators[0];\\n        Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\\n\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        address cTokenAddr = mPlace.cTokenAddress(\\n            o.protocol,\\n            o.underlying,\\n            o.maturity\\n        );\\n\\n        // perform the actual deposit type transaction, specific to a protocol\\n        if (!deposit(o.protocol, o.underlying, cTokenAddr, a)) {\\n            revert Exception(6, 0, 0, address(0), address(0));\\n        }\\n\\n        // alert marketplace\\n        if (\\n            !mPlace.custodialInitiate(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                o.maker,\\n                a\\n            )\\n        ) {\\n            revert Exception(8, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Initiate(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            premiumFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\\n    /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (principal) being filled by the taker's initiate\\n    /// @param c Components of a valid ECDSA signature\\n    function initiateZcTokenFillingZcTokenExit(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.principal) {\\n            revert Exception(5, amount, o.principal, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        uint256 premiumFilled = (a * o.premium) / o.principal;\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n        // transfer underlying tokens, then take fee\\n        Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\\n\\n        uint256 fee = premiumFilled / feenominators[0];\\n        Safe.transferFrom(uToken, msg.sender, address(this), fee);\\n\\n        // alert marketplace\\n        if (\\n            !IMarketPlace(marketPlace).p2pZcTokenExchange(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                o.maker,\\n                msg.sender,\\n                a\\n            )\\n        ) {\\n            revert Exception(11, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Initiate(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            premiumFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\\n    /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (interest) being filled by the taker's exit\\n    /// @param c Components of a valid ECDSA signature\\n    function initiateVaultFillingVaultExit(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.premium) {\\n            revert Exception(5, amount, o.premium, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        Safe.transferFrom(IERC20(o.underlying), msg.sender, o.maker, a);\\n\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        uint256 principalFilled = (a * o.principal) / o.premium;\\n        // alert marketplace\\n        if (\\n            !mPlace.p2pVaultExchange(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                o.maker,\\n                msg.sender,\\n                principalFilled\\n            )\\n        ) {\\n            revert Exception(12, 0, 0, address(0), address(0));\\n        }\\n\\n        // transfer fee (in vault notional) to swivel\\n        uint256 fee = principalFilled / feenominators[2];\\n        if (\\n            !mPlace.transferVaultNotionalFee(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                fee\\n            )\\n        ) {\\n            revert Exception(10, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Initiate(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            principalFilled\\n        );\\n    }\\n\\n    // ********* EXITING ***************\\n\\n    /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\\n    /// @param o Array of offline Swivel.Orders\\n    /// @param a Array of order volume (principal) amounts relative to passed orders\\n    /// @param c Components of a valid ECDSA signature\\n    function exit(\\n        Hash.Order[] calldata o,\\n        uint256[] calldata a,\\n        Sig.Components[] calldata c\\n    ) external returns (bool) {\\n        // for each order filled, routes the order to the right interaction depending on its params\\n        for (uint256 i; i != o.length; ) {\\n            // if the order being filled is not an exit\\n            if (!o[i].exit) {\\n                // if the order being filled is a vault initiate or a zcToken initiate\\n                if (!o[i].vault) {\\n                    // if filling a zcToken initiate with an exit, one is exiting zcTokens\\n                    exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\\n                } else {\\n                    // if filling a vault initiate with an exit, one is exiting vault notional\\n                    exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\\n                }\\n            } else {\\n                // if the order being filled is a vault exit or a zcToken exit\\n                if (!o[i].vault) {\\n                    // if filling a zcToken exit with an exit, one is exiting vault\\n                    exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\\n                } else {\\n                    // if filling a vault exit with an exit, one is exiting zcTokens\\n                    exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\\n    /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (interest) being filled by the taker's exit\\n    /// @param c Components of a valid ECDSA signature\\n    function exitZcTokenFillingZcTokenInitiate(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.premium) {\\n            revert Exception(5, amount, o.premium, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n\\n        uint256 principalFilled = (a * o.principal) / o.premium;\\n        // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\\n        Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\\n\\n        // transfer fee in underlying to swivel\\n        uint256 fee = principalFilled / feenominators[1];\\n\\n        Safe.transferFrom(uToken, msg.sender, address(this), fee);\\n\\n        // alert marketplace\\n        if (\\n            !IMarketPlace(marketPlace).p2pZcTokenExchange(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                o.maker,\\n                principalFilled\\n            )\\n        ) {\\n            revert Exception(11, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Exit(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            principalFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\\n    /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (principal) being filled by the taker's exit\\n    /// @param c Components of a valid ECDSA signature\\n    function exitVaultFillingVaultInitiate(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.principal) {\\n            revert Exception(5, amount, o.principal, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n\\n        // transfer premium from maker to sender\\n        uint256 premiumFilled = (a * o.premium) / o.principal;\\n        Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\\n\\n        uint256 fee = premiumFilled / feenominators[3];\\n        // transfer fee in underlying to swivel from sender\\n        Safe.transferFrom(uToken, msg.sender, address(this), fee);\\n\\n        // transfer <a> notional from sender to maker\\n        if (\\n            !IMarketPlace(marketPlace).p2pVaultExchange(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                o.maker,\\n                a\\n            )\\n        ) {\\n            revert Exception(12, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Exit(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            premiumFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\\n    /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (principal) being filled by the taker's exit\\n    /// @param c Components of a valid ECDSA signature\\n    function exitVaultFillingZcTokenExit(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.principal) {\\n            revert Exception(5, amount, o.principal, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        // redeem underlying on Compound and burn cTokens\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        address cTokenAddr = mPlace.cTokenAddress(\\n            o.protocol,\\n            o.underlying,\\n            o.maturity\\n        );\\n\\n        if (!withdraw(o.protocol, o.underlying, cTokenAddr, a)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n        // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\\n        uint256 premiumFilled = (a * o.premium) / o.principal;\\n        Safe.transfer(uToken, o.maker, a - premiumFilled);\\n\\n        // transfer premium-fee to floating exit party\\n        uint256 fee = premiumFilled / feenominators[3];\\n        Safe.transfer(uToken, msg.sender, premiumFilled - fee);\\n\\n        // burn zcTokens + nTokens from o.maker and msg.sender respectively\\n        if (\\n            !mPlace.custodialExit(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                o.maker,\\n                msg.sender,\\n                a\\n            )\\n        ) {\\n            revert Exception(9, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Exit(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            premiumFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\\n    /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\\n    /// @param o Order being filled\\n    /// @param a Amount of volume (interest) being filled by the taker's exit\\n    /// @param c Components of a valid ECDSA signature\\n    function exitZcTokenFillingVaultExit(\\n        Hash.Order calldata o,\\n        uint256 a,\\n        Sig.Components calldata c\\n    ) internal {\\n        bytes32 hash = validOrderHash(o, c);\\n        uint256 amount = a + filled[hash];\\n\\n        if (amount > o.premium) {\\n            revert Exception(5, amount, o.premium, address(0), address(0));\\n        }\\n\\n        filled[hash] = amount;\\n\\n        // redeem underlying on Compound and burn cTokens\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        address cTokenAddr = mPlace.cTokenAddress(\\n            o.protocol,\\n            o.underlying,\\n            o.maturity\\n        );\\n        uint256 principalFilled = (a * o.principal) / o.premium;\\n\\n        if (!withdraw(o.protocol, o.underlying, cTokenAddr, principalFilled)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        IERC20 uToken = IERC20(o.underlying);\\n        // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\\n        uint256 fee = principalFilled / feenominators[1];\\n        Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\\n        Safe.transfer(uToken, o.maker, a);\\n\\n        // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\\n        if (\\n            !mPlace.custodialExit(\\n                o.protocol,\\n                o.underlying,\\n                o.maturity,\\n                msg.sender,\\n                o.maker,\\n                principalFilled\\n            )\\n        ) {\\n            revert Exception(9, 0, 0, address(0), address(0));\\n        }\\n\\n        emit Exit(\\n            o.key,\\n            hash,\\n            o.maker,\\n            o.vault,\\n            o.exit,\\n            msg.sender,\\n            a,\\n            principalFilled\\n        );\\n    }\\n\\n    /// @notice Allows a user to cancel an order, preventing it from being filled in the future\\n    /// @param o Array of offline orders being cancelled\\n    function cancel(Hash.Order[] calldata o) external returns (bool) {\\n        for (uint256 i; i != o.length; ) {\\n            if (msg.sender != o[i].maker) {\\n                revert Exception(15, 0, 0, msg.sender, o[i].maker);\\n            }\\n\\n            bytes32 hash = Hash.order(o[i]);\\n            cancelled[hash] = true;\\n\\n            emit Cancel(o[i].key, hash);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    // ********* ADMINISTRATIVE ***************\\n\\n    /// @param a Address of a new admin\\n    function setAdmin(address a) external authorized(admin) returns (bool) {\\n        admin = a;\\n\\n        emit SetAdmin(a);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows the admin to schedule the withdrawal of tokens\\n    /// @param e Address of (ERC20) token to withdraw\\n    function scheduleWithdrawal(address e)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        uint256 when = block.timestamp + HOLD;\\n        withdrawals[e] = when;\\n\\n        emit ScheduleWithdrawal(e, when);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows the admin to schedule the approval of tokens\\n    /// @param e Address of (ERC20) token to approve\\n    /// @param a Address of the contract to approve\\n    function scheduleApproval(address e, address a)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        uint256 when = block.timestamp + HOLD;\\n        approvals[e][a] = when;\\n\\n        emit ScheduleApproval(e, a, when);\\n\\n        return true;\\n    }\\n\\n    /// @notice allows the admin to schedule a change to the fee denominators\\n    /// @param f array of length 4 holding values which suggest replacing any at the same index for the current feenominators\\n    function scheduleFeeChange(uint16[4] calldata f)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        uint256 when = block.timestamp + HOLD;\\n        feeChange = when;\\n\\n        emit ScheduleFeeChange(f, when);\\n\\n        return true;\\n    }\\n\\n    /// @notice Emergency function to block unplanned withdrawals\\n    /// @param e Address of token withdrawal to block\\n    function blockWithdrawal(address e)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        delete withdrawals[e];\\n\\n        emit BlockWithdrawal(e);\\n\\n        return true;\\n    }\\n\\n    /// @notice Emergency function to block unplanned approvals\\n    /// @param e Address of token approval to block\\n    /// @param a Address of the contract to block approval of\\n    function blockApproval(address e, address a)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        delete approvals[e][a];\\n\\n        emit BlockApproval(e, a);\\n\\n        return true;\\n    }\\n\\n    /// @notice Emergency function to block unplanned changes to fee structure\\n    function blockFeeChange() external authorized(admin) returns (bool) {\\n        delete feeChange;\\n\\n        emit BlockFeeChange();\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\\n    /// @param e Address of token to withdraw\\n    function withdraw(address e) external authorized(admin) returns (bool) {\\n        uint256 when = withdrawals[e];\\n\\n        if (when == 0) {\\n            revert Exception(16, 0, 0, address(0), address(0));\\n        }\\n\\n        if (block.timestamp < when) {\\n            revert Exception(17, block.timestamp, when, address(0), address(0));\\n        }\\n\\n        delete withdrawals[e];\\n\\n        IERC20 token = IERC20(e);\\n        Safe.transfer(token, admin, token.balanceOf(address(this)));\\n\\n        return true;\\n    }\\n\\n    /// @notice allows the admin to set new fee denominators\\n    /// @param f array of length 4 holding values which will replace any at the same index in the current feenominators\\n    /// @dev note that, since 0 values are allowable the way to leave a feenominator value unchanged is to pass the existing value\\n    function changeFee(uint16[4] calldata f)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        if (feeChange == 0) {\\n            revert Exception(35, 0, 0, address(0), address(0));\\n        }\\n\\n        if (block.timestamp < feeChange) {\\n            revert Exception(\\n                36,\\n                block.timestamp,\\n                feeChange,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        for (uint256 i; i != 4; ) {\\n            if (f[i] < MIN_FEENOMINATOR) {\\n                revert Exception(\\n                    18,\\n                    f[i],\\n                    MIN_FEENOMINATOR,\\n                    address(0),\\n                    address(0)\\n                );\\n            }\\n\\n            // as stated, only set a value different than what exists\\n            if (f[i] != feenominators[i]) {\\n                feenominators[i] = f[i];\\n                emit ChangeFee(i, f[i]);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        delete feeChange;\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows the admin to bulk approve given compounding addresses at the underlying token, saving marginal approvals,\\n    /// providing the holding period has been observed\\n    /// @param u array of underlying token addresses\\n    /// @param c array of compound token addresses\\n    function approveUnderlying(address[] calldata u, address[] calldata c)\\n        external\\n        authorized(admin)\\n        returns (bool)\\n    {\\n        if (u.length != c.length) {\\n            revert Exception(19, u.length, c.length, address(0), address(0));\\n        }\\n\\n        uint256 max = type(uint256).max;\\n\\n        for (uint256 i; i != u.length; ) {\\n            uint256 when = approvals[u[i]][c[i]];\\n\\n            if (when == 0) {\\n                revert Exception(38, 0, 0, address(0), address(0));\\n            }\\n\\n            if (block.timestamp < when) {\\n                revert Exception(\\n                    39,\\n                    block.timestamp,\\n                    when,\\n                    address(0),\\n                    address(0)\\n                );\\n            }\\n\\n            delete approvals[u[i]][c[i]];\\n            IERC20 uToken = IERC20(u[i]);\\n            Safe.approve(uToken, c[i], max);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    // ********* PROTOCOL UTILITY ***************\\n\\n    /// @notice Allows users to deposit underlying and in the process split it into/mint\\n    /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\\n    /// @param p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with this market pair\\n    /// @param m Maturity timestamp of this associated market\\n    /// @param a Amount of underlying being deposited\\n    function splitUnderlying(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint256 a\\n    ) external returns (bool) {\\n        IERC20 uToken = IERC20(u);\\n        Safe.transferFrom(uToken, msg.sender, address(this), a);\\n\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n\\n        // the underlying deposit is directed to the appropriate abstraction\\n        if (!deposit(p, u, mPlace.cTokenAddress(p, u, m), a)) {\\n            revert Exception(6, 0, 0, address(0), address(0));\\n        }\\n\\n        if (!mPlace.mintZcTokenAddingNotional(p, u, m, msg.sender, a)) {\\n            revert Exception(13, 0, 0, address(0), address(0));\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\\n    /// in the process \\\"combining\\\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\\n    /// @param p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with the market\\n    /// @param m Maturity timestamp of the market\\n    /// @param a Amount of zcTokens being redeemed\\n    function combineTokens(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint256 a\\n    ) external returns (bool) {\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n\\n        if (!mPlace.burnZcTokenRemovingNotional(p, u, m, msg.sender, a)) {\\n            revert Exception(14, 0, 0, address(0), address(0));\\n        }\\n\\n        if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), a)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        Safe.transfer(IERC20(u), msg.sender, a);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows MarketPlace to complete its contractual obligation as IRedeemer, redeeming zcTokens and withdrawing underlying\\n    /// @dev Note that this bubbles up from the zcToken instead of starting on Swivel (as per the ERC5095)\\n    /// @notice p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with this market pair\\n    /// @param c Compound token address associated with this market pair\\n    /// @param t Address of the user receiving the underlying tokens\\n    /// @param a Amount of underlying being redeemed\\n    function authRedeem(\\n        uint8 p,\\n        address u,\\n        address c,\\n        address t,\\n        uint256 a\\n    ) external authorized(marketPlace) returns (bool) {\\n        // redeem underlying from compounding\\n        if (!withdraw(p, u, c, a)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n        // transfer underlying back to msg.sender\\n        Safe.transfer(IERC20(u), t, a);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\\n    /// @param p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with the market\\n    /// @param m Maturity timestamp of the market\\n    /// @param a Amount of zcTokens being redeemed\\n    function redeemZcToken(\\n        uint8 p,\\n        address u,\\n        uint256 m,\\n        uint256 a\\n    ) external returns (bool) {\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        // call marketplace to determine the amount redeemed\\n        uint256 redeemed = mPlace.redeemZcToken(p, u, m, msg.sender, a);\\n        // redeem underlying from compounding\\n        if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        // transfer underlying back to msg.sender\\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\\n    /// @param p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with the market\\n    /// @param m Maturity timestamp of the market\\n    function redeemVaultInterest(\\n        uint8 p,\\n        address u,\\n        uint256 m\\n    ) external returns (bool) {\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        // call marketplace to determine the amount redeemed\\n        uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, msg.sender);\\n        // redeem underlying from compounding\\n        address cTokenAddr = mPlace.cTokenAddress(p, u, m);\\n\\n        if (!withdraw(p, u, cTokenAddr, redeemed)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        // transfer underlying back to msg.sender\\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\\n\\n        return true;\\n    }\\n\\n    /// @notice Allows Swivel to redeem any currently accrued interest (via MarketPlace)\\n    /// @param p Protocol Enum value associated with this market pair\\n    /// @param u Underlying token address associated with the market\\n    /// @param m Maturity timestamp of the market\\n    function redeemSwivelVaultInterest(\\n        uint8 p,\\n        address u,\\n        uint256 m\\n    ) external returns (bool) {\\n        IMarketPlace mPlace = IMarketPlace(marketPlace);\\n        // call marketplace to determine the amount redeemed\\n        uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, address(this));\\n        // redeem underlying from compounding\\n        if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) {\\n            revert Exception(7, 0, 0, address(0), address(0));\\n        }\\n\\n        // NOTE: for swivel redeem there is no transfer out as there is in redeemVaultInterest\\n\\n        return true;\\n    }\\n\\n    /// @notice Verifies the validity of an order and it's signature.\\n    /// @param o An offline Swivel.Order\\n    /// @param c Components of a valid ECDSA signature\\n    /// @return the hashed order.\\n    function validOrderHash(Hash.Order calldata o, Sig.Components calldata c)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 hash = Hash.order(o);\\n\\n        if (cancelled[hash]) {\\n            revert Exception(2, 0, 0, address(0), address(0));\\n        }\\n\\n        if (o.expiry < block.timestamp) {\\n            revert Exception(\\n                3,\\n                o.expiry,\\n                block.timestamp,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        address recovered = Sig.recover(Hash.message(domain, hash), c);\\n\\n        if (o.maker != recovered) {\\n            revert Exception(4, 0, 0, o.maker, recovered);\\n        }\\n\\n        return hash;\\n    }\\n\\n    /// @notice Use the Protocol Enum to direct deposit type transactions to their specific library abstraction\\n    /// @dev This functionality is an abstraction used by `IVFZI`, `IZFVI` and `splitUnderlying`\\n    /// @param p Protocol Enum Value\\n    /// @param u Address of an underlying token (used by Aave)\\n    /// @param c Compounding token address\\n    /// @param a Amount to deposit todo compounding or underlying?\\n    function deposit(\\n        uint8 p,\\n        address u,\\n        address c,\\n        uint256 a\\n    ) internal returns (bool) {\\n        if (p == uint8(Protocols.Compound) || p == uint8(Protocols.Rari)) {\\n            return ICompound(c).mint(a) == 0;\\n        } else if (p == uint8(Protocols.Yearn)) {\\n            // yearn vault api states that deposit returns shares as uint256\\n            return IYearn(c).deposit(a) >= 0;\\n        } else if (p == uint8(Protocols.Aave)) {\\n            // Aave deposit is void. NOTE the change in pattern here where our interface is not wrapping a compounding token directly, but\\n            // a specified protocol contract whose address we have set\\n            IAave(aaveAddr).deposit(u, a, address(this), 0);\\n            return true;\\n        } else if (p == uint8(Protocols.Euler)) {\\n            // Euler deposit is void.\\n            IEuler(c).deposit(0, a);\\n            return true;\\n        } else if (p == uint8(Protocols.Lido)) {\\n            return ILido(c).wrap(a) >= 0;\\n        } else {\\n            // we will allow protocol[0] to also function as a catchall for ERC4626\\n            // NOTE: deposit, as per the spec, returns 'shares' but it is unknown if 0 would revert, thus we'll check for 0 or greater\\n            return IERC4626(c).deposit(a, address(this)) >= 0;\\n        }\\n    }\\n\\n    /// @notice Use the Protocol Enum to direct withdraw type transactions to their specific library abstraction\\n    /// @dev This functionality is an abstraction used by `EVFZE`, `EZFVE`, `combineTokens`, `redeemZcToken` and `redeemVaultInterest`.\\n    /// Note that while there is an external method `withdraw` also on this contract the unique method signatures (and visibility)\\n    /// exclude any possible clashing\\n    /// @param p Protocol Enum Value\\n    /// @param u Address of an underlying token (used by Aave)\\n    /// @param c Compounding token address\\n    /// @param a Amount to withdraw\\n    function withdraw(\\n        uint8 p,\\n        address u,\\n        address c,\\n        uint256 a\\n    ) internal returns (bool) {\\n        if (p == uint8(Protocols.Compound) || p == uint8(Protocols.Rari)) {\\n            return ICompound(c).redeemUnderlying(a) == 0;\\n        } else if (p == uint8(Protocols.Yearn)) {\\n            // yearn vault api states that withdraw returns uint256\\n            // NOTE that we must use the price-per-share in Yearn to determine the correct number of underlying assets\\n            IYearn vault = IYearn(c);\\n            return vault.withdraw(a / vault.pricePerShare()) >= 0;\\n        } else if (p == uint8(Protocols.Aave)) {\\n            // Aave v2 docs state that withdraw returns uint256\\n            return IAave(aaveAddr).withdraw(u, a, address(this)) >= 0;\\n        } else if (p == uint8(Protocols.Euler)) {\\n            // Euler withdraw is void\\n            IEuler(c).withdraw(0, a);\\n            return true;\\n        } else if (p == uint8(Protocols.Lido)) {\\n            ILido wstEth = ILido(c);\\n            return wstEth.unwrap(wstEth.getWstETHByStETH(a)) >= 0;\\n        } else {\\n            // we will allow protocol[0] to also function as a catchall for ERC4626\\n            return IERC4626(c).withdraw(a, address(this), address(this)) >= 0;\\n        }\\n    }\\n\\n    modifier authorized(address a) {\\n        if (msg.sender != a) {\\n            revert Exception(0, 0, 0, msg.sender, a);\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Protocols.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\nenum Protocols {\\n    Erc4626,\\n    Compound,\\n    Rari,\\n    Yearn,\\n    Aave,\\n    Euler,\\n    Lido\\n}\\n\"\r\n    },\r\n    \"src/lib/Hash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.\\n  Also to produce / verify hashed and signed Orders.\\n  See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\\n  See/attribute https://github.com/0xProject/0x-monorepo/blob/development/contracts/utils/contracts/src/LibEIP712.sol\\n*/\\n\\nlibrary Hash {\\n    /// @dev struct represents the attributes of an offchain Swivel.Order\\n    struct Order {\\n        bytes32 key;\\n        uint8 protocol;\\n        address maker;\\n        address underlying;\\n        bool vault;\\n        bool exit;\\n        uint256 principal;\\n        uint256 premium;\\n        uint256 maturity;\\n        uint256 expiry;\\n    }\\n\\n    // EIP712 Domain Separator typeHash\\n    // keccak256(abi.encodePacked(\\n    //     'EIP712Domain(',\\n    //     'string name,',\\n    //     'string version,',\\n    //     'uint256 chainId,',\\n    //     'address verifyingContract',\\n    //     ')'\\n    // ));\\n    bytes32 internal constant DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    // EIP712 typeHash of an Order\\n    // keccak256(abi.encodePacked(\\n    //     'Order(',\\n    //     'bytes32 key,',\\n    //     'uint8 protocol,',\\n    //     'address maker,',\\n    //     'address underlying,',\\n    //     'bool vault,',\\n    //     'bool exit,',\\n    //     'uint256 principal,',\\n    //     'uint256 premium,',\\n    //     'uint256 maturity,',\\n    //     'uint256 expiry',\\n    //     ')'\\n    // ));\\n    bytes32 internal constant ORDER_TYPEHASH =\\n        0xbc200cfe92556575f801f821f26e6d54f6421fa132e4b2d65319cac1c687d8e6;\\n\\n    /// @param n EIP712 domain name\\n    /// @param version EIP712 semantic version string\\n    /// @param i Chain ID\\n    /// @param verifier address of the verifying contract\\n    function domain(\\n        string memory n,\\n        string memory version,\\n        uint256 i,\\n        address verifier\\n    ) internal pure returns (bytes32) {\\n        bytes32 hash;\\n\\n        assembly {\\n            let nameHash := keccak256(add(n, 32), mload(n))\\n            let versionHash := keccak256(add(version, 32), mload(version))\\n            let pointer := mload(64)\\n            mstore(pointer, DOMAIN_TYPEHASH)\\n            mstore(add(pointer, 32), nameHash)\\n            mstore(add(pointer, 64), versionHash)\\n            mstore(add(pointer, 96), i)\\n            mstore(add(pointer, 128), verifier)\\n            hash := keccak256(pointer, 160)\\n        }\\n\\n        return hash;\\n    }\\n\\n    /// @param d Type hash of the domain separator (see Hash.domain)\\n    /// @param h EIP712 hash struct (order for example)\\n    function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {\\n        bytes32 hash;\\n\\n        assembly {\\n            let pointer := mload(64)\\n            mstore(\\n                pointer,\\n                0x1901000000000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(add(pointer, 2), d)\\n            mstore(add(pointer, 34), h)\\n            hash := keccak256(pointer, 66)\\n        }\\n\\n        return hash;\\n    }\\n\\n    /// @param o A Swivel Order\\n    function order(Order calldata o) internal pure returns (bytes32) {\\n        // TODO assembly\\n        return\\n            keccak256(\\n                abi.encode(\\n                    ORDER_TYPEHASH,\\n                    o.key,\\n                    o.protocol,\\n                    o.maker,\\n                    o.underlying,\\n                    o.vault,\\n                    o.exit,\\n                    o.principal,\\n                    o.premium,\\n                    o.maturity,\\n                    o.expiry\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Sig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Sig {\\n    /// @dev ECDSA V,R and S components encapsulated here as we may not always be able to accept a bytes signature\\n    struct Components {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    error S();\\n    error V();\\n    error Length();\\n    error ZeroAddress();\\n\\n    /// @param h Hashed data which was originally signed\\n    /// @param c signature struct containing V,R and S\\n    /// @return The recovered address\\n    function recover(bytes32 h, Components calldata c)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        // EIP-2 and malleable signatures...\\n        // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\\n        if (\\n            uint256(c.s) >\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\n        ) {\\n            revert S();\\n        }\\n\\n        if (c.v != 27 && c.v != 28) {\\n            revert V();\\n        }\\n\\n        address recovered = ecrecover(h, c.v, c.r, c.s);\\n\\n        if (recovered == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        return recovered;\\n    }\\n\\n    /// @param sig Valid ECDSA signature\\n    /// @return v The verification bit\\n    /// @return r First 32 bytes\\n    /// @return s Next 32 bytes\\n    function split(bytes memory sig)\\n        internal\\n        pure\\n        returns (\\n            uint8,\\n            bytes32,\\n            bytes32\\n        )\\n    {\\n        if (sig.length != 65) {\\n            revert Length();\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Safe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\\npragma solidity ^0.8.13;\\n\\nimport {IERC20} from 'src/interfaces/IERC20.sol';\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary Safe {\\n    /*//////////////////////////////////////////////////////////////\\n                              CUSTOM ERRORS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    error ETHTransferFailed();\\n\\n    error TransferFailed();\\n\\n    error TransferFromFailed();\\n\\n    error ApproveFailed();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                0,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) {\\n            revert TransferFromFailed();\\n        }\\n    }\\n\\n    function transfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                0,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) {\\n            revert TransferFailed();\\n        }\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(\\n                0,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            )\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(\\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\\n                    iszero(returndatasize())\\n                ),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) {\\n            revert ApproveFailed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\n// methods requried on other contracts which are expected to, at least, implement the following:\\ninterface IERC20 {\\n    function approve(address, uint256) external returns (bool);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function balanceOf(address) external returns (uint256);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface IERC4626 {\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    /// @dev Converts the given 'assets' (uint256) to 'shares', returning that amount\\n    function convertToAssets(uint256) external view returns (uint256);\\n\\n    /// @dev The address of the underlying asset\\n    function asset() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwivel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\nimport 'src/lib/Hash.sol';\\nimport 'src/lib/Sig.sol';\\n\\n// the behavioral Swivel Interface, Implemented by Swivel.sol\\ninterface ISwivel {\\n    function initiate(\\n        Hash.Order[] calldata,\\n        uint256[] calldata,\\n        Sig.Components[] calldata\\n    ) external returns (bool);\\n\\n    function exit(\\n        Hash.Order[] calldata,\\n        uint256[] calldata,\\n        Sig.Components[] calldata\\n    ) external returns (bool);\\n\\n    function cancel(Hash.Order[] calldata) external returns (bool);\\n\\n    function setAdmin(address) external returns (bool);\\n\\n    function scheduleWithdrawal(address) external returns (bool);\\n\\n    function scheduleFeeChange(uint16[4] calldata) external returns (bool);\\n\\n    function blockWithdrawal(address) external returns (bool);\\n\\n    function blockFeeChange() external returns (bool);\\n\\n    function withdraw(address) external returns (bool);\\n\\n    function changeFee(uint16[4] calldata) external returns (bool);\\n\\n    function approveUnderlying(address[] calldata, address[] calldata)\\n        external\\n        returns (bool);\\n\\n    function splitUnderlying(\\n        uint8,\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (bool);\\n\\n    function combineTokens(\\n        uint8,\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (bool);\\n\\n    function authRedeem(\\n        uint8,\\n        address,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function redeemZcToken(\\n        uint8,\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (bool);\\n\\n    function redeemVaultInterest(\\n        uint8,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function redeemSwivelVaultInterest(\\n        uint8,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMarketPlace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface IMarketPlace {\\n    function setSwivel(address) external returns (bool);\\n\\n    function setAdmin(address) external returns (bool);\\n\\n    function createMarket(\\n        uint8,\\n        uint256,\\n        address,\\n        string memory,\\n        string memory\\n    ) external returns (bool);\\n\\n    function matureMarket(\\n        uint8,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function authRedeem(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (uint256);\\n\\n    function exchangeRate(uint8, address) external returns (uint256);\\n\\n    function rates(\\n        uint8,\\n        address,\\n        uint256\\n    ) external returns (uint256, uint256);\\n\\n    function transferVaultNotional(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // adds notional and mints zctokens\\n    function mintZcTokenAddingNotional(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // removes notional and burns zctokens\\n    function burnZcTokenRemovingNotional(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // returns the amount of underlying principal to send\\n    function redeemZcToken(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (uint256);\\n\\n    // returns the amount of underlying interest to send\\n    function redeemVaultInterest(\\n        uint8,\\n        address,\\n        uint256,\\n        address\\n    ) external returns (uint256);\\n\\n    // returns the cToken address for a given market\\n    function cTokenAddress(\\n        uint8,\\n        address,\\n        uint256\\n    ) external returns (address);\\n\\n    // EVFZE FF EZFVE call this which would then burn zctoken and remove notional\\n    function custodialExit(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // IVFZI && IZFVI call this which would then mint zctoken and add notional\\n    function custodialInitiate(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // IZFZE && EZFZI call this, tranferring zctoken from one party to another\\n    function p2pZcTokenExchange(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // IVFVE && EVFVI call this, removing notional from one party and adding to the other\\n    function p2pVaultExchange(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // IVFZI && IVFVE call this which then transfers notional from msg.sender (taker) to swivel\\n    function transferVaultNotionalFee(\\n        uint8,\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface IAave {\\n    function deposit(\\n        address,\\n        uint256,\\n        address,\\n        uint16\\n    ) external; // void\\n\\n    function withdraw(\\n        address,\\n        uint256,\\n        address\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface ICompound {\\n    function mint(uint256) external returns (uint256);\\n\\n    function redeemUnderlying(uint256) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IEuler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface IEuler {\\n    function deposit(uint256, uint256) external; // void\\n\\n    function withdraw(uint256, uint256) external; // void\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILido.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface ILido {\\n    function wrap(uint256) external returns (uint256);\\n\\n    function unwrap(uint256) external returns (uint256);\\n\\n    function getWstETHByStETH(uint256) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IYearn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.13;\\n\\ninterface IYearn {\\n    function deposit(uint256) external returns (uint256);\\n\\n    function withdraw(uint256) external returns (uint256);\\n\\n    function pricePerShare() external returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"m\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApproveFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"S\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"V\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"blocked\",\"type\":\"address\"}],\"name\":\"BlockApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BlockFeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"BlockWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangeFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"filled\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"filled\",\"type\":\"uint256\"}],\"name\":\"Initiate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"}],\"name\":\"ScheduleApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16[4]\",\"name\":\"proposal\",\"type\":\"uint16[4]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"}],\"name\":\"ScheduleFeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hold\",\"type\":\"uint256\"}],\"name\":\"ScheduleWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEENOMINATOR\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aaveAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"u\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"c\",\"type\":\"address[]\"}],\"name\":\"approveUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authRedeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"blockApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockFeeChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"blockWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order[]\",\"name\":\"o\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[4]\",\"name\":\"f\",\"type\":\"uint16[4]\"}],\"name\":\"changeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"combineTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domain\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order[]\",\"name\":\"o\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Sig.Components[]\",\"name\":\"c\",\"type\":\"tuple[]\"}],\"name\":\"exit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feenominators\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vault\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exit\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Hash.Order[]\",\"name\":\"o\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"a\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Sig.Components[]\",\"name\":\"c\",\"type\":\"tuple[]\"}],\"name\":\"initiate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeemSwivelVaultInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeemVaultInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"redeemZcToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"scheduleApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[4]\",\"name\":\"f\",\"type\":\"uint16[4]\"}],\"name\":\"scheduleFeeChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"scheduleWithdrawal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"p\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"splitUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Swivel", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000f13fc4065f3050812d0699fc22976e1bb883d1300000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}