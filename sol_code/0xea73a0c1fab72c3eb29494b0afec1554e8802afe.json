{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return interfaceId == type(IERC165).interfaceId;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n  uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(address addr) internal pure returns (string memory) {\r\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/cryptography/ECDSA.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n  enum RecoverError {\r\n    NoError,\r\n    InvalidSignature,\r\n    InvalidSignatureLength,\r\n    InvalidSignatureS,\r\n    InvalidSignatureV\r\n  }\r\n\r\n  function _throwError(RecoverError error) private pure {\r\n    if (error == RecoverError.NoError) {\r\n      return; // no error: do nothing\r\n    } else if (error == RecoverError.InvalidSignature) {\r\n      revert(\"ECDSA: invalid signature\");\r\n    } else if (error == RecoverError.InvalidSignatureLength) {\r\n      revert(\"ECDSA: invalid signature length\");\r\n    } else if (error == RecoverError.InvalidSignatureS) {\r\n      revert(\"ECDSA: invalid signature 's' value\");\r\n    } else if (error == RecoverError.InvalidSignatureV) {\r\n      revert(\"ECDSA: invalid signature 'v' value\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature` or error string. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   *\r\n   * Documentation for signature generation:\r\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address, RecoverError)\r\n  {\r\n    if (signature.length == 65) {\r\n      bytes32 r;\r\n      bytes32 s;\r\n      uint8 v;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      /// @solidity memory-safe-assembly\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        s := mload(add(signature, 0x40))\r\n        v := byte(0, mload(add(signature, 0x60)))\r\n      }\r\n      return tryRecover(hash, v, r, s);\r\n    } else {\r\n      return (address(0), RecoverError.InvalidSignatureLength);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature`. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   */\r\n  function recover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n   *\r\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address, RecoverError) {\r\n    bytes32 s = vs &\r\n      bytes32(\r\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n      );\r\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n    return tryRecover(hash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n   *\r\n   * _Available since v4.2._\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address, RecoverError) {\r\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n    // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n    //\r\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n    // these malleable signatures as well.\r\n    if (\r\n      uint256(s) >\r\n      0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n    ) {\r\n      return (address(0), RecoverError.InvalidSignatureS);\r\n    }\r\n    if (v != 27 && v != 28) {\r\n      return (address(0), RecoverError.InvalidSignatureV);\r\n    }\r\n\r\n    // If the signature is valid (and not malleable), return the signer address\r\n    address signer = ecrecover(hash, v, r, s);\r\n    if (signer == address(0)) {\r\n      return (address(0), RecoverError.InvalidSignature);\r\n    }\r\n\r\n    return (signer, RecoverError.NoError);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return\r\n      keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes memory s)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          \"\\x19Ethereum Signed Message:\\n\",\r\n          Strings.toString(s.length),\r\n          s\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Typed Data, created from a\r\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n   * to the one signed with the\r\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n   * JSON-RPC method as part of EIP-712.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/IAccessControl.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n  /**\r\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n   *\r\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n   * {RoleAdminChanged} not being emitted signaling this.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  event RoleAdminChanged(\r\n    bytes32 indexed role,\r\n    bytes32 indexed previousAdminRole,\r\n    bytes32 indexed newAdminRole\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is granted `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call, an admin role\r\n   * bearer except when using {AccessControl-_setupRole}.\r\n   */\r\n  event RoleGranted(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is revoked `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call:\r\n   *   - if using `revokeRole`, it is the admin role bearer\r\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n   */\r\n  event RoleRevoked(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function grantRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function revokeRole(bytes32 role, address account) external;\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   */\r\n  function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/AccessControl.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n  struct RoleData {\r\n    mapping(address => bool) members;\r\n    bytes32 adminRole;\r\n  }\r\n\r\n  mapping(bytes32 => RoleData) private _roles;\r\n\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n  /**\r\n   * @dev Modifier that checks that an account has a specific role. Reverts\r\n   * with a standardized message including the required role.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   *\r\n   * _Available since v4.1._\r\n   */\r\n  modifier onlyRole(bytes32 role) {\r\n    _checkRole(role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControl).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _roles[role].members[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n   * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n   *\r\n   * Format of the revert message is described in {_checkRole}.\r\n   *\r\n   * _Available since v4.6._\r\n   */\r\n  function _checkRole(bytes32 role) internal view virtual {\r\n    _checkRole(role, _msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `account` is missing `role`.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n   */\r\n  function _checkRole(bytes32 role, address account) internal view virtual {\r\n    if (!hasRole(role, account)) {\r\n      revert(\r\n        string(\r\n          abi.encodePacked(\r\n            \"AccessControl: account \",\r\n            Strings.toHexString(uint160(account), 20),\r\n            \" is missing role \",\r\n            Strings.toHexString(uint256(role), 32)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bytes32)\r\n  {\r\n    return _roles[role].adminRole;\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   */\r\n  function grantRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function revokeRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function renounceRole(bytes32 role, address account) public virtual override {\r\n    require(\r\n      account == _msgSender(),\r\n      \"AccessControl: can only renounce roles for self\"\r\n    );\r\n\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event. Note that unlike {grantRole}, this function doesn't perform any\r\n   * checks on the calling account.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   *\r\n   * [WARNING]\r\n   * ====\r\n   * This function should only be called from the constructor when setting\r\n   * up the initial roles for the system.\r\n   *\r\n   * Using this function in any other way is effectively circumventing the admin\r\n   * system imposed by {AccessControl}.\r\n   * ====\r\n   *\r\n   * NOTE: This function is deprecated in favor of {_grantRole}.\r\n   */\r\n  function _setupRole(bytes32 role, address account) internal virtual {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `adminRole` as ``role``'s admin role.\r\n   *\r\n   * Emits a {RoleAdminChanged} event.\r\n   */\r\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n    bytes32 previousAdminRole = getRoleAdmin(role);\r\n    _roles[role].adminRole = adminRole;\r\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   *\r\n   * May emit a {RoleGranted} event.\r\n   */\r\n  function _grantRole(bytes32 role, address account) internal virtual {\r\n    if (!hasRole(role, account)) {\r\n      _roles[role].members[account] = true;\r\n      emit RoleGranted(role, account, _msgSender());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * Internal function without access restriction.\r\n   *\r\n   * May emit a {RoleRevoked} event.\r\n   */\r\n  function _revokeRole(bytes32 role, address account) internal virtual {\r\n    if (hasRole(role, account)) {\r\n      _roles[role].members[account] = false;\r\n      emit RoleRevoked(role, account, _msgSender());\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/DecagonTimelock.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\nerror NotTokenOwner();\r\nerror InvalidSignature();\r\nerror NonceAlreadyUsed();\r\nerror ExpiredSignature();\r\n\r\ncontract DecagonTimelock is AccessControl {\r\n  address private signer;\r\n  IERC721 public decagon;\r\n\r\n  mapping(uint256 => uint256) private timelocks;\r\n  mapping(string => bool) public usedNonces;\r\n\r\n  event TokenLocked(\r\n    uint256 indexed tokenId,\r\n    uint256 indexed numberOfWeeks,\r\n    string nonce\r\n  );\r\n  event SignerUpdated(address indexed newSigner);\r\n\r\n  constructor(\r\n    address _signer,\r\n    address _decagon,\r\n    address[] memory admins_\r\n  ) {\r\n    decagon = IERC721(_decagon);\r\n    signer = _signer;\r\n\r\n    for (uint256 i = 0; i < admins_.length; i++) {\r\n      _grantRole(DEFAULT_ADMIN_ROLE, admins_[i]);\r\n    }\r\n  }\r\n\r\n  modifier onlyTokenOwner(uint256 tokenId) {\r\n    if (decagon.ownerOf(tokenId) != msg.sender) revert NotTokenOwner();\r\n    _;\r\n  }\r\n\r\n  function updateSigner(address newSigner)\r\n    external\r\n    onlyRole(DEFAULT_ADMIN_ROLE)\r\n  {\r\n    signer = newSigner;\r\n    emit SignerUpdated(newSigner);\r\n  }\r\n\r\n  function removeTimelock(uint256 tokenId)\r\n    external\r\n    onlyRole(DEFAULT_ADMIN_ROLE)\r\n  {\r\n    timelocks[tokenId] = 0;\r\n  }\r\n\r\n  function beforeTransferLogic(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external view {\r\n    require(!isTimelocked(tokenId), \"Decagon: Timelocked token\");\r\n  }\r\n\r\n  function isTimelocked(uint256 tokenId) public view returns (bool) {\r\n    return block.timestamp < timelocks[tokenId];\r\n  }\r\n\r\n  function timelockExpiresAt(uint256 tokenId) external view returns (uint256) {\r\n    return timelocks[tokenId];\r\n  }\r\n\r\n  function lockToken(\r\n    uint256 tokenId,\r\n    uint256 numberOfWeeks,\r\n    string memory nonce,\r\n    uint256 expiryBlock,\r\n    bytes memory signature\r\n  ) external onlyTokenOwner(tokenId) {\r\n    if (usedNonces[nonce]) revert NonceAlreadyUsed();\r\n\r\n    if (block.number > expiryBlock) revert ExpiredSignature();\r\n\r\n    if (\r\n      !verify(\r\n        keccak256(\r\n          abi.encodePacked(\r\n            msg.sender,\r\n            tokenId,\r\n            numberOfWeeks,\r\n            nonce,\r\n            expiryBlock,\r\n            address(this)\r\n          )\r\n        ),\r\n        signature\r\n      )\r\n    ) revert InvalidSignature();\r\n\r\n    usedNonces[nonce] = true;\r\n    uint256 expires = block.timestamp + (1 weeks * numberOfWeeks);\r\n    timelocks[tokenId] = expires;\r\n\r\n    emit TokenLocked(tokenId, numberOfWeeks, nonce);\r\n  }\r\n\r\n  function verify(bytes32 messageHash, bytes memory signature)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return\r\n      signer ==\r\n      ECDSA.recover(ECDSA.toEthSignedMessageHash(messageHash), signature);\r\n  }\r\n}\r\n\r\ninterface IERC721 {\r\n  function ownerOf(uint256 tokenId) external view returns (address);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_decagon\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"admins_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"numberOfWeeks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nonce\",\"type\":\"string\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"beforeTransferLogic\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decagon\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTimelocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfWeeks\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nonce\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"removeTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"timelockExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"updateSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"usedNonces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DecagonTimelock", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000083d685a90b1aa4c02a376b290956eb384e0f2566000000000000000000000000d93206bd0062cc054e397ecccdb8436c3fa5700e0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000300000000000000000000000070feeec90d37dc73d9ded8cfafd7ede3f697b70b000000000000000000000000d523545b49076807094c0718f5eba00c0ae72fd6000000000000000000000000f8709ee6a525be2e3419aa652ca25521c33f4c35", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75726d946e6b2734f4c1c6867bbbc6f2a93349080310b91d923dacfb39ecaa6c"}]}