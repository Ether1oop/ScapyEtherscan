{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function description() external view returns (string memory);\\r\\n\\r\\n    function version() external view returns (uint256);\\r\\n\\r\\n    function getRoundData(uint80 _roundId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint80 roundId,\\r\\n            int256 answer,\\r\\n            uint256 startedAt,\\r\\n            uint256 updatedAt,\\r\\n            uint80 answeredInRound\\r\\n        );\\r\\n\\r\\n    function latestRoundData()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint80 roundId,\\r\\n            int256 answer,\\r\\n            uint256 startedAt,\\r\\n            uint256 updatedAt,\\r\\n            uint80 answeredInRound\\r\\n        );\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"},\"IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IFactory {\\r\\n    function getPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        view\\r\\n        returns (address pair);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\"},\"IPair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IPair {\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n}\\r\\n\"},\"IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n}\\r\\n\"},\"RaffleCashier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./IPair.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IRouter.sol\\\";\\r\\nimport \\\"./IFactory.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./AggregatorV3Interface.sol\\\";\\r\\n\\r\\ncontract Owned {\\r\\n    address public owner;\\r\\n\\r\\n    event LogActualOwner(address sender, address oldOwner, address newOwner);\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function changeOwner(address newOwner)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(\\r\\n            newOwner != address(0x0),\\r\\n            \\\"You are not the owner of the contract.\\\"\\r\\n        );\\r\\n        owner = newOwner;\\r\\n        emit LogActualOwner(msg.sender, owner, newOwner);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract RaffleCashier is Owned {\\r\\n    IRouter public router;\\r\\n    address public usdToken;\\r\\n    address[] private adminUsers;\\r\\n    address public immutable WETH;\\r\\n    address public immutable FMON;\\r\\n    address public treasuryAddress;\\r\\n    address public megaVaultAddress;\\r\\n    address public xPresidentsVaultAddress;\\r\\n    uint256 public extraAmountToSend;\\r\\n    uint16 private constant MAX_ADMINS = 10;\\r\\n    mapping(address =\\u003e bool) private _isBot;\\r\\n    uint256 public feesAcumulatedForTreasuryInFMON;\\r\\n    uint256 public feesAcumulatedForMegaVaultInFMON;\\r\\n    uint256 public feesAcumulatedForXpresidentsVaultInFMON;\\r\\n    mapping(address =\\u003e bool) public isAdminUser;\\r\\n    uint256 public prizePercentageToWinner = 800; // --\\u003e ((Raffle total prize) - (Operator fees))\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    struct PlayersToReturnMoney {\\r\\n        address player;\\r\\n        address tokenUsedToPay;\\r\\n        uint256 tokenAmountPayed;\\r\\n    }\\r\\n\\r\\n    struct OperatorFees {\\r\\n        uint256 megaVault;\\r\\n        uint256 treasury;\\r\\n        uint256 xPresidentsVault;\\r\\n    }\\r\\n\\r\\n    struct RaffleOperator {\\r\\n        bool isRunning;\\r\\n        address raffleWinner;\\r\\n        uint256 prizeAmountInUSD;\\r\\n        bool isRaffleOperator;\\r\\n        uint256 minNumberOfPlayers;\\r\\n        uint256 currentNumOfRegisteredPlayers;\\r\\n        mapping(uint256 =\\u003e PlayersToReturnMoney) playersToReturnMoney;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e RaffleOperator) public raffleOperator;\\r\\n    // OperatorFees public operatorFees = OperatorFees (170, 15, 15);\\r\\n    OperatorFees public operatorFees = OperatorFees(850, 75, 75);\\r\\n\\r\\n    error TooManyAdminUsers();\\r\\n    error OwnerCantBeRemoved();\\r\\n    error AdminUsersCantBeEmpty();\\r\\n    error AdminUserAlreadyAdded();\\r\\n    error UserToRemoveIsNotAdmin();\\r\\n\\r\\n    event FeesChanged();\\r\\n    event AdminUserAdded(address indexed _adminUserAddress);\\r\\n    event AdminUserRemoved(address indexed _adminUserAddress);\\r\\n    event RaffleWinnerSetted(\\r\\n        address indexed _raffleOperator,\\r\\n        address indexed _winnerAddress\\r\\n    );\\r\\n\\r\\n    modifier onlyIfAdminUser() {\\r\\n        require(isAdminUser[msg.sender] == true, \\\"You are not authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIfRunning(address _raffleOperator) {\\r\\n        require(\\r\\n            raffleOperator[_raffleOperator].isRunning == true,\\r\\n            \\\"Unauthorized\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIfIsRaffleOperator(address _raffleOperator) {\\r\\n        require(\\r\\n            raffleOperator[_raffleOperator].isRaffleOperator == true \\u0026\\u0026\\r\\n                raffleOperator[_raffleOperator].isRunning == false,\\r\\n            \\\"Unauthorized\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _routerAddress,\\r\\n        address _treasuryAddress,\\r\\n        address _megaVaultAddress,\\r\\n        address _xPresidentsVaultAddress,\\r\\n        address _WETH,\\r\\n        address _FMON,\\r\\n        address _usdToken\\r\\n    ) {\\r\\n        owner = msg.sender;\\r\\n        adminUsers.push(msg.sender);\\r\\n        isAdminUser[msg.sender] = true;\\r\\n\\r\\n        IRouter _router = IRouter(_routerAddress);\\r\\n        router = _router;\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n        megaVaultAddress = _megaVaultAddress;\\r\\n        xPresidentsVaultAddress = _xPresidentsVaultAddress;\\r\\n        WETH = _WETH;\\r\\n        FMON = _FMON;\\r\\n        usdToken = _usdToken;\\r\\n        // priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e); // --\\u003e Goerli\\r\\n        priceFeed = AggregatorV3Interface(\\r\\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function isBot(address account) public view returns (bool _isABot) {\\r\\n        return _isBot[account];\\r\\n    }\\r\\n\\r\\n    function getCurrentAdminUsers()\\r\\n        external\\r\\n        view\\r\\n        onlyIfAdminUser\\r\\n        returns (address[] memory _currentAdminUsers)\\r\\n    {\\r\\n        return adminUsers;\\r\\n    }\\r\\n\\r\\n    function getIfUserIsAdmin(address userToCheck)\\r\\n        external\\r\\n        view\\r\\n        returns (bool _userIsAdmin)\\r\\n    {\\r\\n        return isAdminUser[userToCheck];\\r\\n    }\\r\\n\\r\\n    function getCurrentPriceOfTokenByETHInUSDC(address _tokenA)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 _currentPriceOfTokenWithoutDecimalsInUSD)\\r\\n    {\\r\\n        // tokenA always the token which we want to know the price\\r\\n        address _pair = IFactory(router.factory()).getPair(_tokenA, WETH);\\r\\n        uint256 decimalsUSDC = IERC20(usdToken).decimals();\\r\\n        uint256 decimalsToken0 = IERC20(IPair(_pair).token0()).decimals();\\r\\n        uint256 decimalsToken1 = IERC20(IPair(_pair).token1()).decimals();\\r\\n        (uint256 reserve0, uint256 reserve1, ) = IPair(_pair).getReserves();\\r\\n\\r\\n        uint256 currentToken0PriceWithoutDecimals = (1 *\\r\\n            10**decimalsToken0 *\\r\\n            reserve1) / reserve0; // --\\u003e For 1 FMON is this ETH\\r\\n        uint256 currentToken1PriceWithoutDecimals = (1 *\\r\\n            10**decimalsToken1 *\\r\\n            reserve0) / reserve1; // --\\u003e For 1 ETH is this FMON\\r\\n\\r\\n        uint256 currentETHPrice = uint256(getETHLatestPrice());\\r\\n        uint8 ETHPriceDecimals = getETHPriceDecimals();\\r\\n        uint256 currentPriceETHInUSD = currentETHPrice / 10**ETHPriceDecimals;\\r\\n        uint256 currentPriceETHInUSDWithoutDecimals = 1 *\\r\\n            10**decimalsUSDC *\\r\\n            currentPriceETHInUSD;\\r\\n\\r\\n        // If token0 is ETH, token1 is FMON\\r\\n        if (_tokenA == IPair(_pair).token0()) {\\r\\n            _currentPriceOfTokenWithoutDecimalsInUSD =\\r\\n                ((1 * 10**decimalsToken0) *\\r\\n                    currentPriceETHInUSDWithoutDecimals) /\\r\\n                currentToken1PriceWithoutDecimals;\\r\\n        } else if (_tokenA == IPair(_pair).token1()) {\\r\\n            _currentPriceOfTokenWithoutDecimalsInUSD =\\r\\n                ((1 * 10**decimalsToken1) *\\r\\n                    currentPriceETHInUSDWithoutDecimals) /\\r\\n                currentToken0PriceWithoutDecimals;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getETHLatestPrice() public view returns (int256) {\\r\\n        (, int256 price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function getETHPriceDecimals() public view returns (uint8) {\\r\\n        uint8 decimals = priceFeed.decimals();\\r\\n        return decimals;\\r\\n    }\\r\\n\\r\\n    function addAdminUser(address adminUserToAdd) external onlyOwner {\\r\\n        // Already maxed, cannot add any more admin users.\\r\\n        if (adminUsers.length == MAX_ADMINS) revert TooManyAdminUsers();\\r\\n        if (isAdminUser[adminUserToAdd] == true) revert AdminUserAlreadyAdded();\\r\\n\\r\\n        adminUsers.push(adminUserToAdd);\\r\\n        isAdminUser[adminUserToAdd] = true;\\r\\n\\r\\n        emit AdminUserAdded(adminUserToAdd);\\r\\n    }\\r\\n\\r\\n    function removeAdminUser(address adminUserToRemove)\\r\\n        external\\r\\n        onlyIfAdminUser\\r\\n    {\\r\\n        if (adminUsers.length == 1) revert AdminUsersCantBeEmpty();\\r\\n        if (adminUserToRemove == owner) revert OwnerCantBeRemoved();\\r\\n        if (!isAdminUser[adminUserToRemove]) revert UserToRemoveIsNotAdmin();\\r\\n\\r\\n        uint256 lastAdminUserIndex = adminUsers.length - 1;\\r\\n        for (uint256 i = 0; i \\u003c adminUsers.length; i++) {\\r\\n            if (adminUsers[i] == adminUserToRemove) {\\r\\n                address last = adminUsers[lastAdminUserIndex];\\r\\n                adminUsers[i] = last;\\r\\n                adminUsers.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        isAdminUser[adminUserToRemove] = false;\\r\\n        emit AdminUserRemoved(adminUserToRemove);\\r\\n    }\\r\\n\\r\\n    function addLiquidity(\\r\\n        address _tokenToAddLiquidity,\\r\\n        address _liquidityProvider,\\r\\n        uint256 _liquidityToAdd\\r\\n    ) external onlyOwner returns (bool _success) {\\r\\n        TransferHelper.safeTransferFrom(\\r\\n            _tokenToAddLiquidity,\\r\\n            _liquidityProvider,\\r\\n            address(this),\\r\\n            _liquidityToAdd\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address _tokenToRemoveLiquidity,\\r\\n        uint256 _liquidityToRemove,\\r\\n        address _liquidityReceiver\\r\\n    ) external onlyOwner returns (bool _removeLiquiditySuccess) {\\r\\n        TransferHelper.safeTransfer(\\r\\n            _tokenToRemoveLiquidity,\\r\\n            _liquidityReceiver,\\r\\n            _liquidityToRemove\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAntibot(address account, bool state) external onlyIfAdminUser {\\r\\n        require(_isBot[account] != state, \\\"Value already set\\\");\\r\\n        _isBot[account] = state;\\r\\n    }\\r\\n\\r\\n    function updateMegaVaultWallet(address newWallet) external onlyIfAdminUser {\\r\\n        require(megaVaultAddress != newWallet, \\\"Wallet already set\\\");\\r\\n        megaVaultAddress = newWallet;\\r\\n    }\\r\\n\\r\\n    function updateXPresidentsVaultWallet(address newWallet)\\r\\n        external\\r\\n        onlyIfAdminUser\\r\\n    {\\r\\n        require(xPresidentsVaultAddress != newWallet, \\\"Wallet already set\\\");\\r\\n        xPresidentsVaultAddress = newWallet;\\r\\n    }\\r\\n\\r\\n    function updateTreasuryWallet(address newWallet) external onlyIfAdminUser {\\r\\n        require(treasuryAddress != newWallet, \\\"Wallet already set\\\");\\r\\n        treasuryAddress = newWallet;\\r\\n    }\\r\\n\\r\\n    function setOperatorPercentages(\\r\\n        uint256 _prizePercentageToWinner,\\r\\n        uint256 _megaVault,\\r\\n        uint256 _treasury,\\r\\n        uint256 _xPresidentsVault\\r\\n    ) external onlyIfAdminUser {\\r\\n        require(\\r\\n            _prizePercentageToWinner +\\r\\n                _megaVault +\\r\\n                _treasury +\\r\\n                _xPresidentsVault ==\\r\\n                1000,\\r\\n            \\\"Bad Request\\\"\\r\\n        );\\r\\n\\r\\n        prizePercentageToWinner = _prizePercentageToWinner;\\r\\n        operatorFees.megaVault = _megaVault;\\r\\n        operatorFees.treasury = _treasury;\\r\\n        operatorFees.xPresidentsVault = _xPresidentsVault;\\r\\n\\r\\n        emit FeesChanged();\\r\\n    }\\r\\n\\r\\n    function setNewRaffleOperator(\\r\\n        address _raffleOperator,\\r\\n        uint256 _prizeAmountInUSD,\\r\\n        uint256 _minNumberOfPlayers\\r\\n    ) external onlyOwner returns (bool _success) {\\r\\n        raffleOperator[_raffleOperator].isRunning = true;\\r\\n        raffleOperator[_raffleOperator].isRaffleOperator = true;\\r\\n        raffleOperator[_raffleOperator].currentNumOfRegisteredPlayers = 0;\\r\\n        raffleOperator[_raffleOperator].prizeAmountInUSD = _prizeAmountInUSD;\\r\\n        raffleOperator[_raffleOperator]\\r\\n            .minNumberOfPlayers = _minNumberOfPlayers;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function buyTicketsToPlay(\\r\\n        uint256 _amountToBuyTickets,\\r\\n        address _tokenToUseToBuyTickets\\r\\n    ) public payable returns (bool _success) {\\r\\n        TransferHelper.safeTransferFrom(\\r\\n            _tokenToUseToBuyTickets,\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _amountToBuyTickets\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setPlayersToReturnMoney(\\r\\n        address _raffleOperator,\\r\\n        address _player,\\r\\n        address _tokenUsedToPay,\\r\\n        uint256 _tokenAmountPayed\\r\\n    )\\r\\n        public\\r\\n        onlyIfAdminUser\\r\\n        onlyIfIsRaffleOperator(_raffleOperator)\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        uint256 currentNumOfRegisteredPlayers = raffleOperator[_raffleOperator]\\r\\n            .currentNumOfRegisteredPlayers;\\r\\n        require(\\r\\n            currentNumOfRegisteredPlayers \\u003c\\r\\n                raffleOperator[_raffleOperator].minNumberOfPlayers,\\r\\n            \\\"Bad Request\\\"\\r\\n        );\\r\\n\\r\\n        raffleOperator[_raffleOperator].currentNumOfRegisteredPlayers++;\\r\\n        raffleOperator[_raffleOperator]\\r\\n            .playersToReturnMoney[currentNumOfRegisteredPlayers]\\r\\n            .player = _player;\\r\\n        raffleOperator[_raffleOperator]\\r\\n            .playersToReturnMoney[currentNumOfRegisteredPlayers]\\r\\n            .tokenUsedToPay = _tokenUsedToPay;\\r\\n        raffleOperator[_raffleOperator]\\r\\n            .playersToReturnMoney[currentNumOfRegisteredPlayers]\\r\\n            .tokenAmountPayed = _tokenAmountPayed;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setRaffleOperatorWinner(\\r\\n        address _raffleOperator,\\r\\n        address _raffleWinnerPlayer\\r\\n    ) external onlyIfAdminUser returns (bool _success) {\\r\\n        raffleOperator[_raffleOperator].raffleWinner = _raffleWinnerPlayer;\\r\\n        raffleOperator[_raffleOperator].isRunning = false;\\r\\n\\r\\n        emit RaffleWinnerSetted(_raffleOperator, _raffleWinnerPlayer);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function distributeRaffleOperatorPrize(\\r\\n        address _raffleOperator,\\r\\n        address _raffleWinnerPlayer,\\r\\n        uint256 _operatorPrizeToDistributeInUSD // with decimals, USD\\r\\n    )\\r\\n        public\\r\\n        onlyIfAdminUser\\r\\n        onlyIfIsRaffleOperator(_raffleOperator)\\r\\n        returns (bool _transferSuccess)\\r\\n    {\\r\\n        require(\\r\\n            _raffleWinnerPlayer == raffleOperator[_raffleOperator].raffleWinner,\\r\\n            \\\"Unauthorized\\\"\\r\\n        );\\r\\n        require(\\r\\n            _operatorPrizeToDistributeInUSD \\u003c=\\r\\n                raffleOperator[_raffleOperator].prizeAmountInUSD,\\r\\n            \\\"Bad Request\\\"\\r\\n        );\\r\\n\\r\\n        uint256 currentPriceOfFMONByETHInUSDC = getCurrentPriceOfTokenByETHInUSDC(\\r\\n                FMON\\r\\n            );\\r\\n        uint256 decimalsFMON = IERC20(FMON).decimals();\\r\\n        uint256 decimalsUSDC = IERC20(usdToken).decimals();\\r\\n        uint256 currentFMONBalanceOfCashier = IERC20(FMON).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        uint256 operatorPriceToDistributeInFMON = ((_operatorPrizeToDistributeInUSD *\\r\\n                1 *\\r\\n                10**decimalsUSDC) * (1 * 10**decimalsFMON)) /\\r\\n                currentPriceOfFMONByETHInUSDC;\\r\\n        uint256 prizeToDeliverToWinnerInFMON = (operatorPriceToDistributeInFMON *\\r\\n                prizePercentageToWinner) / 1000;\\r\\n        uint256 prizeToDeliverToOperatorInFMON = operatorPriceToDistributeInFMON -\\r\\n                prizeToDeliverToWinnerInFMON;\\r\\n\\r\\n        if (currentFMONBalanceOfCashier \\u003c prizeToDeliverToWinnerInFMON) {\\r\\n            TransferHelper.safeTransfer(\\r\\n                FMON,\\r\\n                _raffleWinnerPlayer,\\r\\n                currentFMONBalanceOfCashier\\r\\n            );\\r\\n\\r\\n            extraAmountToSend =\\r\\n                prizeToDeliverToWinnerInFMON -\\r\\n                currentFMONBalanceOfCashier;\\r\\n            TransferHelper.safeTransferFrom(\\r\\n                FMON,\\r\\n                treasuryAddress,\\r\\n                _raffleWinnerPlayer,\\r\\n                extraAmountToSend\\r\\n            );\\r\\n        } else {\\r\\n            TransferHelper.safeTransfer(\\r\\n                FMON,\\r\\n                _raffleWinnerPlayer,\\r\\n                prizeToDeliverToWinnerInFMON\\r\\n            );\\r\\n        }\\r\\n\\r\\n        currentFMONBalanceOfCashier = IERC20(FMON).balanceOf(address(this)); // Updated balance\\r\\n\\r\\n        if (currentFMONBalanceOfCashier \\u003c prizeToDeliverToOperatorInFMON) {\\r\\n            sendFeesToOperator(currentFMONBalanceOfCashier);\\r\\n        } else {\\r\\n            sendFeesToOperator(prizeToDeliverToOperatorInFMON);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function sendFeesToOperator(uint256 _prizeToDeliverToOperatorInFMON)\\r\\n        internal\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        uint256 prizeToDeliverToTreasuryInFMON = (_prizeToDeliverToOperatorInFMON *\\r\\n                operatorFees.treasury) / 1000;\\r\\n        feesAcumulatedForTreasuryInFMON += prizeToDeliverToTreasuryInFMON;\\r\\n\\r\\n        uint256 prizeToDeliverToMegaVaultInFMON = (_prizeToDeliverToOperatorInFMON *\\r\\n                operatorFees.megaVault) / 1000;\\r\\n        feesAcumulatedForMegaVaultInFMON += prizeToDeliverToMegaVaultInFMON;\\r\\n\\r\\n        uint256 prizeToDeliverToXPresidentsVaultInFMON = (_prizeToDeliverToOperatorInFMON *\\r\\n                operatorFees.xPresidentsVault) / 1000;\\r\\n        feesAcumulatedForXpresidentsVaultInFMON += prizeToDeliverToXPresidentsVaultInFMON;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function cancelRaffleOperator(address _raffleOperator)\\r\\n        public\\r\\n        onlyOwner\\r\\n        onlyIfRunning(_raffleOperator)\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        uint256 currentNumOfRegisteredPlayers = raffleOperator[_raffleOperator]\\r\\n            .currentNumOfRegisteredPlayers;\\r\\n        require(\\r\\n            currentNumOfRegisteredPlayers \\u003c\\r\\n                raffleOperator[_raffleOperator].minNumberOfPlayers,\\r\\n            \\\"Bad Request\\\"\\r\\n        );\\r\\n\\r\\n        if (currentNumOfRegisteredPlayers \\u003e 0) {\\r\\n            returnMoneyToOwners(_raffleOperator);\\r\\n        }\\r\\n\\r\\n        raffleOperator[_raffleOperator].isRunning = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function returnMoneyToOwners(address _raffleOperator)\\r\\n        internal\\r\\n        onlyOwner\\r\\n        onlyIfRunning(_raffleOperator)\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        for (\\r\\n            uint256 i = 0;\\r\\n            i \\u003c raffleOperator[_raffleOperator].currentNumOfRegisteredPlayers;\\r\\n            ++i\\r\\n        ) {\\r\\n            TransferHelper.safeTransfer(\\r\\n                raffleOperator[_raffleOperator]\\r\\n                    .playersToReturnMoney[i]\\r\\n                    .tokenUsedToPay,\\r\\n                raffleOperator[_raffleOperator].playersToReturnMoney[i].player,\\r\\n                raffleOperator[_raffleOperator]\\r\\n                    .playersToReturnMoney[i]\\r\\n                    .tokenAmountPayed\\r\\n            );\\r\\n        }\\r\\n\\r\\n        raffleOperator[_raffleOperator].isRunning = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function distributeFeesToTreasury()\\r\\n        public\\r\\n        onlyOwner\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        TransferHelper.safeTransfer(\\r\\n            FMON,\\r\\n            treasuryAddress,\\r\\n            feesAcumulatedForTreasuryInFMON\\r\\n        );\\r\\n        feesAcumulatedForTreasuryInFMON = 0;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function distributeFeesToMegaVault()\\r\\n        public\\r\\n        onlyOwner\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        TransferHelper.safeTransfer(\\r\\n            FMON,\\r\\n            megaVaultAddress,\\r\\n            feesAcumulatedForMegaVaultInFMON\\r\\n        );\\r\\n        feesAcumulatedForMegaVaultInFMON = 0;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function distributeFeesToXPresidentsVault()\\r\\n        public\\r\\n        onlyOwner\\r\\n        returns (bool _success)\\r\\n    {\\r\\n        TransferHelper.safeTransfer(\\r\\n            FMON,\\r\\n            xPresidentsVaultAddress,\\r\\n            feesAcumulatedForXpresidentsVaultInFMON\\r\\n        );\\r\\n        feesAcumulatedForXpresidentsVaultInFMON = 0;\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity \\u003e=0.6.0;\\r\\n\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\r\\n        );\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\r\\n        );\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(\\r\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\r\\n        );\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(\\r\\n            success,\\r\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_megaVaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xPresidentsVaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_FMON\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdminUserAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AdminUsersCantBeEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerCantBeRemoved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyAdminUsers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserToRemoveIsNotAdmin\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adminUserAddress\",\"type\":\"address\"}],\"name\":\"AdminUserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adminUserAddress\",\"type\":\"address\"}],\"name\":\"AdminUserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LogActualOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_winnerAddress\",\"type\":\"address\"}],\"name\":\"RaffleWinnerSetted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FMON\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminUserToAdd\",\"type\":\"address\"}],\"name\":\"addAdminUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenToAddLiquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityToAdd\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountToBuyTickets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenToUseToBuyTickets\",\"type\":\"address\"}],\"name\":\"buyTicketsToPlay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"}],\"name\":\"cancelRaffleOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFeesToMegaVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFeesToTreasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFeesToXPresidentsVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_raffleWinnerPlayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_operatorPrizeToDistributeInUSD\",\"type\":\"uint256\"}],\"name\":\"distributeRaffleOperatorPrize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_transferSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraAmountToSend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAcumulatedForMegaVaultInFMON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAcumulatedForTreasuryInFMON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAcumulatedForXpresidentsVaultInFMON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentAdminUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_currentAdminUsers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"}],\"name\":\"getCurrentPriceOfTokenByETHInUSDC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentPriceOfTokenWithoutDecimalsInUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHLatestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHPriceDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToCheck\",\"type\":\"address\"}],\"name\":\"getIfUserIsAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_userIsAdmin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdminUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isABot\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"megaVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"treasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xPresidentsVault\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prizePercentageToWinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"raffleOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRunning\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"raffleWinner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmountInUSD\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRaffleOperator\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minNumberOfPlayers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentNumOfRegisteredPlayers\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminUserToRemove\",\"type\":\"address\"}],\"name\":\"removeAdminUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenToRemoveLiquidity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityToRemove\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_removeLiquiditySuccess\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAntibot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_prizeAmountInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minNumberOfPlayers\",\"type\":\"uint256\"}],\"name\":\"setNewRaffleOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prizePercentageToWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_megaVault\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasury\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_xPresidentsVault\",\"type\":\"uint256\"}],\"name\":\"setOperatorPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenUsedToPay\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountPayed\",\"type\":\"uint256\"}],\"name\":\"setPlayersToReturnMoney\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raffleOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_raffleWinnerPlayer\",\"type\":\"address\"}],\"name\":\"setRaffleOperatorWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateMegaVaultWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateXPresidentsVaultWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xPresidentsVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RaffleCashier", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000a6a22adb82c47747772f1fb6eacc5367fccfcfd200000000000000000000000087ec9d0fdda7d7300a563ca064c487d4d44a9e45000000000000000000000000ab7077e84d4153fc41d5fd8e86d96cbf7e738759000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d283ec9db7b3094ed5a2c87eb48d54f5fa96e96d000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ef40b74bfefb37ecbd32b46e915999ea46d498c0819a87a57ab84de524caf402"}]}