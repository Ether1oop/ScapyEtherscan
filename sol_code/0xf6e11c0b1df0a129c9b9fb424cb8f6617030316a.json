{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/IERC900.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC900 {\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n\r\n    function stake(uint256 amount, bytes memory data) external;\r\n    function stakeFor(address user, uint256 amount, bytes memory data) external;\r\n    function unstake(uint256 amount, bytes memory data) external;\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n    function totalStaked() external view returns (uint256);\r\n    function token() external view returns (address);\r\n    function supportsHistory() external pure returns (bool);\r\n\r\n    // optional\r\n    // function lastStakedFor(address addr) public view returns (uint256);\r\n    // function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256);\r\n    // function totalStakedAt(uint256 blockNumber) public view returns (uint256);\r\n}\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/SpiExtStaking.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract SpiExtStaking is IERC900 {\r\n    // Token used for staking\r\n    IERC20 stakingToken;\r\n\r\n    // The default duration of stake lock-in (in seconds)\r\n    uint256 public defaultLockInDuration;\r\n\r\n    // To save on gas, rather than create a separate mapping for totalStakedFor & personalStakes,\r\n    //  both data structures are stored in a single mapping for a given addresses.\r\n    //\r\n    // It's possible to have a non-existing personalStakes, but have tokens in totalStakedFor\r\n    //  if other users are staking on behalf of a given address.\r\n    mapping(address => StakeContract) public stakeHolders;\r\n\r\n    Income[] public incomes;\r\n\r\n    uint256 public totalStaked;\r\n\r\n    // Struct for personal stakes (i.e., stakes made by this address)\r\n    // unlockedTimestamp - when the stake unlocks (in seconds since Unix epoch)\r\n    // actualAmount - the amount of tokens in the stake\r\n    // stakedFor - the address the stake was staked for\r\n    struct Stake {\r\n        uint256 unlockedTimestamp;\r\n        uint256 actualAmount;\r\n        address stakedFor;\r\n    }\r\n\r\n    // Struct for all stake metadata at a particular address\r\n    // totalStakedFor - the number of tokens staked for this address\r\n    // personalStakeIndex - the index in the personalStakes array.\r\n    // personalStakes - append only array of stakes made by this address\r\n    // exists - whether or not there are stakes that involve this address\r\n    struct StakeContract {\r\n        uint256 totalStakedFor;\r\n\r\n        uint256 personalStakeIndex;\r\n\r\n        Stake[] personalStakes;\r\n\r\n        uint256 dividends;\r\n\r\n        uint256 paid;\r\n\r\n        uint incomeIndex;\r\n\r\n        bool exists;\r\n    }\r\n\r\n    struct Income {\r\n        uint256 amount;\r\n        uint256 remainingAmount;\r\n        uint256 totalStaked;\r\n    }\r\n\r\n    /**\r\n      Events\r\n    */\r\n    event IncomeAdded(address indexed user, uint256 amount);\r\n    event DividendsClaimed(address indexed user, uint256 amount);\r\n    /**\r\n     * @dev Modifier that checks that this contract can transfer tokens from the\r\n       *  balance in the stakingToken contract for the given address.\r\n       * @dev This modifier also transfers the tokens.\r\n       * @param _address address to transfer tokens from\r\n       * @param _amount uint256 the number of tokens\r\n       */\r\n    modifier canStake(address _address, uint256 _amount) {\r\n        require(stakingToken.transferFrom(_address, address(this), _amount), \"Stake required\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor function\r\n       * @param _stakingToken ERC20 The address of the token contract used for staking\r\n       */\r\n    constructor(IERC20 _stakingToken, uint256 _defaultLockInDuration) {\r\n      require(address(_stakingToken) != address(0), \"Staking token address can't be set to 0\");\r\n      require(_defaultLockInDuration > 0, \"Staking duration should be more than 0\");\r\n      stakingToken = _stakingToken;\r\n      defaultLockInDuration = _defaultLockInDuration;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the timestamps for when active personal stakes for an address will unlock\r\n       * @dev These accessors functions are needed until https://github.com/ethereum/web3.js/issues/1241 is solved\r\n       * @param _address address that created the stakes\r\n       * @return uint256[] array of timestamps\r\n       */\r\n    function getPersonalStakeUnlockedTimestamps(address _address) external view returns (uint256[] memory) {\r\n        uint256[] memory timestamps;\r\n        (timestamps,,) = getPersonalStakes(_address);\r\n\r\n        return timestamps;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the stake actualAmount for active personal stakes for an address\r\n       * @dev These accessors functions are needed until https://github.com/ethereum/web3.js/issues/1241 is solved\r\n       * @param _address address that created the stakes\r\n       * @return uint256[] array of actualAmounts\r\n       */\r\n    function getPersonalStakeActualAmounts(address _address) external view returns (uint256[] memory) {\r\n        uint256[] memory actualAmounts;\r\n        (, actualAmounts,) = getPersonalStakes(_address);\r\n\r\n        return actualAmounts;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addresses that each personal stake was created for by an address\r\n       * @dev These accessors functions are needed until https://github.com/ethereum/web3.js/issues/1241 is solved\r\n       * @param _address address that created the stakes\r\n       * @return address[] array of amounts\r\n       */\r\n    function getPersonalStakeForAddresses(address _address) external view returns (address[] memory) {\r\n        address[] memory stakedFor;\r\n        (,, stakedFor) = getPersonalStakes(_address);\r\n\r\n        return stakedFor;\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes a certain amount of tokens, this MUST transfer the given amount from the user\r\n       * @notice MUST trigger Staked event\r\n       * @param _amount uint256 the amount of tokens to stake\r\n       * @param _data bytes optional data to include in the Stake event\r\n       */\r\n    function stake(uint256 _amount, bytes memory _data) public override {\r\n        createStake(msg.sender, _amount, defaultLockInDuration, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes a certain amount of tokens, this MUST transfer the given amount from the caller\r\n       * @notice MUST trigger Staked event\r\n       * @param _user address the address the tokens are staked for\r\n       * @param _amount uint256 the amount of tokens to stake\r\n       * @param _data bytes optional data to include in the Stake event\r\n       */\r\n    function stakeFor(address _user, uint256 _amount, bytes memory _data) public override {\r\n        createStake(_user, _amount, defaultLockInDuration,_data);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert\r\n       * @notice MUST trigger Unstaked event\r\n       * @dev Unstaking tokens is an atomic operation\u2014either all of the tokens in a stake, or none of the tokens.\r\n       * @dev Users can only unstake a single stake at a time, it is must be their oldest active stake. Upon releasing that stake, the tokens will be\r\n       *  transferred back to their account, and their personalStakeIndex will increment to the next active stake.\r\n       * @param _amount uint256 the amount of tokens to unstake\r\n       * @param _data bytes optional data to include in the Unstake event\r\n       */\r\n    function unstake(uint256 _amount, bytes memory _data) public override {\r\n        withdrawStake(_amount,_data);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current total of tokens staked for an address\r\n       * @param _address address The address to query\r\n       * @return uint256 The number of tokens staked for the given address\r\n       */\r\n    function totalStakedFor(address _address) public override view returns (uint256) {\r\n        return stakeHolders[_address].totalStakedFor;\r\n    }\r\n\r\n    /**\r\n     * @notice Address of the token being used by the staking interface\r\n       * @return address The address of the ERC20 token used for staking\r\n       */\r\n    function token() public override view returns (address) {\r\n        return address(stakingToken);\r\n    }\r\n\r\n    /**\r\n     * @notice MUST return true if the optional history functions are implemented, otherwise false\r\n       * @dev Since we don't implement the optional interface, this always returns false\r\n       * @return bool Whether or not the optional history functions are implemented\r\n       */\r\n    function supportsHistory() public override pure returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get specific properties of all of the personal stakes created by an address\r\n       * @param _address address The address to query\r\n       * @return (uint256[], uint256[], address[])\r\n       *  timestamps array, actualAmounts array, stakedFor array\r\n       */\r\n    function getPersonalStakes(address _address) view public returns (uint256[] memory, uint256[] memory, address[] memory)\r\n    {\r\n        StakeContract storage stakeContract = stakeHolders[_address];\r\n\r\n        uint256 arraySize = stakeContract.personalStakes.length - stakeContract.personalStakeIndex;\r\n        uint256[] memory unlockedTimestamps = new uint256[](arraySize);\r\n        uint256[] memory actualAmounts = new uint256[](arraySize);\r\n        address[] memory stakedFor = new address[](arraySize);\r\n\r\n        for (uint i = stakeContract.personalStakeIndex; i < stakeContract.personalStakes.length; i++) {\r\n            uint index = i - stakeContract.personalStakeIndex;\r\n            unlockedTimestamps[index] = stakeContract.personalStakes[i].unlockedTimestamp;\r\n            actualAmounts[index] = stakeContract.personalStakes[i].actualAmount;\r\n            stakedFor[index] = stakeContract.personalStakes[i].stakedFor;\r\n        }\r\n\r\n        return (unlockedTimestamps, actualAmounts, stakedFor);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to create stakes for a given address\r\n       * @param _address address The address the stake is being created for\r\n       * @param _amount uint256 The number of tokens being staked\r\n       * @param _lockInDuration uint256 The duration to lock the tokens for\r\n       * @param _data bytes optional data to include in the Stake event\r\n       */\r\n    function createStake(address _address,uint256 _amount,uint256 _lockInDuration,bytes memory _data) internal canStake(msg.sender, _amount)\r\n    {\r\n        _createStake(_address, _amount, _lockInDuration, _data);\r\n    }\r\n\r\n    function stakeDividends(uint256 _amount, bytes memory _data) public {\r\n        require(getUnpaidDividends(msg.sender) >= _amount, \"Amount is greater than remaining dividends\");\r\n        _createStake(msg.sender, _amount, defaultLockInDuration, _data);\r\n        stakeHolders[msg.sender].paid += _amount;\r\n    }\r\n\r\n    function _createStake(address _address,uint256 _amount,uint256 _lockInDuration,bytes memory _data) private {\r\n        if (!stakeHolders[msg.sender].exists) {\r\n            stakeHolders[msg.sender].exists = true;\r\n        }\r\n\r\n        updateDividends(_address);\r\n\r\n        stakeHolders[_address].totalStakedFor += _amount;\r\n        stakeHolders[_address].personalStakes.push(Stake(block.timestamp + _lockInDuration,_amount,_address));\r\n\r\n        totalStaked +=_amount;\r\n\r\n        emit Staked(_address,_amount,totalStakedFor(_address),_data);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to withdraw stakes for the msg.sender\r\n       * @param _amount uint256 The amount to withdraw. MUST match the stake amount for the\r\n       *  stake at personalStakeIndex.\r\n       * @param _data bytes optional data to include in the Unstake event\r\n       */\r\n    function withdrawStake(uint256 _amount, bytes memory _data) internal {\r\n        require(stakeHolders[msg.sender].exists, \"The current address hasn't any stakes\");\r\n\r\n        Stake storage personalStake = stakeHolders[msg.sender].personalStakes[stakeHolders[msg.sender].personalStakeIndex];\r\n\r\n        // Check that the current stake has unlocked & matches the unstake amount\r\n        require(personalStake.unlockedTimestamp <= block.timestamp, \"The current stake hasn't unlocked yet\");\r\n\r\n        require( personalStake.actualAmount == _amount,\"The unstake amount does not match the current stake\");\r\n\r\n        // Transfer the staked tokens from this contract back to the sender\r\n        // Notice that we are using transfer instead of transferFrom here, so\r\n        //  no approval is needed beforehand.\r\n        require(stakingToken.transfer(msg.sender, _amount),\"Unable to withdraw stake\");\r\n\r\n        updateDividends(msg.sender);\r\n        stakeHolders[personalStake.stakedFor].totalStakedFor = stakeHolders[personalStake.stakedFor].totalStakedFor - personalStake.actualAmount;\r\n\r\n        personalStake.actualAmount = 0;\r\n        stakeHolders[msg.sender].personalStakeIndex++;\r\n\r\n        totalStaked -=_amount;\r\n\r\n        emit Unstaked(personalStake.stakedFor,_amount,totalStakedFor(personalStake.stakedFor),_data);\r\n    }\r\n\r\n    function withdrawDividends(uint256 _amount) external {\r\n        require(stakeHolders[msg.sender].exists, \"The current address hasn't any stakes\");\r\n        require(_amount <= getUnpaidDividends(msg.sender), \"Requested Amount exceed not paid erarings\");\r\n        stakeHolders[msg.sender].paid += _amount;\r\n        require(stakingToken.transfer(msg.sender, _amount),\"Unable to withdraw stake\");\r\n        emit DividendsClaimed(msg.sender, _amount);\r\n    }\r\n\r\n    function addIncome(uint256 _amount) public {\r\n      require(_amount > 0, 'Amount should be greater than 0');\r\n      require(stakingToken.transferFrom(msg.sender, address(this), _amount), 'Transfer of funds failed');\r\n      incomes.push(Income(_amount,_amount, this.totalStaked()));\r\n      emit IncomeAdded(msg.sender, _amount);\r\n    }\r\n\r\n    // View functions\r\n\r\n    function getUnpaidDividends(address _address) view public returns(uint256) {\r\n        uint256 dividends = getDividends(_address);\r\n        if(dividends > 0 && dividends >= stakeHolders[_address].paid) {\r\n          return dividends - stakeHolders[_address].paid;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function totalPaid(address _address) external view returns (uint256) {\r\n        return stakeHolders[_address].paid;\r\n    }\r\n\r\n    function getDividends(address _address) view public returns(uint256) {\r\n        if(stakeHolders[_address].exists) {\r\n          uint256 notAppliedDividendsAmountSum = calculateNotAppliedDividends(_address);\r\n          return stakeHolders[_address].dividends + notAppliedDividendsAmountSum;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    //Private Functions\r\n\r\n    function updateDividends(address _address) private {\r\n      uint256 notAppliedDividendsAmountSum = calculateNotAppliedDividends(_address);\r\n      stakeHolders[_address].dividends += notAppliedDividendsAmountSum;\r\n      stakeHolders[_address].incomeIndex = incomes.length;\r\n    }\r\n\r\n    function calculateNotAppliedDividends(address _address) view private returns(uint256) {\r\n        if(stakeHolders[_address].exists) {\r\n            if(incomes.length > 0 && stakeHolders[_address].incomeIndex < incomes.length) {\r\n                uint256 notAppliedDividendsAmount;\r\n                for(uint i = stakeHolders[_address].incomeIndex; i < incomes.length; i++) {\r\n                    notAppliedDividendsAmount += stakeHolders[_address].totalStakedFor * incomes[i].amount / incomes[i].totalStaked;\r\n                }\r\n                return notAppliedDividendsAmount;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_defaultLockInDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncomeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultLockInDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPersonalStakeActualAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPersonalStakeForAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPersonalStakeUnlockedTimestamps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPersonalStakes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUnpaidDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incomes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stakeDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedFor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"personalStakeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incomeIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsHistory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"totalPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SpiExtStaking", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000064b78325d7495d6d4be92f234fa3f3b8d8964b8b000000000000000000000000000000000000000000000000000000000076a700", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://47b95102d2195793d4819e5a599099ef72b9ffccd570373592add9ce1edfc47f"}]}