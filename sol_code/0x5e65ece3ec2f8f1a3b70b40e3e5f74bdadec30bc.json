{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0<0.9.0;\r\n\r\ninterface IERC20 {\r\n    function burn(uint256 _tokens) external;\r\n    function allowance(address, address) external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function approve(address _spender, uint256 _tokens) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IERC721 {\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n}\r\n\r\ninterface IClaimable {\r\n\tfunction claim() external;\r\n    function rewardsOf(address _user) external view returns (uint256);\r\n    function allInfoFor(address _owner) external view returns (uint256 supply, uint256 whales, uint256 balance, uint256 ownerWhales, uint256 fmRewards, uint256 whRewards, uint256 dailyKrill);\r\n    function getIsWhale(uint256 _tokenId) external view returns (bool);\r\n    function fishermenRewardsOf(address _owner) external view returns (uint256);\r\n    function whaleRewardsOf(address _owner) external view returns (uint256);\r\n    function deposit(uint256 _amount) external;\r\n    function withdraw() external returns (uint256);\r\n\tfunction dividendsOf(address _user) external view returns (uint256);\r\n    function depositedOf(address _user) external view returns (uint256);\r\n    function withdrawAll() external;\r\n}\r\n\r\ninterface IGuildRegistry {\r\n    function isGuild(address _who) external view returns (bool);\r\n    function throneChest(address _guild, address _throne) external view returns (address);\r\n}\r\n\r\ncontract RewardEngine {\r\n    bool public wrapperClaimOverride;\r\n\r\n    function _claimRewardsFromAll(address _staking, address _liquidity, address _whalesGame, address _wFM, address _wWH, address _cKRILL, uint _minimumKRILL, uint _minimumLP)\r\n    internal {\r\n        address _this = address(this);                                                          // shorthand\r\n        uint wgRewards =                                                                        // wg rewards are the sum of\r\n            IClaimable(_whalesGame).fishermenRewardsOf(_this) +                                     // fishermen rewards\r\n                IClaimable(_whalesGame).whaleRewardsOf(_this);                                          // whale rewards\r\n        uint LPBalance = IERC20(_liquidity).balanceOf(_this);                                   // load LP balance into memory\r\n        if(LPBalance >= _minimumLP)                                                             // are there any LP tokens?\r\n            IClaimable(_staking).deposit(LPBalance);                                                // deposit the entire amount into the StakingRewards contract\r\n        if(IClaimable(_staking).rewardsOf(_this) >= _minimumKRILL)                              // if there are pending LP staking rewards greater than or equal to the MINIMUM\r\n            IClaimable(_staking).claim();                                                            // Claim rewards from the LP staking contract\r\n        if(wgRewards >= _minimumKRILL)                                                          // if the pending rewards from the whales game contract is greater than or equal to MINIMUM\r\n\t\t    IClaimable(_whalesGame).claim();                                                        // Claim rewards from the whales game contract\r\n        if(IClaimable(_wFM).rewardsOf(_this) >= _minimumKRILL || wrapperClaimOverride == true)  // if the pending rewards from the whales game contract is greater than or equal to MINIMUM OR if the wrapper claim override is true\r\n\t\t    IClaimable(_wFM).claim();                                                               // Claim rewards from the fishermen wrapper contract\r\n        if(IClaimable(_wWH).rewardsOf(_this) >= _minimumKRILL || wrapperClaimOverride == true)  // if the pending rewards from the whales game contract is greater than or equal to MINIMUM OR if the wrapper claim override is true\r\n\t\t    IClaimable(_wWH).claim();                                                               // Claim rewards from the whales wrapper contract\r\n\t\tif(IClaimable(_cKRILL).dividendsOf(_this) >= _minimumKRILL)                             // If this contract has rewards to claim\r\n\t\t\tIClaimable(_cKRILL).withdraw();                                                         // Claim rewards from the cKRILL held by this contract\r\n    }\r\n    function _calculateKRILLToClaim(address _staking, address _whalesGame, address _wFM, address _wWH, address _cKRILL, address _KRILL, uint _minimum)\r\n    internal view returns (uint) {\r\n        address _this = address(this);                                                      // shorthand\r\n        uint total = IERC20(_KRILL).balanceOf(_this);                                       // current krill balance of this contract                                                      \r\n        uint wgRewards =                                                                    // wg rewards are the sum of\r\n            IClaimable(_whalesGame).fishermenRewardsOf(_this) +                                 // fishermen rewards\r\n                IClaimable(_whalesGame).whaleRewardsOf(_this);                                      // whale rewards\r\n        if(wgRewards >= _minimum)                                                           // if the pending rewards from the whales game contract is greater than or equal to MINIMUM\r\n            total += wgRewards;                                                                 // add the pending rewards to the total\r\n        if(IClaimable(_staking).rewardsOf(_this) >= _minimum)                               // if there are pending LP staking rewards greater than or equal to the MINIMUM\r\n            total += IClaimable(_staking).rewardsOf(_this);                                     // add the pending rewards to the total\r\n        if(IClaimable(_wFM).rewardsOf(_this) >= _minimum || wrapperClaimOverride == true)   // if the pending rewards from the wFM contract is greater than or equal to MINIMUM OR if the wrapper claim override is true\r\n            total += IClaimable(_wFM).rewardsOf(_this);                                         // rewards from wFM held\r\n        if(IClaimable(_wWH).rewardsOf(_this) >= _minimum || wrapperClaimOverride == true)   // if the pending rewards from the wWH contract is greater than or equal to MINIMUM OR if the wrapper claim override is true\r\n            total += IClaimable(_wWH).rewardsOf(_this);                                         // rewards from wWH held\r\n        if(IClaimable(_cKRILL).dividendsOf(_this) >= _minimum)                              // If this contract has rewards to claim\r\n            total += IClaimable(_cKRILL).dividendsOf(_this);                                    // pending compounder dividends\r\n        return total;                                                                       // return grand total\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    modifier _onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address _owner)\r\n    external _onlyOwner {\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\ninterface IWG {\r\n    function krillAddress() external view returns (address);\r\n    function pairAddress() external view returns (address);\r\n    function stakingRewardsAddress() external view returns (address);\r\n    function fishermenOf(address _owner) external view returns (uint256);\r\n    function whalesOf(address _owner) external view returns (uint256);\r\n}\r\n\r\ninterface IIsland {\r\n    function wrappedFishermenAddress() external view returns (address);\r\n    function wrappedWhalesAddress() external view returns (address);\r\n}\r\n\r\ninterface IKRILL2 {\r\n    function whalesGameAddress() external view returns (address);\r\n}\r\n\r\ncontract KRILLCommon is Ownable, RewardEngine {\r\n    address immutable public BURNER = address(0x000000000000000000000000000000000000dEaD);  // address of the BURNER - this is where burned tokens go\r\n    address immutable public KRILL;             // address of the KRILL token\r\n    address immutable public cKRILL;            // address of the cKRILL token\r\n    address immutable public wFM;               // address of the wFM token\r\n    address immutable public wWH;               // address of the wWH token                                                        \r\n    address immutable public whalesGame;        // address of the whales game contract\r\n    address immutable public staking;           // address of the LP staking contract\r\n    address immutable public liquidity;         // address of the LP token\r\n    uint public MINIMUM_KRILL = 1e18;           // minimum token threshold of 1 krill\r\n    uint public MINIMUM_LP = 1e18;              // minimum LP token threshold of 1 token\r\n\r\n    modifier claiming() {\r\n        _claimRewardsFromAll(staking, liquidity, whalesGame, wFM, wWH, cKRILL, MINIMUM_KRILL, MINIMUM_LP);  // claim rewards from reward sources \r\n        _;\r\n    }\r\n\r\n    constructor (address _cKRILL, address _KRILL, address _ISLAND) {\r\n        address whalesGame_ = IKRILL2(_KRILL).whalesGameAddress();      // get the address of the whales game contract\r\n        KRILL = IWG(whalesGame_).krillAddress();                        // get the KRILL address from the whales game contract\r\n        cKRILL = _cKRILL;                                               // address of the cKRILL token\r\n        wFM = IIsland(_ISLAND).wrappedFishermenAddress();               // address of the wFM token\r\n        wWH = IIsland(_ISLAND).wrappedWhalesAddress();                  // address of the wWH token\r\n        whalesGame = whalesGame_;                                       // set the whales game contract\r\n        address staking_ = IWG(whalesGame_).stakingRewardsAddress();    // get the LP staking contract address from the whales game contract\r\n        staking = staking_;                                             // set the LP staking contract\r\n        address liquidity_ = IWG(whalesGame_).pairAddress();            // get the LP address from the whales game contract\r\n        liquidity = liquidity_;                                         // set the LP token\r\n        IERC20(liquidity_).approve(staking_, type(uint256).max);        // approve the maximum amount of LP tokens for the staking contract\r\n    }\r\n\r\n    function _claimRewards()\r\n    internal claiming {}\r\n\r\n    function setMinimums(uint _krillMinimum, uint _LPMinimum)\r\n    external _onlyOwner {\r\n        require(_krillMinimum > 0);     // require that the krill minimum amount is greater than zero\r\n        require(_LPMinimum > 0);        // require that the LP minimum amount is greater than zero\r\n        MINIMUM_KRILL = _krillMinimum;  // set the minimum krill threshold\r\n        MINIMUM_LP = _LPMinimum;        // set the minimum LP threshold\r\n    }\r\n\r\n    function setWrapperClaimOverride(bool _override)\r\n    external _onlyOwner {\r\n        wrapperClaimOverride = _override;\r\n    }\r\n}\r\n\r\ninterface IWrapper {\r\n    function unwrap(uint256[] calldata _tokenIds) external returns (uint256 totalUnwrapped);\r\n}\r\n\r\ninterface IPermissionGate {\r\n    function viewGate(address _what) external view returns (bool);\r\n}\r\n\r\ncontract WrappedTokenBurner is KRILLCommon {\r\n    constructor (address _cKRILL, address _KRILL, address _ISLAND)\r\n    KRILLCommon(_cKRILL, _KRILL, _ISLAND) {}\r\n\r\n    function _unwrap(address _what)\r\n    internal {\r\n        uint[] memory IDs = new uint[](1);                                  // create array\r\n        uint tokenID = IERC721(whalesGame).tokenOfOwnerByIndex(_what, 0);   // get the token ID of the NFT\r\n        IDs[0] = tokenID;                                                   // add the token ID to the array\r\n        IWrapper(_what).unwrap(IDs);                                        // unwrap the tokens using the array of IDs\r\n    }\r\n\r\n    function burn(address _what)\r\n    external claiming {\r\n        require(_what == wFM || _what == wWH);                              // only allow burning of wFM or wWH tokens\r\n        address _this = address(this);                                      // shorthand\r\n        uint balance = IERC20(_what).balanceOf(_this);                      // load wFM balance into memory\r\n        require(balance >= 1e18);                                           // require that the balance is greater than or equal to the requested amount\r\n        _unwrap(_what);                                                     // unwrap the tokens\r\n        uint tokenID = IERC721(whalesGame).tokenOfOwnerByIndex(_this, 0);   // get the token ID of the NFT\r\n        IERC721(whalesGame).transferFrom(_this, BURNER, tokenID);           // transfer the NFT to the burn address\r\n        uint KRILLBalance = IERC20(KRILL).balanceOf(_this);                 // load the KRILL balance into memory\r\n        if(KRILLBalance > 0)                                                // if the KRILL balance is greater than 0\r\n            IERC20(KRILL).transfer(msg.sender, KRILLBalance);                   // transfer the KRILL balance to the sender as reward\r\n    }\r\n}\r\n\r\ncontract PermissionGate is Ownable {\r\n    address immutable public registry;          // address of the guild registry contract\r\n\r\n    mapping(address => bool) public allowed;    // mapping of addresses to boolean values indicating whether or not they are allowed by the permissiongate\r\n\r\n    constructor(address _registry) {\r\n        registry = _registry;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function toggleGate(address _what)\r\n    external _onlyOwner {\r\n        allowed[_what] = !allowed[_what];\r\n    }\r\n    function viewGate(address _what)\r\n    external view returns (bool) {\r\n        return (IGuildRegistry(registry).isGuild(_what) || allowed[_what]);\r\n    }\r\n}\r\n\r\ncontract ThroneCore is KRILLCommon {\r\n    struct EpochData {\r\n        address player;\r\n        address caller;\r\n        uint96 stamp;\r\n    }\r\n    \r\n    address immutable public input;                                 // address of the token to be burned\r\n    address public winner;                                          // address of the winner\r\n    address public permissionGate;                                  // address of the permission gate - a contract that determines which contracts can be granted permission to use other accounts' approvals to play\r\n    address public wrapperBurner;                                   // address of the wrapper burner\r\n    address public registry;                                        // address of the guild registry contract\r\n    address public feeDestination;                                  // address of the fee destination\r\n    address public secondThrone;                                    // address of the other Throne that this Throne feeds\r\n    address public islandThrone;                                    // address of the island Throne that this Throne feeds\r\n    bool public shutDown;                                           // flag to indicate if the throne is shut down - can only be shut down within two weeks of the throne starting\r\n    uint public startStamp;                                         // timestamp of when the throne is playable\r\n    uint public decayRate;                                          // decay rate of the throne input\r\n    uint public potFee = 0;                                         // fee percentage of the total reward\r\n    uint public epochCounter;                                       // current epoch counter\r\n    uint public playAmountCap;                                      // maximum amount of tokens that can be used to play per transaction\r\n    uint public totalRawScores;                                     // all-time total raw scores from all players\r\n    uint public totalBurned;                                        // all-time total burns\r\n    uint public totalPlayers;                                       // all-time total players\r\n    uint public winnerSlashRate;                                    // the score penalty to apply to the winner's score when non-winners play, based on the amount played by non-winners\r\n    uint public krillSupplyAtLaunch;                                // the total krill supply, tracked at launch\r\n    address[] public players;                                       // array of all players\r\n\r\n    mapping(address => uint) public entered;                        // total amount of tokens burned for a given address\r\n    mapping(address => uint) public last;                           // lastUsed timestamp of interaction for a given address\r\n    mapping(uint => EpochData) public epochs;                       // epoch data for a given epoch\r\n    mapping(address => uint) public rawScores;                      // \"raw\" score which has no decay and also includes score from playing \"for\" an entity such as a guild etc\r\n    mapping(address => mapping(address => bool)) public permission; // mapping of addresses to mapping of addresses to boolean values indicating whether or not they are allowed to use a player's tokens to play\r\n    mapping(address => mapping(address => uint)) public winnings;   // mapping of addresses to asset addresses to total winnings for that asset\r\n    mapping(address => uint) public totalWinnings;                  // mapping of assets to all-time total winnings for that asset\r\n    mapping(address => bool) public tracked;                        // mapping of addresses to boolean indicating if they are tracked as a player or not\r\n    mapping(address => uint) public controlTime;                    // mapping of addresses to uint tracking how long they've maintained control over the throne\r\n    mapping(address => uint) public rawScorePlayedForOthers;        // mapping of addresses to uint tracking the amount of their raw score that came from playing for others (guilds etc)\r\n\r\n    event ThroneTaken(uint indexed _epoch, address indexed _takenFrom, address indexed _takenBy);\r\n    event Played(uint indexed _epoch, address indexed _who, address indexed _from, uint _amount);\r\n\r\n    modifier onlyPlayable() {\r\n        require(decayRate > 0);                 // require that the decay rate is configured\r\n        require(startStamp > 0);                // require that the start stamp is configured\r\n        require(block.timestamp >= startStamp); // require that the block timestamp is greater than the start stamp\r\n        require(shutDown == false);             // require that the throne is not shut down\r\n        _;\r\n    }\r\n\r\n    constructor(address _input, address _cKRILL, address _KRILL, address _ISLAND)\r\n    KRILLCommon(_cKRILL, _KRILL, _ISLAND) {\r\n        input = _input;\r\n        krillSupplyAtLaunch = IERC20(_KRILL).totalSupply();\r\n    }\r\n\r\n    function _calcScore(address _who, uint _time)\r\n    internal view returns (uint) {\r\n        uint decayed = _time * decayRate;                               // linear decay\r\n        return decayed >= entered[_who] ? 0 : entered[_who] - decayed;  // the result can't be less than zero\r\n    }\r\n    function _calcTime(uint _now, uint _lastUsed, uint _winnerStamp)\r\n    internal pure returns (uint, uint) {\r\n        uint whoTime = _now - _lastUsed;        // the difference between now and when the contract was last used by an arbitrary account\r\n        uint winnerTime = _now - _winnerStamp;  // the difference between now and when the contract was last used by the winner\r\n        return (whoTime, winnerTime);           // return the differences\r\n    }\r\n    function _slashWinner(uint _amount)\r\n    internal {\r\n        uint time;                                                          // time delta for winner interaction\r\n        uint score;                                                         // winner score calculation\r\n        uint slashAmount;                                                   // how many tokens to remove from the winner's score\r\n        uint _now = block.timestamp;                                        // shorthand\r\n        (,time) = _calcTime(_now, 0, last[winner]);                         // calculate time delta for interaction\r\n        score = _calcScore(winner, time);                                   // calculate score\r\n        slashAmount = (_amount / 100) * winnerSlashRate;                    // calculate amount to slash from winner score (x/100% of input)\r\n        entered[winner] = score <= slashAmount ? 0 : score - slashAmount;   // update the winner's score - check for underflow\r\n        last[winner] = _now;                                                // update the winner's last interaction timestamp\r\n    }\r\n    function _calculateFee(uint _amount)\r\n    internal view returns (uint, uint) {\r\n        uint feeAmount;                         // amount to send to the fee destination\r\n        uint postFeeAmount;                     // amount after fee\r\n        feeAmount = (_amount / 100) * potFee;   // calculate fee amount\r\n        postFeeAmount = _amount - feeAmount;    // calculate post-fee amount\r\n        return (feeAmount, postFeeAmount);      // return the fee and post-fee amounts\r\n    }\r\n    function _nonZeroTransferAll(address _asset, address _to)\r\n    internal {\r\n        address _this = address(this);                                          // shorthand\r\n        uint balance = IERC20(_asset).balanceOf(_this);                         // load current token balance into memory\r\n        if(registry != address(0)) {                                            // if the guild registry is configured \r\n            bool isGuild = IGuildRegistry(registry).isGuild(_to);                   // determine if _to is a guild\r\n            _to = isGuild ? IGuildRegistry(registry).throneChest(_to, _this) : _to; // override _to if the destination address is a guild, the reward should go to the chest for that guild instead\r\n        }\r\n        if(balance > 100) {                                                     // if token balance can be taxed/is non-zero\r\n            if(potFee > 0) {                                                        // if the fee is enabled\r\n                (uint feeAmount, uint postFeeAmount) = _calculateFee(balance);          // calculate the fee amount\r\n                IERC20(_asset).transfer(_to, postFeeAmount);                            // transfer out current token balance to the winner\r\n                IERC20(_asset).transfer(feeDestination, feeAmount);                     // transfer the fee to the fee destination\r\n                winnings[_to][_asset] += postFeeAmount;                                 // update the winner's winnings\r\n                totalWinnings[_asset] += postFeeAmount;                                 // update the all-time total winnings\r\n            } else {                                                                // otherwise, the fee is disabled\r\n                IERC20(_asset).transfer(_to, balance);                                  // transfer out current token balance to the winner\r\n                winnings[_to][_asset] += balance;                                       // update the winner's winnings\r\n                totalWinnings[_asset] += balance;                                       // update the all-time total winnings\r\n            }\r\n        }\r\n    }\r\n    function _handleBurnTransfer(address _input, address _from, uint _amount)\r\n    internal {\r\n        if(_input == KRILL) {                                       // if the input is KRILL\r\n            address _this = address(this);                              // shorthand\r\n            uint burnAmount = _amount;                                  // amount to burn\r\n            if(_from != _this) {                                        // if this isnt being done via claimAndBurn()\r\n                uint before = IERC20(KRILL).balanceOf(_this);               // record current balance\r\n                IERC20(_input).transferFrom(_from, _this, _amount);         // transfer it to this contract\r\n                uint delta = IERC20(KRILL).balanceOf(_this) - before;       // record change in balance to take fee-on-transfer into account\r\n                burnAmount = delta;                                         // update the burn amount to be equal to the change in balance\r\n            }\r\n            IERC20(_input).burn(burnAmount);                            // burn the burn amount\r\n            totalBurned += burnAmount;                                  // increase the all-time total burned amount\r\n        } else if(_input == wFM || _input == wWH) {                     // otherwise, is the input a wrapped token?\r\n            IERC20(_input).transferFrom(_from, wrapperBurner, _amount);     // transfer to wraperburner address (to be burned)\r\n            totalBurned += _amount;                                         // increase the all-time total burned amount\r\n        } else {                                                        // otherwise\r\n            IERC20(_input).transferFrom(_from, BURNER, _amount);            // transfer to dead address (equivalent to burning)\r\n            totalBurned += _amount;                                         // increase the all-time total burned amount\r\n        }\r\n    }\r\n    function _handleOtherTransfers(address[2] memory _thrones, address _input, address _from, uint _amountEach)\r\n    internal {\r\n        address _this = address(this);                                                  // shorthand\r\n        for(uint x = 0; x < 2; x++)                                                     // for each throne address\r\n            if(_thrones[x] == address(0) || _thrones[x] == BURNER || _thrones[x] == _this)  // if the throne address is not configured, set to the burner, or this contract\r\n                _handleBurnTransfer(_input, _from, _amountEach);                                // handle the transfer as a burn\r\n            else                                                                            // otherwise\r\n                IERC20(_input).transferFrom(_from, _thrones[x], _amountEach);                   // transfer the tokens\r\n    }\r\n    function _handleFee(address _from, uint _totalAmount)\r\n    internal virtual {\r\n        address input_ = input;                                 // shorthand - save gas since it doesnt need to be loaded from storage more than once\r\n        uint burned = _totalAmount / 2;                         // burn 50%\r\n        uint other = burned / 2;                                // 25% to secondary Throne winner, 25% to island Throne winner\r\n        _handleBurnTransfer(input_, _from, burned);             // burn the input amount from _from\r\n        address[2] memory thrones;                              // create an array to hold the throne addresses\r\n        thrones[0] = secondThrone;                              // set the first element to the second throne address\r\n        thrones[1] = islandThrone;                              // set the second element to the island throne address\r\n        _handleOtherTransfers(thrones, input_, _from, other);   // transfer the other amount to the secondary and island throne\r\n    }\r\n    function _disperseRewards(address _winner)\r\n    internal virtual {\r\n        _nonZeroTransferAll(KRILL, _winner);    // transfer out all KRILL to _winner\r\n    }\r\n    function _enterFor(address _who, address _from, uint _amount, bool _ignoreTokens)\r\n    internal {\r\n        require(_amount <= playAmountCap);                              // require that the amount is less than or equal to the current play amount cap\r\n        address _this = address(this);                                  // shorthand\r\n        require(_who != address(0) && _who != _this && _who != BURNER); // require that _who is not the zero address, this contract, AND the 0x000...dEaD address\r\n        require(_amount > 0);                                           // require that the amount being entered is non-zero\r\n        if(_ignoreTokens == false)                                      // if we are not ignoring tokens\r\n            _handleFee(_from, _amount);                                     // handle the fee\r\n        _assumeControl(_who, _from, _amount);                           // attempt to assume control for _who\r\n        if(_who == _from || _from == _this)                             // if _who and _from are the same address OR if _from is this contract (claimAndBurn() is being called)\r\n            rawScores[_who] += _amount;                                     // log the raw score increase for _who\r\n        else {                                                          // otherwise, they are not (user is playing for another guild or entity)\r\n            rawScores[_from] += _amount;                                    // log the raw score increase for _from\r\n            rawScorePlayedForOthers[_from] += _amount;                      // log the raw score played for others for _from\r\n        }\r\n        totalRawScores += _amount;                                      // increase the all-time total raw scores\r\n        if(tracked[_who] == false) {                                    // if they arent tracked as a player yet\r\n            tracked[_who] = true;                                           // indicate that they are tracked\r\n            players.push(_who);                                             // add them to the player list\r\n            totalPlayers++;                                                 // increment total player tracker\r\n        }\r\n    }\r\n    function _logEpoch(address _who, address _from, uint _stamp)\r\n    internal {\r\n        if(epochCounter > 0) {                                      // if we are past the first epoch\r\n            EpochData memory data = epochs[epochCounter-1];             // load epoch data into memory\r\n            controlTime[data.player] += block.timestamp - data.stamp;   // increment their controlTime, which tracks the total amount of recorded time an entity has maintained control over the throne\r\n        }\r\n        epochs[epochCounter] = EpochData({                          // create a new epoch\r\n            player: _who,\r\n            caller: _from,\r\n            stamp: uint96(_stamp)\r\n        });\r\n        epochCounter++;                                             // increment the epoch counter\r\n    }\r\n    function _assumeControl(address _who, address _from, uint _amount)\r\n    internal {\r\n        uint whoTime;                                                       // time difference between last interaction and now for _who\r\n        uint winnerTime;                                                    // time difference between last interaction and now for winner\r\n        uint _now = block.timestamp;                                        // shorthand\r\n        if(last[_who] == 0)                                                 // if this is their first time interacting with the contract\r\n            last[_who] = _now;                                                  // their lastUsed timestamp needs to be set before calculating their current score to check against the requirement\r\n        (whoTime, winnerTime) = _calcTime(_now, last[_who], last[winner]);  // save the time differences for both _who and the winner in memory\r\n        entered[_who] = _calcScore(_who, whoTime) + _amount;                // increment the amount entered by _who based on the score calculation\r\n        last[_who] = _now;                                                  // update _who's timestamp indicating when they last used this contract\r\n        if(_who != winner) {                                                // if _who is not the winner\r\n            if(_amount > 10)                                                    // if the amount is greater than ten wei (10% slash rate)\r\n                _slashWinner(_amount);                                              // slash the winner's score                  \r\n            if(entered[_who] > _calcScore(winner, winnerTime)) {                // if they are the top player\r\n                if(winner != address(0))                                            // if the current winner is not 0x0\r\n                    claimForWinner();                                                   // claim for the \"old\" winner\r\n                emit ThroneTaken(epochCounter, winner, _who);                       // emit an event for the UI\r\n                winner = _who;                                                      // the winner is now _who\r\n                _logEpoch(_who, _from, _now);                                       // log the epoch, passing in the player (_from) and current timestamp\r\n            }                                                                       // ... this allows guild members to progress their own questline while playing for a guild\r\n        }\r\n        emit Played(epochCounter, _who, _from, _amount);                            // emit an event for the UI\r\n    }\r\n\r\n    function claimForWinner()\r\n    public onlyPlayable {\r\n        _claimRewards();            // claim rewards from all sources\r\n        _disperseRewards(winner);   // disperse the rewards for the winner\r\n    }\r\n}\r\n\r\ncontract ManagedThrone is ThroneCore {\r\n    constructor(address _input, address _cKRILL, address _KRILL, address _ISLAND)\r\n    ThroneCore(_input, _cKRILL, _KRILL, _ISLAND) {}\r\n\r\n    modifier andSweepKrill(address _to) {\r\n        _;\r\n        uint KRILLBalance = IERC20(KRILL).balanceOf(address(this)); // load KRILL balance\r\n        if(KRILLBalance > 0)                                        // if KRILL balance is greater than zero\r\n            IERC20(KRILL).transfer(_to, KRILLBalance);                  // transfer out the balance\r\n    }\r\n\r\n    function setGuildRegistry(address _registry)\r\n    external _onlyOwner {\r\n        registry = _registry;   // set the guild registry contract\r\n    }\r\n    function sweepOut(address _to)\r\n    external claiming _onlyOwner andSweepKrill(_to) {\r\n        require(shutDown == true);                              // require that the throne is shut down (due to misconfiguration etc)\r\n        address _this = address(this);                          // shorthand\r\n        uint wFMBalance = IERC20(wFM).balanceOf(_this);         // load wrapped fishermen balance\r\n        if(wFMBalance > 0)                                      // if wrapped fishermen balance is greater than zero\r\n            IERC20(wFM).transfer(_to, wFMBalance);                  // transfer out the balance\r\n        uint wWHBalance = IERC20(wWH).balanceOf(_this);         // load wrapped whales balance\r\n        if(wWHBalance > 0)                                      // if wrapped whales balance is greater than zero\r\n            IERC20(wWH).transfer(_to, wWHBalance);                  // transfer out the balance\r\n        uint cKRILLBalance = IERC20(cKRILL).balanceOf(_this);   // load cKRILL balance\r\n        if(cKRILLBalance > 0)                                   // if cKRILL balance is greater than zero\r\n            IERC20(cKRILL).transfer(_to, cKRILLBalance);            // transfer out the balance\r\n        uint LPStaked = IClaimable(staking).depositedOf(_this); // load LP tokens staked\r\n        if(LPStaked > 0)                                        // if LP token stake amount is greater than zero\r\n            IClaimable(staking).withdrawAll();                      // withdraw the balance\r\n        uint LPBalance = IERC20(liquidity).balanceOf(_this);    // load LP token balance\r\n        if(LPBalance > 0)                                       // if LP token balance is greater than zero\r\n            IERC20(liquidity).transfer(_to, LPBalance);             // transfer out the balance\r\n    }\r\n    function sweepOutNFTs(address _to)\r\n    external claiming _onlyOwner andSweepKrill(_to) {\r\n        require(shutDown == true);                                              // require that the throne is shut down (due to misconfiguration etc)\r\n        address _this = address(this);                                          // shorthand\r\n        uint NFTBalance = IERC20(whalesGame).balanceOf(_this);                  // load amount of NFTs held\r\n        for(uint x = 0; x < NFTBalance; x++) {                                  // for every NFT\r\n            uint tokenID = IERC721(whalesGame).tokenOfOwnerByIndex(_this, 0);       // load its ID\r\n            IERC721(whalesGame).transferFrom(_this, _to, tokenID);                  // transfer it out\r\n        }\r\n    }\r\n    function setFee(address _feeDestination, uint _feePercent)\r\n    external _onlyOwner {\r\n        require(_feeDestination != address(0)); // fee destination cannot be the zero address\r\n        require(_feePercent <= 100);            // fee percentage cannot be greater than 100%\r\n        feeDestination = _feeDestination;       // set the fee destination\r\n        potFee = _feePercent;                   // set the fee percentage\r\n    }\r\n    function setWrapperBurner(address _wrapperBurner)\r\n    external _onlyOwner {\r\n        require(wrapperBurner == address(0));   // require that the wrapper burner is not set yet\r\n        require(input == wFM || input == wWH);  // require that the input is either wFM or wWH\r\n        wrapperBurner = _wrapperBurner;         // set the wrapper burner\r\n    }\r\n    function setPermissionGate(address _permissionGate)\r\n    external _onlyOwner {\r\n        permissionGate = _permissionGate;   // set the permission gate, updatable at any time to maintain flexibility\r\n    }\r\n    function setStartStamp()\r\n    external _onlyOwner {\r\n        if(input == wFM || input == wWH)        // if the input is wFM or wWH     \r\n            require(wrapperBurner != address(0));   // require that the wrapper burner is set\r\n        require(startStamp == 0);               // cannot configure more than once\r\n        startStamp = block.timestamp;           // set the start stamp to now\r\n    }\r\n    function setDecayRate(uint _decayRate)\r\n    external _onlyOwner {\r\n        require(decayRate == 0);    // cannot configure more than once\r\n        decayRate = _decayRate;     // set the decay rate\r\n    }\r\n    function flipShutdownSwitch()\r\n    external _onlyOwner {\r\n        require(block.timestamp <= (startStamp + 30 days)); // cannot shutdown after 30 days. this should be enough time to tell if the throne is misconfigured or not (decay rate can be too high or too low etc)\r\n        shutDown = true;                                    // flip the shutdown switch\r\n    }\r\n    function setThrone(bool _secondOrIsland, address _throne)\r\n    external _onlyOwner {\r\n        if(_secondOrIsland == true) // if the throne is the second throne\r\n            secondThrone = _throne;     // set the second throne\r\n        else                        // if the throne is the island throne\r\n            islandThrone = _throne;     // set the island throne\r\n    }\r\n    function setPlayAmountCap(uint _amountCap)\r\n    external _onlyOwner {\r\n        playAmountCap = _amountCap;             // store the new value\r\n    }\r\n    function setWinnerSlashRate(uint _slashRate)\r\n    external _onlyOwner {\r\n        require(_slashRate <= 100);     // slash rate is 0-100%\r\n        winnerSlashRate = _slashRate;   // set the slash rate\r\n    }\r\n}\r\n\r\ncontract Throne is ManagedThrone {\r\n    address immutable public ISLAND;    // address of the ISLAND token\r\n\r\n    constructor(address _input, address _cKRILL, address _KRILL, address _ISLAND)\r\n    ManagedThrone(_input, _cKRILL, _KRILL, _ISLAND) {\r\n        address _this = address(this);  // shorthand\r\n        ISLAND = _ISLAND;               // set the ISLAND address\r\n        secondThrone = _this;           // set the second throne address\r\n        islandThrone = _this;           // set the island throne address\r\n    }\r\n\r\n    function _calcTotalPot()\r\n    internal view returns (uint) {\r\n        uint totalPot = _calculateKRILLToClaim(staking, whalesGame, wFM, wWH, cKRILL, KRILL, MINIMUM_KRILL);    // calculate the total pot\r\n        uint postFee;                                                                                           // post-fee total pot\r\n        if(potFee > 0) {                                                                                        // if the fee is enabled\r\n            (, postFee) = _calculateFee(totalPot);                                                                  // calculate the post-fee total pot\r\n            return postFee;                                                                                         // return the post-fee total pot\r\n        } else                                                                                                  // otherwise, the fee is disabled\r\n            return totalPot;                                                                                        // return the total pot\r\n    }\r\n    function _mostInfoFor(address _who)\r\n    internal view returns (uint userBalance, uint userAllowance, uint userScore, address currentWinner, uint winnerScore, uint dailyKrill, uint decayPerSecond) {\r\n        uint whoTime;                                                                   // time difference between last interaction and now for _who\r\n        uint winnerTime;                                                                // time difference between last interaction and now for winner\r\n        address _this = address(this);                                                  // shorthand\r\n        (whoTime, winnerTime) = _calcTime(block.timestamp, last[_who], last[winner]);   // save the time differences for both _who and the winner in memory\r\n        userBalance = IERC20(input).balanceOf(_who);                                    // the current balance of the input token for _who\r\n        userAllowance = IERC20(input).allowance(_who, _this);                           // the current allowance for the input token granted by _who to this contract\r\n        if(last[_who] > 0)                                                              // if _who has ever interacted with this contract\r\n            userScore = _calcScore(_who, whoTime);                                          // get the current score of _who\r\n        if(last[winner] > 0) {                                                          // if the winner has ever interacted with this contract\r\n            currentWinner = winner;                                                         // the address of the current winner\r\n            winnerScore = _calcScore(winner, winnerTime);                                   // get the current score of the winner\r\n        }\r\n        dailyKrill += (8000 ether * IWG(whalesGame).fishermenOf(_this));                // every fisherman NFT brings in 8K/day\r\n        dailyKrill += (16000 ether * IWG(whalesGame).whalesOf(_this));                  // every whale NFT brings in 16K/day\r\n        if(input != ISLAND) {                                                           // if the input token is NOT the island token (otherwise the wfm/wwh earning krill goes to the winner)\r\n            dailyKrill += (8000 ether * IERC20(wFM).balanceOf(_this) / 1 ether);            // add the daily krill generation rate from the wFM held by this contract\r\n            dailyKrill += (16000 ether * IERC20(wWH).balanceOf(_this) / 1 ether);           // add the daily krill generation rate from the wWH held by this contract\r\n        }\r\n        if(potFee > 0)                                                                  // if the fee is enabled\r\n            (,dailyKrill) = _calculateFee(dailyKrill);                                      // calculate the daily krill generation rate after the fee is applied\r\n        decayPerSecond = decayRate;                                                     // the decay per second for the krill\r\n    }\r\n    function assumeControl()\r\n    external onlyPlayable {\r\n        address caller = msg.sender;        // shorthand\r\n        claimForWinner();                   // claim rewards from all sources, for the winner\r\n        _assumeControl(caller, caller, 0);  // atttempt to assume control\r\n    }\r\n    function claimAndBurn()\r\n    external onlyPlayable {\r\n        address _this = address(this);                  // shorthand\r\n        address caller = msg.sender;                    // shorthand\r\n        require(caller == winner);                      // only allow calling this if the caller is the winner\r\n        require(input == KRILL);                        // only allow calling this if the input token is KRILL\r\n        _claimRewards();                                // claim rewards\r\n        uint balance = IERC20(KRILL).balanceOf(_this);  // load current KRILL balance\r\n        winnings[caller][KRILL] += balance;             // increment the winnings for the caller\r\n        totalWinnings[KRILL] += balance;                // increment the total winnings\r\n        _enterFor(caller, _this, balance, false);       // enter the difference in balance for the caller (the current winner)\r\n    }\r\n    function enter(uint _amount)\r\n    external onlyPlayable {\r\n        _enterFor(msg.sender, msg.sender, _amount, false);  // enter the amount for the caller, taking tokens from the caller\r\n    }\r\n    function enterFor(address _who, uint _amount)\r\n    external onlyPlayable {\r\n        _enterFor(_who, msg.sender, _amount, false);    // enter the amount for _who, taking tokens from the caller\r\n    }\r\n    function enterFrom(address _who, uint _amount)\r\n    external onlyPlayable {\r\n        address caller = msg.sender;                // shorthand\r\n        require(permission[_who][caller] == true);  // only allow calling this if the caller has permission to use _who's tokens\r\n        _enterFor(caller, _who, _amount, false);    // enter the amount for the caller, taking tokens from _who\r\n    }\r\n    function setPermission(address _to, bool _value)\r\n    external {\r\n        address caller = msg.sender;                                    // shorthand\r\n        if(permission[caller][_to] == false)                            // if the caller is currently not allowed to use _to's tokens\r\n            require(IPermissionGate(permissionGate).viewGate(_to) == true); // only proceed if the permission gate is configured to allow _to to use caller's tokens\r\n        permission[caller][_to] = _value;                               // set the permission for _to to _value\r\n    }\r\n    function allInfoFor(address _who)\r\n    external view returns (uint playCap, uint userBalance, uint userAllowance, uint userScore, address currentWinner, uint winnerScore, uint potTotal, uint dailyKrill, uint decayPerSecond) {\r\n        playCap = playAmountCap;\r\n        (userBalance, userAllowance, userScore, currentWinner, winnerScore, dailyKrill, decayPerSecond) = _mostInfoFor(_who);   // load most info for _who into memory\r\n        potTotal = _calcTotalPot();                                                                                             // load the total pot into memory\r\n    }\r\n    function viewEpoch(uint _epoch)\r\n    external view returns (address, address, uint) {\r\n        EpochData memory data = epochs[_epoch];                 // load the epoch data for _epoch into memory\r\n        return (data.player, data.caller, uint(data.stamp));    // return the player and timestamp of the epoch\r\n    }\r\n    function viewStatsFor(address _who, address _asset)\r\n    external view returns (uint, uint, uint, uint, uint, uint, uint) {\r\n        return (rawScores[_who], totalWinnings[_asset], totalBurned, totalRawScores, winnings[_who][_asset], totalPlayers, startStamp);\r\n    }\r\n    function viewExtraInfo()\r\n    external view returns (uint, uint, uint, uint, uint, uint) {\r\n        uint totalSupply = IERC20(whalesGame).totalSupply();                                                                    // load total NFT supply\r\n        uint activeSupply = totalSupply - IERC20(whalesGame).balanceOf(BURNER);                                                 // deactivated NFTs do not mint KRILL\r\n        uint dailyInflationEstimate = ((10000e18 * activeSupply) / 100) * 90;                                                   // 10k * supply * 0.9 per day\r\n        uint currentKrillSupply = IERC20(KRILL).totalSupply();                                                                  // load the current krill supply\r\n        return (winnerSlashRate, totalSupply, activeSupply, dailyInflationEstimate, krillSupplyAtLaunch, currentKrillSupply);   // return the data\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cKRILL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_KRILL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ISLAND\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Played\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_takenFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_takenBy\",\"type\":\"address\"}],\"name\":\"ThroneTaken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ISLAND\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"KRILL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_KRILL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_LP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"allInfoFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"playCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userScore\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currentWinner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winnerScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"potTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyKrill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decayPerSecond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assumeControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cKRILL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimForWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"controlTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decayRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"stamp\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipShutdownSwitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"input\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"islandThrone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"krillSupplyAtLaunch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissionGate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"playAmountCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rawScorePlayedForOthers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rawScores\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondThrone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_decayRate\",\"type\":\"uint256\"}],\"name\":\"setDecayRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDestination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercent\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setGuildRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_krillMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_LPMinimum\",\"type\":\"uint256\"}],\"name\":\"setMinimums\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_permissionGate\",\"type\":\"address\"}],\"name\":\"setPermissionGate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountCap\",\"type\":\"uint256\"}],\"name\":\"setPlayAmountCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStartStamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_secondOrIsland\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_throne\",\"type\":\"address\"}],\"name\":\"setThrone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slashRate\",\"type\":\"uint256\"}],\"name\":\"setWinnerSlashRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapperBurner\",\"type\":\"address\"}],\"name\":\"setWrapperBurner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_override\",\"type\":\"bool\"}],\"name\":\"setWrapperClaimOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutDown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sweepOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sweepOutNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRawScores\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tracked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"viewEpoch\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewExtraInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"viewStatsFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wFM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wWH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whalesGame\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winnerSlashRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"winnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapperBurner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapperClaimOverride\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Throne", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000f59bfeed034092e399cc43ff79edab15e2e187350000000000000000000000009a8fd979f655f8e41d086b596f14bca16f53ad15000000000000000000000000f59bfeed034092e399cc43ff79edab15e2e18735000000000000000000000000e0be84ca5c7beaa2051057f02449ecb0495bf50e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://44b356f2e5de224863f73d35a2a5ffa18ddaa2c104b8ddfe95e422843d726900"}]}