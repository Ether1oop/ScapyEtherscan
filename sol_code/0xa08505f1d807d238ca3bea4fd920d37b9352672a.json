{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ncontract SRI is Auth {\r\n\r\n\tstruct StakeState {\r\n\t\tuint256 stakedAmount;\r\n\t\tuint32 since;\r\n\t\tuint32 lastUpdate;\r\n\t}\r\n\r\n\t// Staking token and fee receivers.\r\n\taddress public stakingToken;\r\n\taddress constant public DEAD = address(0xdead);\r\n\taddress public devFeeReceiver;\r\n\taddress public lpFeeReceiver;\r\n\t// APR% with 2 decimals.\r\n\tuint256 public aprNumerator = 3600;\r\n\tuint256 constant public aprDenominator = 10000;\r\n\t// Fees in % with 2 decimals.\r\n\tuint256 public burnFeeNumerator = 300;\r\n\tuint256 constant public burnFeeDenominator = 10000;\r\n\tuint256 public devFeeNumerator = 50;\r\n\tuint256 constant public devFeeDenominator = 10000;\r\n\tuint256 public lpFeeNumerator = 50;\r\n\tuint256 constant public lpFeeDenominator = 10000;\r\n\t// Staking status.\r\n\tuint256 public totalStakedTokens;\r\n\tmapping (address => StakeState) internal stakerDetails;\r\n\r\n\tevent TokenStaked(address indexed user, uint256 amount);\r\n\tevent TokenUnstaked(address indexed user, uint256 amount, uint256 reward);\r\n\tevent RewardClaimed(address indexed user, uint256 reward);\r\n\tevent Compounded(address indexed user, uint256 amount);\r\n\r\n\tconstructor(address tokenToStake, address devFee, address lpAddress) Auth(msg.sender) {\r\n\t\tstakingToken = tokenToStake;\r\n\t\tdevFeeReceiver = devFee;\r\n\t\tlpFeeReceiver = lpAddress;\r\n\t}\r\n\r\n\tfunction stake(uint256 amount) external {\r\n\t\trequire(amount > 0, \"Amount needs to be bigger than 0\");\r\n\r\n\t\tStakeState storage user = stakerDetails[msg.sender];\r\n\t\tuint32 ts = uint32(block.timestamp);\r\n\r\n\t\t// New staking\r\n\t\tif (user.since == 0) {\r\n\t\t\tuser.since = ts;\r\n\t\t} else {\r\n\t\t\tcompoundFor(msg.sender);\r\n\t\t}\r\n\t\tuser.lastUpdate = ts;\r\n\t\tuser.stakedAmount += amount;\r\n\t\ttotalStakedTokens += amount;\r\n\r\n\t\tIERC20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\r\n\t\temit TokenStaked(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction unstake(uint256 amount) public {\r\n\t\trequire(amount > 0, \"Amount needs to be bigger than 0\");\r\n\t\tunstakeFor(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction unstakeAll() external {\r\n\t\tStakeState storage user = stakerDetails[msg.sender];\r\n\t\trequire(user.since > 0, \"You are not staking.\");\r\n\t\trequire(user.stakedAmount > 0, \"You are not staking.\");\r\n\t\tuint256 toUnstake = user.stakedAmount;\r\n\t\trequire(toUnstake > 0, \"You are not staking.\");\r\n\t\tunstakeFor(msg.sender, toUnstake);\r\n\t}\r\n\r\n\tfunction unstakeFor(address staker, uint256 amount) internal {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\trequire(user.stakedAmount >= amount, \"Not enough tokens staked.\");\r\n\r\n\t\t// Unstaking automatically gives the pending reward.\r\n\t\tuint256 pending = pendingReward(staker);\r\n\t\tuint256 total = amount + pending;\r\n\t\tuint256 burnFee = executeBurnFee(total);\r\n\t\tuint256 devFee = executeDevFee(total);\r\n\t\tuint256 lpFee = executeLPFee(total);\r\n\t\tuint256 toReceive = total - burnFee - devFee - lpFee;\r\n\t\tuser.stakedAmount -= amount;\r\n\t\ttotalStakedTokens -= amount;\r\n\t\tuser.lastUpdate = uint32(block.timestamp);\r\n\r\n\t\tIERC20(stakingToken).transfer(staker, toReceive);\r\n\r\n\t\temit TokenUnstaked(staker, toReceive, pending);\r\n\t}\r\n\r\n\tfunction executeBurnFee(uint256 amount) internal returns (uint256) {\r\n\t\treturn executeFee(amount, burnFeeNumerator, burnFeeDenominator, DEAD);\r\n\t}\r\n\r\n\tfunction executeDevFee(uint256 amount) internal returns (uint256) {\r\n\t\treturn executeFee(amount, devFeeNumerator, devFeeDenominator, devFeeReceiver);\r\n\t}\r\n\r\n\tfunction executeLPFee(uint256 amount) internal returns (uint256) {\r\n\t\treturn executeFee(amount, lpFeeNumerator, lpFeeDenominator, lpFeeReceiver);\r\n\t}\r\n\r\n\tfunction executeFee(uint256 amount, uint256 numerator, uint256 denominator, address receiver) internal returns (uint256) {\r\n\t\tuint256 fee = calcFee(amount, numerator, denominator);\r\n\t\tif (fee > 0) {\r\n\t\t\tIERC20(stakingToken).transfer(receiver, fee);\r\n\t\t\treturn fee;\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction calcFee(uint256 amount, uint256 num, uint256 den) public pure returns (uint256) {\r\n\t\tif (amount == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (num == 0 || den == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn amount * num / den;\r\n\t}\r\n\r\n\tfunction claim() external {\r\n\t\tStakeState storage user = stakerDetails[msg.sender];\r\n\t\trequire(user.since > 0, \"You are not staking.\");\r\n\t\tuint256 pending = pendingReward(msg.sender);\r\n\t\tif (pending > 0) {\r\n\t\t\tIERC20(stakingToken).transfer(msg.sender, pending);\r\n\t\t\tuser.lastUpdate = uint32(block.timestamp);\r\n\r\n\t\t\temit RewardClaimed(msg.sender, pending);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction compound() external {\r\n\t\tcompoundFor(msg.sender);\r\n\t}\r\n\r\n\tfunction compoundFor(address staker) internal {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\tuint256 pending = pendingReward(staker);\r\n\t\tif (pending > 0) {\r\n\t\t\tuser.lastUpdate = uint32(block.timestamp);\r\n\t\t\tuser.stakedAmount += pending;\r\n\t\t\ttotalStakedTokens += pending;\r\n\r\n\t\t\temit Compounded(staker, pending);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPendingReward() external view returns (uint256) {\r\n\t\treturn pendingReward(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check the current unclaimed pending reward for a user.\r\n\t */\r\n\tfunction pendingReward(address staker) public view returns (uint256) {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\t// Check if the user ever staked.\r\n\t\tif (user.since == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Should not happen but block.timestamp is not 100% secure.\r\n\t\tif (block.timestamp <= user.lastUpdate) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 deltaTime = block.timestamp - user.lastUpdate;\r\n\t\tuint256 annualReward = user.stakedAmount * aprNumerator / aprDenominator;\r\n\t\treturn annualReward * deltaTime / 365 days;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get the APR values, returns a numerator to divide by a denominator to get the decimal value of the percentage.\r\n\t * Example: 20% can be 2000 / 10000, which is 0.2, the decimal representation of 20%.\r\n\t * @notice APY = (1 + APR / n) ** n - 1;\r\n\t * Where n is the compounding rate (times of compounding in a year)\r\n\t * This is better calculated on a frontend, as Solidity does not do floating point arithmetic.\r\n\t */\r\n\tfunction getAPR() external view returns (uint256 numerator, uint256 denominator) {\r\n\t\treturn (aprNumerator, aprDenominator);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets an approximated APR percentage rounded to no decimals.\r\n\t */\r\n\tfunction getAPRRoundedPercentage() external view returns (uint256) {\r\n\t\treturn 100 * aprNumerator / aprDenominator;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets an approximated APR percentage rounded to specified decimals.\r\n\t */\r\n\tfunction getAPRPercentage(uint256 desiredDecimals) external view returns (uint256 percentage, uint256 decimals) {\r\n\t\tuint256 factor = 10 ** desiredDecimals;\r\n\t\tuint256 integerPercent = 100 * factor * aprNumerator / aprDenominator;\r\n\t\treturn (integerPercent / factor, integerPercent % factor);\r\n\t}\r\n\r\n\tfunction setDevFeeReceiver(address receiver) external authorized {\r\n\t\tdevFeeReceiver = receiver;\r\n\t}\r\n\r\n\tfunction setLPAddress(address lp) external authorized {\r\n\t\tlpFeeReceiver = lp;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets the unstake burn fee. It is then divided by 10000, so for 1% fee you would set it to 100.\r\n\t */\r\n\tfunction setBurnFeeNumerator(uint256 numerator) external authorized {\r\n\t\trequire(numerator + lpFeeNumerator + devFeeNumerator < 3333, \"Total fee has to be lower than 33.33%.\");\r\n\t\tburnFeeNumerator = numerator;\r\n\t}\r\n\r\n\tfunction setDevFeeNumerator(uint256 numerator) external authorized {\r\n\t\trequire(numerator + lpFeeNumerator + burnFeeNumerator < 3333, \"Total fee has to be lower than 33.33%.\");\r\n\t\tdevFeeNumerator = numerator;\r\n\t}\r\n\r\n\tfunction setLPFeeNumerator(uint256 numerator) external authorized {\r\n\t\trequire(numerator + burnFeeNumerator + devFeeNumerator < 3333, \"Total fee has to be lower than 33.33%.\");\r\n\t\tlpFeeNumerator = numerator;\r\n\t}\r\n\r\n\tfunction getStake(address staker) external view returns (StakeState memory) {\r\n\t\treturn stakerDetails[staker];\r\n\t}\r\n\r\n\tfunction availableRewardTokens() external view returns (uint256) {\r\n\t\tuint256 tokens = IERC20(stakingToken).balanceOf(address(this));\r\n\t\tif (tokens <= totalStakedTokens) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn tokens - totalStakedTokens;\r\n\t}\r\n\r\n\tfunction setStakingToken(address newToken) external authorized {\r\n\t\trequire(totalStakedTokens == 0, \"Cannot change staking token while people are still staking.\");\r\n\t\tstakingToken = newToken;\r\n\t}\r\n\r\n\tfunction forceUnstakeAll(address staker) external authorized {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\trequire(user.since > 0, \"User is not staking.\");\r\n\t\trequire(user.stakedAmount > 0, \"User is not staking.\");\r\n\t\tuint256 toUnstake = user.stakedAmount;\r\n\t\trequire(toUnstake > 0, \"User is not staking.\");\r\n\t\tunstakeFor(staker, toUnstake);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToStake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Compounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"TokenUnstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableRewardTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"den\",\"type\":\"uint256\"}],\"name\":\"calcFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"forceUnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"desiredDecimals\",\"type\":\"uint256\"}],\"name\":\"getAPRPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPRRoundedPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"since\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdate\",\"type\":\"uint32\"}],\"internalType\":\"struct SRI.StakeState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"}],\"name\":\"setBurnFeeNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"}],\"name\":\"setDevFeeNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setDevFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"setLPAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"}],\"name\":\"setLPFeeNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SRI", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d55231b619ec464347d7b6eb12cc7ae19fbbf37d00000000000000000000000043c2b1adde05ec23b9bcbd4f10a7d5d9c111e6a100000000000000000000000043c2b1adde05ec23b9bcbd4f10a7d5d9c111e6a1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://19efa4a1d61689aaa59eba0f8baa401ba957dcd1a16654987f8b090dce3ce4a9"}]}