{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ncontract PyroStaking is Auth {\r\n\r\n    struct PoolConfiguration {\r\n        uint256 poolStakedTokens;\r\n\t\tuint16 apr;\r\n\t\tuint16 depositFee;\r\n        uint16 earlyWithdrawFee;\r\n        uint32 withdrawLockPeriod;\r\n\t\tbool available;\r\n\t\tbool burnDeposit;\r\n    }\r\n\r\n\tstruct StakeState {\r\n\t\tuint256 stakedAmount;\r\n\t\tuint256 rewardDebt; \r\n\t\tuint32 lastChangeTime;\r\n\t\tuint32 lockEndTime;\r\n\t}\r\n\r\n\tevent TokenStaked(address indexed user, uint256 amount);\r\n\tevent TokenUnstaked(address indexed user, uint256 amount);\r\n\tevent RewardClaimed(address indexed user, uint256 outAmount);\r\n\tevent PoolAvailability(bool available);\r\n\tevent PoolConfigurated(uint16 apr, uint16 depositFee, uint32 lockPeriod, uint16 earlyWithdrawFee);\r\n\tevent DepositFeeBurnStatus(bool active);\r\n\tevent DepositFeeBurn(uint256 burn);\r\n\tevent StakingTokenUpdate(address indexed oldToken, address indexed newToken);\r\n\r\n\t// Informs about the address for the token being used for staking.\r\n\taddress public stakingToken;\r\n\r\n    // Taxes are set in /10000.\r\n\t// Using solidity underscore separator for easier reading.\r\n\t// Digits before underscore are the percentage.\r\n\t// Digits after underscore are decimals for said percentage.\r\n    uint256 public immutable denominator = 100_00;\r\n\r\n    // Staking pool configuration.\r\n\tPoolConfiguration private poolConfig;\r\n\r\n\t// Info of each user that stakes tokens.\r\n\tmapping (address => StakeState) public stakerDetails;\r\n\r\n\t// Burn address.\r\n\taddress public immutable DEAD = address(0xdead);\r\n\r\n\tconstructor(address t) Auth(msg.sender) {\r\n\t\tstakingToken = t;\r\n\r\n\t\tuint16 apr = 100_00; // 100%\r\n\t\tuint16 depositFee = 3_00; // 3%\r\n\t\tuint16 earlyWithdrawFee = 50_00; // 50%\r\n\t\tuint32 lockPeriod = 30 days;\r\n\t\tbool available = true;\r\n\r\n\t\t_setStakingConfig(apr, depositFee, earlyWithdrawFee, lockPeriod, available, false);\r\n\t}\r\n\r\n\tmodifier noStakes {\r\n\t\trequire(poolConfig.poolStakedTokens == 0, \"Action can only be done when there are no staked tokens.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier positiveAPR(uint16 apr) {\r\n\t\trequire(apr > 0, \"APR cannot be 0.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validFee(uint16 fee) {\r\n\t\trequire(fee <= 5000, \"Fees cannot be more than 50%.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validLockPeriod(uint32 time) {\r\n\t\trequire(time < 365 days, \"Lockout period should be less than a year.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setPoolConfiguration(\r\n\t\tuint16 apr, uint16 depositFee, uint16 earlyWithdrawFee, uint32 withdrawLockPeriod, bool active, bool burn\r\n\t)\r\n\t\texternal authorized noStakes positiveAPR(apr)\r\n\t\tvalidFee(depositFee) validFee(earlyWithdrawFee)\r\n\t\tvalidLockPeriod(withdrawLockPeriod)\r\n\t{\t\t\r\n\t\t_setStakingConfig(apr, depositFee, earlyWithdrawFee, withdrawLockPeriod, active, burn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function for updating full stake configuration.\r\n\t */\r\n\tfunction _setStakingConfig(\r\n\t\tuint16 apr, uint16 depositFee, uint16 earlyWithdrawFee, uint32 withdrawLockPeriod, bool active, bool burn\r\n\t) internal {\r\n\t\tpoolConfig.apr = apr;\r\n\t\tpoolConfig.depositFee = depositFee;\r\n        poolConfig.earlyWithdrawFee = earlyWithdrawFee;\r\n\t\tpoolConfig.withdrawLockPeriod = withdrawLockPeriod;\r\n\t\tpoolConfig.available = active;\r\n\t\tpoolConfig.burnDeposit = burn;\r\n\r\n\t\temit PoolConfigurated(apr, depositFee, withdrawLockPeriod, earlyWithdrawFee);\r\n\t\temit PoolAvailability(active);\r\n\t\temit DepositFeeBurnStatus(burn);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets APR out of / 10000.\r\n\t * Each 100 means 1%.\r\n\t */\r\n\tfunction setAPR(uint16 apr) external authorized positiveAPR(apr) {\r\n\t\tif (poolConfig.poolStakedTokens > 0) {\r\n\t\t\trequire(apr >= poolConfig.apr, \"APR cannot be lowered while there are tokens staked.\");\r\n\t\t}\r\n\t\tpoolConfig.apr = apr;\r\n\r\n\t\temit PoolConfigurated(apr, poolConfig.depositFee, poolConfig.withdrawLockPeriod, poolConfig.earlyWithdrawFee);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets deposit fee out of / 10000.\r\n\t */\r\n\tfunction setDepositFee(uint16 fee) external authorized validFee(fee) {\r\n\t\tpoolConfig.depositFee = fee;\r\n\r\n\t\temit PoolConfigurated(poolConfig.apr, fee, poolConfig.withdrawLockPeriod, poolConfig.earlyWithdrawFee);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Early withdraw fee out of / 10000.\r\n\t */\r\n\tfunction setEarlyWithdrawFee(uint16 fee) external authorized validFee(fee) {\r\n\t\tpoolConfig.earlyWithdrawFee = fee;\r\n\r\n\t\temit PoolConfigurated(poolConfig.apr, poolConfig.depositFee, poolConfig.withdrawLockPeriod, fee);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Pool can be set inactive to end staking after the last lock and restart with new values.\r\n\t */\r\n\tfunction setPoolAvailable(bool active) external authorized {\r\n\t\tpoolConfig.available = active;\r\n\t\temit PoolAvailability(active);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Early withdraw penalty in seconds.\r\n\t */\r\n\tfunction setEarlyWithdrawLock(uint32 time) external authorized noStakes validLockPeriod(time) {\r\n\t\tpoolConfig.withdrawLockPeriod = time;\r\n\t\temit PoolConfigurated(poolConfig.apr, poolConfig.depositFee, time, poolConfig.earlyWithdrawFee);\r\n\t}\r\n\r\n\tfunction setFeeBurn(bool burn) external authorized {\r\n\t\tpoolConfig.burnDeposit = burn;\r\n\t\temit DepositFeeBurnStatus(burn);\r\n\t}\r\n\r\n    function updateStakingToken(address t) external authorized noStakes {\r\n\t\temit StakingTokenUpdate(stakingToken, t);\r\n        stakingToken = t;\r\n    }\r\n\r\n\t/**\r\n\t * @dev Check the current unclaimed pending reward for a specific stake.\r\n\t */\r\n\tfunction pendingReward(address account) public view returns (uint256) {\r\n\t\tStakeState storage user = stakerDetails[account];\r\n\t\t// Last change time of 0 means there's never been a stake to begin with.\r\n\t\tif (user.lastChangeTime == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// Ellapsed time since staking and now.\r\n\t\tif (block.timestamp <= user.lastChangeTime) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 deltaTime = block.timestamp - user.lastChangeTime;\r\n\t\tuint256 accrued = yieldFromElapsedTime(user.stakedAmount, deltaTime);\r\n\r\n\t\treturn accrued + user.rewardDebt;\r\n\t}\r\n\r\n\tfunction yieldFromElapsedTime(uint256 amount, uint256 deltaTime) public view returns (uint256) {\r\n\t\t// No elapsed time or no amount means no reward accrued.\r\n\t\tif (amount == 0 || deltaTime == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * It's quite simple to derive owed reward from time using the set duration (APR):\r\n\t\t * Total cycle reward plus time elapsed divided by cycle duration.\r\n\t\t * Time is counted by seconds, so we divide the total reward by seconds and calculate the amount due to seconds passed.\r\n\t\t */\r\n\t\tuint256 annuality = annualYield(amount);\r\n\t\tif (annuality == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn (deltaTime * annuality) / 365 days;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Given an amount to stake returns a total yield as per APR.\r\n\t */\r\n\tfunction annualYield(uint256 amount) public view returns (uint256) {\r\n\t\tif (amount == 0 || poolConfig.apr == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn amount * poolConfig.apr / denominator;\r\n\t}\r\n\r\n\tfunction dailyYield(uint256 amount) external view returns (uint256) {\r\n\t\t// Due to how Solidity decimals work, any amount less than 365 will yield 0 per day.\r\n\t\t// On a 9 decimal token this means less than 0.000000365 -- basically nothing at all.\r\n\t\t// Once the time has surpassed 365 days the yield will be owed normally as soon as the decimal place jumps.\r\n\t\tif (amount < 365) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (amount == 365) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\treturn annualYield(amount) / 365;\r\n\t}\r\n\r\n\tfunction stake(uint256 amount) external {\r\n\t\trequire(amount > 0, \"Amount needs to be bigger than 0\");\r\n\t\trequire(poolConfig.available, \"Pool is not accepting staking right now.\");\r\n\r\n\t\tIERC20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\t\tStakeState storage user = stakerDetails[msg.sender];\r\n\t\t// Calc unclaimed reward on stake update.\r\n\t\tif (user.lastChangeTime != 0 && user.stakedAmount > 0) {\r\n\t\t\tuser.rewardDebt = pendingReward(msg.sender);\r\n\t\t}\r\n        uint256 stakeAmount = amount;\r\n\r\n        // Check deposit fee\r\n        if (poolConfig.depositFee > 0) {\r\n            uint256 dFee = depositFeeFromAmount(amount);\r\n            stakeAmount -= dFee;\r\n\t\t\t// If the pool has enough for rewards, deposit fee can be sent to burn address instead.\r\n\t\t\tif (poolConfig.burnDeposit) {\r\n\t\t\t\tIERC20(stakingToken).transfer(DEAD, dFee);\r\n\t\t\t\temit DepositFeeBurn(dFee);\r\n\t\t\t}\r\n        }\r\n\r\n\t\tuser.stakedAmount += stakeAmount;\r\n\t\tuint32 rnow = uint32(block.timestamp);\r\n\t\tuser.lastChangeTime = rnow;\r\n        if (user.lockEndTime == 0) {\r\n            user.lockEndTime = rnow + poolConfig.withdrawLockPeriod;\r\n        }\r\n\t\tpoolConfig.poolStakedTokens += stakeAmount;\r\n\r\n\t\temit TokenStaked(msg.sender, stakeAmount);\r\n\t}\r\n\r\n\tfunction depositFeeFromAmount(uint256 amount) public view returns (uint256) {\r\n\t\tif (poolConfig.depositFee == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn amount * poolConfig.depositFee / denominator;\r\n\t}\r\n\r\n\tfunction unstake() external {\r\n\t\tunstakeFor(msg.sender);\r\n\t}\r\n\r\n\tfunction unstakeFor(address staker) internal {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\tuint256 amount = user.stakedAmount;\r\n\t\trequire(amount > 0, \"No stake on pool.\");\r\n\r\n\t\t// Update user staking status.\r\n\t\t// When unstaking is done, claim is automatically done.\r\n\t\t_claim(staker);\r\n\t\tuser.stakedAmount = 0;\r\n\r\n\t\tuint256 unstakeAmount = amount;\r\n        // Check for early withdraw fee.\r\n        if (block.timestamp < user.lockEndTime && poolConfig.earlyWithdrawFee > 0) {\r\n            uint256 fee = amount * poolConfig.earlyWithdrawFee / denominator;\r\n            unstakeAmount -= fee;\r\n        }\r\n        user.lockEndTime = 0;\r\n\r\n\t\tIERC20 stakedToken = IERC20(stakingToken);\r\n\t\t// Check for a clear revert error if rewards+unstake surpass balance.\r\n\t\trequire(stakedToken.balanceOf(address(this)) >= unstakeAmount, \"Staking contract does not have enough tokens.\");\r\n\r\n\t\t// Return token to staker and update staking values.\r\n\t\tstakedToken.transfer(staker, unstakeAmount);\r\n\t\tpoolConfig.poolStakedTokens -= amount;\r\n\r\n\t\temit TokenUnstaked(staker, unstakeAmount);\r\n\t}\r\n\r\n\tfunction claim() external {\r\n\t\t_claim(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows an authorised account to finalise a staking that has not claimed nor unstaked while the period is over.\r\n\t */\r\n\tfunction forceClaimUnstake(address staker) external authorized {\r\n\t\t// Pool must not be available for staking, otherwise the user should be free to renew their stake.\r\n\t\trequire(!poolConfig.available, \"Pool is still available.\");\r\n\t\t// The stake must have finished its lock time and accrued all the APR.\r\n\t\trequire(block.timestamp > stakerDetails[staker].lockEndTime, \"User's lock time has not finished yet.\");\r\n\t\t// Run their claim and unstake.\r\n\t\tunstakeFor(staker);\r\n\t}\r\n\r\n\tfunction _claim(address staker) internal {\r\n\t\tStakeState storage user = stakerDetails[staker];\r\n\t\tuint256 outAmount = pendingReward(staker);\r\n\t\tif (outAmount > 0) {\r\n\t\t\t// Check for a clear revert error if rewards+unstake surpass balance.\r\n\t\t\tuint256 contractBalance = IERC20(stakingToken).balanceOf(address(this));\r\n\t\t\trequire(contractBalance >= outAmount, \"Staking contract does not own enough tokens.\");\r\n\r\n\t\t\tIERC20(stakingToken).transfer(staker, outAmount);\r\n\t\t\tuser.rewardDebt = 0;\r\n\t\t\tuser.lastChangeTime = uint32(block.timestamp);\r\n\r\n\t\t\temit RewardClaimed(staker, outAmount);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks whether there's a stake withdraw fee or not.\r\n\t */\r\n\tfunction canWithdrawTokensNoFee(address user) external view returns (bool) {\r\n\t\tif (stakerDetails[user].lastChangeTime == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn block.timestamp > stakerDetails[user].lockEndTime;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Rescue non staking tokens sent to this contract by accident.\r\n\t */\r\n\tfunction rescueToken(address t, address receiver) external authorized {\r\n\t\trequire(t != stakingToken, \"Staking token can't be withdrawn!\");\r\n\t\tuint256 balance = IERC20(t).balanceOf(address(this));\r\n\t\tIERC20(t).transfer(receiver, balance);\r\n\t}\r\n\r\n\tfunction viewPoolDetails() external view returns (PoolConfiguration memory) {\r\n\t\treturn poolConfig;\r\n\t}\r\n\r\n\tfunction viewStake(address staker) public view returns (StakeState memory) {\r\n\t\treturn stakerDetails[staker];\r\n\t}\r\n\r\n\tfunction viewMyStake() external view returns (StakeState memory) {\r\n\t\treturn viewStake(msg.sender);\r\n\t}\r\n\r\n\tfunction viewMyPendingReward() external view returns (uint256) {\r\n\t\treturn pendingReward(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns APR in percentage.\r\n\t */\r\n\tfunction viewAPRPercent() external view returns (uint16) {\r\n\t\treturn poolConfig.apr / 100;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns APR in percentage and 2 decimal points in an extra varaible.\r\n\t */\r\n\tfunction viewAPRPercentDecimals() external view returns (uint16 aprPercent, uint16 decimalValue) {\r\n\t\treturn (poolConfig.apr / 100, poolConfig.apr % 100);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Given a theroetical stake, returns the unstake returning amount, deposit fee paid, and yield on a full cycle.\r\n\t */\r\n\tfunction simulateYearStake(uint256 amount) external view returns (uint256 unstakeAmount, uint256 depositFee, uint256 yield) {\r\n\t\tif (amount == 0) {\r\n\t\t\treturn (0, 0, 0);\r\n\t\t}\r\n\t\tuint256 fee = depositFeeFromAmount(amount);\r\n\t\tuint256 actual = amount - fee;\r\n\t\tuint256 y = annualYield(actual);\r\n\r\n\t\treturn (actual, fee, y);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Given an amount to stake and a duration, returns unstake returning amount, deposit fee paid, and yield.\r\n\t */\r\n\tfunction simulateStake(uint256 amount, uint32 duration) external view returns (uint256 unstakeAmount, uint256 depositFee, uint256 yield) {\r\n\t\tif (amount == 0 || duration == 0) {\r\n\t\t\treturn (0, 0, 0);\r\n\t\t}\r\n\t\tuint256 fee = depositFeeFromAmount(amount);\r\n\t\tuint256 actual = amount - fee;\r\n\t\tuint256 y = yieldFromElapsedTime(actual, duration);\r\n\t\tif (duration < poolConfig.withdrawLockPeriod && poolConfig.earlyWithdrawFee > 0) {\r\n            uint256 withdrawFee = amount * poolConfig.earlyWithdrawFee / denominator;\r\n            actual -= withdrawFee;\r\n        }\r\n\r\n\t\treturn (actual, fee, y);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns total amount of tokens staked by users.\r\n\t */\r\n\tfunction totalStakedTokens() external view returns (uint256) {\r\n\t\treturn poolConfig.poolStakedTokens;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"name\":\"DepositFeeBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"DepositFeeBurnStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"available\",\"type\":\"bool\"}],\"name\":\"PoolAvailability\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"apr\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"depositFee\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"lockPeriod\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"earlyWithdrawFee\",\"type\":\"uint16\"}],\"name\":\"PoolConfigurated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"StakingTokenUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenUnstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"annualYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canWithdrawTokensNoFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"dailyYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositFeeFromAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"forceClaimUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"apr\",\"type\":\"uint16\"}],\"name\":\"setAPR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"setDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"setEarlyWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"setEarlyWithdrawLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"}],\"name\":\"setFeeBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setPoolAvailable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"apr\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"depositFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"earlyWithdrawFee\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"withdrawLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burn\",\"type\":\"bool\"}],\"name\":\"setPoolConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"simulateStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"simulateYearStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yield\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"lastChangeTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockEndTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"updateStakingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAPRPercent\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAPRPercentDecimals\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"aprPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"decimalValue\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewMyPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewMyStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"lastChangeTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockEndTime\",\"type\":\"uint32\"}],\"internalType\":\"struct PyroStaking.StakeState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolStakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"apr\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"depositFee\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"earlyWithdrawFee\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"withdrawLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"available\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"burnDeposit\",\"type\":\"bool\"}],\"internalType\":\"struct PyroStaking.PoolConfiguration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"viewStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"lastChangeTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockEndTime\",\"type\":\"uint32\"}],\"internalType\":\"struct PyroStaking.StakeState\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaTime\",\"type\":\"uint256\"}],\"name\":\"yieldFromElapsedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PyroStaking", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000001e2d230c7a7f4c679fb1378f1f51dedeae85cd72", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5f6359aa68785e1c6dacec3963c2ab9ebf3a2b48909a68032cc8286cfb9e028a"}]}