{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/interfaces/IBankingNode.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBankingNode {\r\n    //ERC20 functions\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    //Banking Node Functions\r\n\r\n    function requestLoan(\r\n        uint256 loanAmount,\r\n        uint256 paymentInterval,\r\n        uint256 numberOfPayments,\r\n        uint256 interestRate,\r\n        bool interestOnly,\r\n        address collateral,\r\n        uint256 collateralAmount,\r\n        address agent,\r\n        string memory message\r\n    ) external returns (uint256 requestId);\r\n\r\n    function withdrawCollateral(uint256 loanId) external;\r\n\r\n    function collectAaveRewards(address[] calldata assets) external;\r\n\r\n    function collectCollateralFees(address collateral) external;\r\n\r\n    function makeLoanPayment(uint256 loanId) external;\r\n\r\n    function repayEarly(uint256 loanId) external;\r\n\r\n    function collectFees() external;\r\n\r\n    function deposit(uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function stake(uint256 _amount) external;\r\n\r\n    function initiateUnstake(uint256 _amount) external;\r\n\r\n    function unstake() external;\r\n\r\n    function slashLoan(uint256 loanId, uint256 minOut) external;\r\n\r\n    function sellSlashed(uint256 minOut) external;\r\n\r\n    function donateBaseToken(uint256 _amount) external;\r\n\r\n    //Operator only functions\r\n\r\n    function approveLoan(uint256 loanId, uint256 requiredCollateralAmount)\r\n        external;\r\n\r\n    function clearPendingLoans() external;\r\n\r\n    function whitelistAddresses(address whitelistAddition) external;\r\n\r\n    //View functions\r\n\r\n    function getStakedBNPL() external view returns (uint256);\r\n\r\n    function getBaseTokenBalance(address user) external view returns (uint256);\r\n\r\n    function getBNPLBalance(address user) external view returns (uint256 what);\r\n\r\n    function getUnbondingBalance(address user) external view returns (uint256);\r\n\r\n    function getNextPayment(uint256 loanId) external view returns (uint256);\r\n\r\n    function getNextDueDate(uint256 loanId) external view returns (uint256);\r\n\r\n    function getTotalAssetValue() external view returns (uint256);\r\n\r\n    function getPendingRequestCount() external view returns (uint256);\r\n\r\n    function getCurrentLoansCount() external view returns (uint256);\r\n\r\n    function getDefaultedLoansCount() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/libraries/TransferHelper.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/SafeMath.sol\r\n\r\npragma solidity >=0.6.6;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2Pair.sol\r\n\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/libraries/UniswapV2Library.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex\"ff\",\r\n                            factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            // hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                            //mainnet hash for sushiSwap:\r\n                            hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\"\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\r\n            pairFor(factory, tokenA, tokenB)\r\n        ).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\r\n        require(\r\n            reserveA > 0 && reserveB > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i],\r\n                path[i + 1]\r\n            );\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory,\r\n        uint256 amountOut,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint256 i = path.length - 1; i > 0; i--) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i - 1],\r\n                path[i]\r\n            );\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/DistributionTypes.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary DistributionTypes {\r\n    struct AssetConfigInput {\r\n        uint104 emissionPerSecond;\r\n        uint256 totalStaked;\r\n        address underlyingAsset;\r\n    }\r\n\r\n    struct UserStakeInput {\r\n        address underlyingAsset;\r\n        uint256 stakedByUser;\r\n        uint256 totalStaked;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IAaveDistributionManager.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IAaveDistributionManager {\r\n    event AssetConfigUpdated(address indexed asset, uint256 emission);\r\n    event AssetIndexUpdated(address indexed asset, uint256 index);\r\n    event UserIndexUpdated(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 index\r\n    );\r\n    event DistributionEndUpdated(uint256 newDistributionEnd);\r\n\r\n    /**\r\n     * @dev Sets the end date for the distribution\r\n     * @param distributionEnd The end date timestamp\r\n     **/\r\n    function setDistributionEnd(uint256 distributionEnd) external;\r\n\r\n    /**\r\n     * @dev Gets the end date for the distribution\r\n     * @return The end of the distribution\r\n     **/\r\n    function getDistributionEnd() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev for backwards compatibility with the previous DistributionManager used\r\n     * @return The end of the distribution\r\n     **/\r\n    function DISTRIBUTION_END() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the data of an user on a distribution\r\n     * @param user Address of the user\r\n     * @param asset The address of the reference asset of the distribution\r\n     * @return The new index\r\n     **/\r\n    function getUserAssetData(address user, address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the distribution for a certain asset\r\n     * @param asset The address of the reference asset of the distribution\r\n     * @return The asset index, the emission per second and the last updated timestamp\r\n     **/\r\n    function getAssetData(address asset)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n\r\n// File: contracts/interfaces/IAaveIncentivesController.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IAaveIncentivesController is IAaveDistributionManager {\r\n    event RewardsAccrued(address indexed user, uint256 amount);\r\n\r\n    event RewardsClaimed(\r\n        address indexed user,\r\n        address indexed to,\r\n        address indexed claimer,\r\n        uint256 amount\r\n    );\r\n\r\n    event ClaimerSet(address indexed user, address indexed claimer);\r\n\r\n    /**\r\n     * @dev Whitelists an address to claim the rewards on behalf of another address\r\n     * @param user The address of the user\r\n     * @param claimer The address of the claimer\r\n     */\r\n    function setClaimer(address user, address claimer) external;\r\n\r\n    /**\r\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\r\n     * @param user The address of the user\r\n     * @return The claimer address\r\n     */\r\n    function getClaimer(address user) external view returns (address);\r\n\r\n    /**\r\n     * @dev Configure assets for a certain rewards emission\r\n     * @param assets The assets to incentivize\r\n     * @param emissionsPerSecond The emission for each asset\r\n     */\r\n    function configureAssets(\r\n        address[] calldata assets,\r\n        uint256[] calldata emissionsPerSecond\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\r\n     * @param asset The address of the user\r\n     * @param userBalance The balance of the user of the asset in the lending pool\r\n     * @param totalSupply The total supply of the asset in the lending pool\r\n     **/\r\n    function handleAction(\r\n        address asset,\r\n        uint256 userBalance,\r\n        uint256 totalSupply\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n     * @param user The address of the user\r\n     * @return The rewards\r\n     **/\r\n    function getRewardsBalance(address[] calldata assets, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewards(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n     * @param amount Amount of rewards to claim\r\n     * @param user Address to check and claim rewards\r\n     * @param to Address that will be receiving the rewards\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewardsOnBehalf(\r\n        address[] calldata assets,\r\n        uint256 amount,\r\n        address user,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Claims reward for msg.sender, on all the assets of the lending pool, accumulating the pending rewards\r\n     * @param amount Amount of rewards to claim\r\n     * @return Rewards claimed\r\n     **/\r\n    function claimRewardsToSelf(address[] calldata assets, uint256 amount)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev returns the unclaimed rewards of the user\r\n     * @param user the address of the user\r\n     * @return the unclaimed user rewards\r\n     */\r\n    function getUserUnclaimedRewards(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev for backward compatibility with previous implementation of the Incentives controller\r\n     */\r\n    function REWARD_TOKEN() external view returns (address);\r\n}\r\n\r\n// File: contracts/libraries/DataTypes.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary DataTypes {\r\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //tokens addresses\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint8 id;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: Reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60-63: reserved\r\n        //bit 64-79: reserve factor\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        uint256 data;\r\n    }\r\n\r\n    enum InterestRateMode {\r\n        NONE,\r\n        STABLE,\r\n        VARIABLE\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ILendingPoolAddressesProvider.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event MarketIdSet(string newMarketId);\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    function setMarketId(string calldata marketId) external;\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\n// File: contracts/interfaces/ILendingPool.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface ILendingPool {\r\n    /**\r\n     * @dev Emitted on deposit()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the deposit\r\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n     * @param amount The amount deposited\r\n     * @param referral The referral code used\r\n     **/\r\n    event Deposit(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlyng asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to Address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed\r\n     * @param referral The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referral\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address indexed initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        uint16 referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered.\r\n     */\r\n    event Paused();\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted.\r\n     */\r\n    event Unpaused();\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n     * LendingPoolCollateral manager using a DELEGATECALL\r\n     * This allows to have the events in the generated ABI for LendingPool.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n     * gets added to the LendingPool ABI\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The new liquidity rate\r\n     * @param stableBorrowRate The new stable borrow rate\r\n     * @param variableBorrowRate The new variable borrow rate\r\n     * @param liquidityIndex The new liquidity index\r\n     * @param variableBorrowIndex The new variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param rateMode The rate mode that the user wants to swap to\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n    /**\r\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n     *        borrowed at a stable rate and depositors are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n     * @param asset The address of the underlying asset deposited\r\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n     * For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts amounts being flash-borrowed\r\n     * @param modes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata modes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralETH the total collateral in ETH of the user\r\n     * @return totalDebtETH the total debt in ETH of the user\r\n     * @return availableBorrowsETH the borrowing power left of the user\r\n     * @return currentLiquidationThreshold the liquidation threshold of the user\r\n     * @return ltv the loan to value of the user\r\n     * @return healthFactor the current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralETH,\r\n            uint256 totalDebtETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    function initReserve(\r\n        address reserve,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    function setReserveInterestRateStrategyAddress(\r\n        address reserve,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n    /**\r\n     * @dev Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @dev Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromAfter,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    function getAddressesProvider()\r\n        external\r\n        view\r\n        returns (ILendingPoolAddressesProvider);\r\n\r\n    function setPause(bool val) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = _setInitializedVersion(1);\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\r\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\r\n     * initialization.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        bool isTopLevelCall = _setInitializedVersion(version);\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(version);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        _setInitializedVersion(type(uint8).max);\r\n    }\r\n\r\n    function _setInitializedVersion(uint8 version) private returns (bool) {\r\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\r\n        // of initializers, because in other contexts the contract may have been reentered.\r\n        if (_initializing) {\r\n            require(\r\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\r\n                \"Initializable: contract is already initialized\"\r\n            );\r\n            return false;\r\n        } else {\r\n            require(_initialized < version, \"Initializable: contract is already initialized\");\r\n            _initialized = version;\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/BankingNode.sol\r\n\r\n\r\n\r\n// NOTE: BankingNode.sol should only be created through the BNPLFactory contract to\r\n// ensure compatibility of baseToken and minimum bond amounts. Before interacting,\r\n// please ensure that the contract deployer was BNPLFactory.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//CUSTOM ERRORS\r\n\r\n//occurs when trying to do privledged functions\r\nerror InvalidUser(address requiredUser);\r\n//occurs when users try to add funds if node operator hasn't maintaioned enough pledged BNPL\r\nerror NodeInactive();\r\n//occurs when trying to interact without being KYC's (if node requires it)\r\nerror KYCNotApproved();\r\n//occurs when trying to pay loans that are completed or not started\r\nerror NoPrincipalRemaining();\r\n//occurs when trying to swap/deposit/withdraw a zero\r\nerror ZeroInput();\r\n//occurs if interest rate, loanAmount, or paymentInterval or is applied as 0\r\nerror InvalidLoanInput();\r\n//occurs if trying to apply for a loan with >5 year loan length\r\nerror MaximumLoanDurationExceeded();\r\n//occurs if user tries to withdraw collateral while loan is still ongoing\r\nerror LoanStillOngoing();\r\n//edge case occurence if all BNPL is slashed, but there are still BNPL shares\r\nerror DonationRequired();\r\n//occurs if operator tries to unstake while there are active loans\r\nerror ActiveLoansOngoing();\r\n//occurs when trying to withdraw too much funds\r\nerror InsufficientBalance();\r\n//occurs during swaps, if amount received is lower than minOut (slippage tolerance exceeded)\r\nerror InsufficentOutput();\r\n//occurs if trying to approve a loan that has already started\r\nerror LoanAlreadyStarted();\r\n//occurs if trying to approve a loan without enough collateral posted\r\nerror InsufficientCollateral();\r\n//occurs when trying to slash a loan that is not yet considered defaulted\r\nerror LoanNotExpired();\r\n//occurs is trying to slash an already slashed loan\r\nerror LoanAlreadySlashed();\r\n//occurs if trying to withdraw staked BNPL where 7 day unbonding hasnt passed\r\nerror LoanStillUnbonding();\r\n//occurs if trying to post baseToken as collateral\r\nerror InvalidCollateral();\r\n//first deposit to prevent edge case must be at least 10M wei\r\nerror InvalidInitialDeposit();\r\n\r\ncontract BankingNode is ERC20(\"BNPL USD\", \"pUSD\") {\r\n    //Node specific variables\r\n    address public operator;\r\n    address public baseToken; //base liquidity token, e.g. USDT or USDC\r\n    uint256 public gracePeriod;\r\n    bool public requireKYC;\r\n\r\n    //variables used for swaps, private to reduce contract size\r\n    address private uniswapFactory;\r\n    address private WETH;\r\n    uint256 private incrementor;\r\n\r\n    //constants set by factory\r\n    address public BNPL;\r\n    ILendingPoolAddressesProvider public lendingPoolProvider;\r\n    address public immutable bnplFactory;\r\n    //used by treasury can be private\r\n    IAaveIncentivesController private aaveRewardController;\r\n    address private treasury;\r\n\r\n    //For loans\r\n    mapping(uint256 => Loan) public idToLoan;\r\n    uint256[] public pendingRequests;\r\n    uint256[] public currentLoans;\r\n    mapping(uint256 => uint256) defaultedLoans;\r\n    uint256 public defaultedLoanCount;\r\n\r\n    //For Staking, Slashing and Balances\r\n    uint256 public accountsReceiveable;\r\n    mapping(address => bool) public whitelistedAddresses;\r\n    mapping(address => uint256) public unbondBlock;\r\n    mapping(uint256 => address) public loanToAgent;\r\n    uint256 public slashingBalance;\r\n    mapping(address => uint256) public stakingShares;\r\n    //can be private as there is a getter function for staking balance\r\n    uint256 public totalStakingShares;\r\n\r\n    uint256 public unbondingAmount;\r\n    mapping(address => uint256) public unbondingShares;\r\n    //can be private as there is getter function for unbonding balance\r\n    uint256 private totalUnbondingShares;\r\n    uint256 public timeCreated;\r\n\r\n    //For Collateral in loans\r\n    mapping(address => uint256) public collateralOwed;\r\n\r\n    struct Loan {\r\n        address borrower;\r\n        bool interestOnly; //interest only or principal + interest\r\n        uint256 loanStartTime; //unix timestamp of start\r\n        uint256 loanAmount;\r\n        uint256 paymentInterval; //unix interval of payment (e.g. monthly = 2,628,000)\r\n        uint256 interestRate; //interest rate per peiod * 10000, e.g., 10% on a 12 month loan = : 0.1 * 10000 / 12 = 83\r\n        uint256 numberOfPayments;\r\n        uint256 principalRemaining;\r\n        uint256 paymentsMade;\r\n        address collateral;\r\n        uint256 collateralAmount;\r\n        bool isSlashed;\r\n    }\r\n\r\n    //EVENTS\r\n    event LoanRequest(uint256 loanId, string message);\r\n    event collateralWithdrawn(\r\n        uint256 loanId,\r\n        address collateral,\r\n        uint256 collateralAmount\r\n    );\r\n    event approvedLoan(uint256 loanId);\r\n    event loanPaymentMade(uint256 loanId);\r\n    event loanRepaidEarly(uint256 loanId);\r\n    event baseTokenDeposit(address user, uint256 amount);\r\n    event baseTokenWithdrawn(address user, uint256 amount);\r\n    event feesCollected(uint256 operatorFees, uint256 stakerFees);\r\n    event baseTokensDonated(uint256 amount);\r\n    event loanSlashed(uint256 loanId);\r\n    event slashingSale(uint256 bnplSold, uint256 baseTokenRecovered);\r\n    event bnplStaked(address user, uint256 bnplStaked);\r\n    event unbondingInitiated(address user, uint256 unbondAmount);\r\n    event bnplWithdrawn(address user, uint256 bnplWithdrawn);\r\n    event KYCRequirementChanged(bool newStatus);\r\n\r\n    constructor() {\r\n        bnplFactory = msg.sender;\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    /**\r\n     * Ensure a node is active for deposit, stake functions\r\n     * Require KYC is also batched in\r\n     */\r\n    modifier ensureNodeActive() {\r\n        address _operator = operator;\r\n        if (msg.sender != bnplFactory && msg.sender != _operator) {\r\n            if (getBNPLBalance(_operator) < 0x13DA329B6336471800000) {\r\n                revert NodeInactive();\r\n            }\r\n            if (requireKYC && whitelistedAddresses[msg.sender] == false) {\r\n                revert KYCNotApproved();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Ensure that the loan has principal to be paid\r\n     */\r\n    modifier ensurePrincipalRemaining(uint256 loanId) {\r\n        if (idToLoan[loanId].principalRemaining == 0) {\r\n            revert NoPrincipalRemaining();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * For operator only functions\r\n     */\r\n    modifier operatorOnly() {\r\n        address _operator = operator;\r\n        if (msg.sender != _operator) {\r\n            revert InvalidUser(_operator);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Requires input value to be non-zero\r\n     */\r\n    modifier nonZeroInput(uint256 input) {\r\n        if (input == 0) {\r\n            revert ZeroInput();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Ensures collateral is not the baseToken\r\n     */\r\n    modifier nonBaseToken(address collateral) {\r\n        if (collateral == baseToken) {\r\n            revert InvalidCollateral();\r\n        }\r\n        _;\r\n    }\r\n\r\n    //STATE CHANGING FUNCTIONS\r\n\r\n    /**\r\n     * Called once by the factory at time of deployment\r\n     */\r\n    function initialize(\r\n        address _baseToken,\r\n        address _BNPL,\r\n        bool _requireKYC,\r\n        address _operator,\r\n        uint256 _gracePeriod,\r\n        address _lendingPoolProvider,\r\n        address _WETH,\r\n        address _aaveDistributionController,\r\n        address _uniswapFactory\r\n    ) external {\r\n        //only to be done by factory, no need for error msgs in here as not used by users\r\n        require(msg.sender == bnplFactory);\r\n        baseToken = _baseToken;\r\n        BNPL = _BNPL;\r\n        requireKYC = _requireKYC;\r\n        operator = _operator;\r\n        gracePeriod = _gracePeriod;\r\n        lendingPoolProvider = ILendingPoolAddressesProvider(\r\n            _lendingPoolProvider\r\n        );\r\n        aaveRewardController = IAaveIncentivesController(\r\n            _aaveDistributionController\r\n        );\r\n        WETH = _WETH;\r\n        uniswapFactory = _uniswapFactory;\r\n        treasury = address(0x27a99802FC48b57670846AbFFf5F2DcDE8a6fC29);\r\n        timeCreated = block.timestamp;\r\n        //decimal check on baseToken and aToken to make sure math logic on future steps\r\n        require(\r\n            ERC20(_baseToken).decimals() ==\r\n                ERC20(\r\n                    _getLendingPool().getReserveData(_baseToken).aTokenAddress\r\n                ).decimals()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Request a loan from the banking node\r\n     * Saves the loan with the operator able to approve or reject\r\n     * Can post collateral if chosen, collateral accepted is anything that is accepted by aave\r\n     * Collateral can not be the same token as baseToken\r\n     */\r\n    function requestLoan(\r\n        uint256 loanAmount,\r\n        uint256 paymentInterval,\r\n        uint256 numberOfPayments,\r\n        uint256 interestRate,\r\n        bool interestOnly,\r\n        address collateral,\r\n        uint256 collateralAmount,\r\n        address agent,\r\n        string memory message\r\n    )\r\n        external\r\n        ensureNodeActive\r\n        nonBaseToken(collateral)\r\n        returns (uint256 requestId)\r\n    {\r\n        if (\r\n            loanAmount < 10000000 ||\r\n            paymentInterval == 0 ||\r\n            interestRate == 0 ||\r\n            numberOfPayments == 0\r\n        ) {\r\n            revert InvalidLoanInput();\r\n        }\r\n        //157,680,000 seconds in 5 years\r\n        if (paymentInterval * numberOfPayments > 157680000) {\r\n            revert MaximumLoanDurationExceeded();\r\n        }\r\n        requestId = incrementor;\r\n        incrementor++;\r\n        pendingRequests.push(requestId);\r\n        idToLoan[requestId] = Loan(\r\n            msg.sender, //set borrower\r\n            interestOnly,\r\n            0, //start time initiated to 0\r\n            loanAmount,\r\n            paymentInterval, //interval of payments (e.g. Monthly)\r\n            interestRate, //annualized interest rate per period * 10000 (e.g. 12 month loan 10% = 83)\r\n            numberOfPayments,\r\n            0, //initalize principalRemaining to 0\r\n            0, //intialize paymentsMade to 0\r\n            collateral,\r\n            collateralAmount,\r\n            false\r\n        );\r\n        //post the collateral if any\r\n        if (collateralAmount > 0) {\r\n            //update the collateral owed (interest accrued on collateral is given to lend)\r\n            collateralOwed[collateral] += collateralAmount;\r\n            TransferHelper.safeTransferFrom(\r\n                collateral,\r\n                msg.sender,\r\n                address(this),\r\n                collateralAmount\r\n            );\r\n            //deposit the collateral in AAVE to accrue interest\r\n            _depositToLendingPool(collateral, collateralAmount);\r\n        }\r\n        //save the agent of the loan\r\n        loanToAgent[requestId] = agent;\r\n\r\n        emit LoanRequest(requestId, message);\r\n    }\r\n\r\n    /**\r\n     * Withdraw the collateral from a loan\r\n     * Loan must have no principal remaining (not approved, or payments finsihed)\r\n     */\r\n    function withdrawCollateral(uint256 loanId) external {\r\n        Loan storage loan = idToLoan[loanId];\r\n        address collateral = loan.collateral;\r\n        uint256 amount = loan.collateralAmount;\r\n\r\n        //must be the borrower or operator to withdraw, and loan must be either paid/not initiated\r\n        if (msg.sender != loan.borrower) {\r\n            revert InvalidUser(loan.borrower);\r\n        }\r\n        if (loan.principalRemaining > 0) {\r\n            revert LoanStillOngoing();\r\n        }\r\n\r\n        //update the amounts\r\n        collateralOwed[collateral] -= amount;\r\n        loan.collateralAmount = 0;\r\n\r\n        //no need to check if loan is slashed as collateral amont set to 0 on slashing\r\n        _withdrawFromLendingPool(collateral, amount, loan.borrower);\r\n        emit collateralWithdrawn(loanId, collateral, amount);\r\n    }\r\n\r\n    /**\r\n     * Collect AAVE rewards to be sent to the treasury\r\n     */\r\n    function collectAaveRewards(address[] calldata assets) external {\r\n        uint256 rewardAmount = aaveRewardController.getUserUnclaimedRewards(\r\n            address(this)\r\n        );\r\n        address _treasuy = treasury;\r\n        if (rewardAmount == 0) {\r\n            revert ZeroInput();\r\n        }\r\n        //claim rewards to the treasury\r\n        aaveRewardController.claimRewards(assets, rewardAmount, _treasuy);\r\n        //no need for event as its a function that will only be used by treasury\r\n    }\r\n\r\n    /**\r\n     * Collect the interest earnt on collateral posted to distribute to stakers\r\n     * Collateral can not be the same as baseToken\r\n     */\r\n    function collectCollateralFees(address collateral)\r\n        external\r\n        nonBaseToken(collateral)\r\n    {\r\n        //get the aToken address\r\n        ILendingPool lendingPool = _getLendingPool();\r\n        address _bnpl = BNPL;\r\n        uint256 feesAccrued = IERC20(\r\n            lendingPool.getReserveData(collateral).aTokenAddress\r\n        ).balanceOf(address(this)) - collateralOwed[collateral];\r\n        //ensure there is collateral to collect inside of _swap\r\n        lendingPool.withdraw(collateral, feesAccrued, address(this));\r\n        //no slippage for small swaps\r\n        _swapToken(collateral, _bnpl, 0, feesAccrued);\r\n    }\r\n\r\n    /*\r\n     * Make a loan payment\r\n     */\r\n    function makeLoanPayment(uint256 loanId)\r\n        external\r\n        ensurePrincipalRemaining(loanId)\r\n    {\r\n        Loan storage loan = idToLoan[loanId];\r\n        uint256 paymentAmount = getNextPayment(loanId);\r\n        uint256 interestPortion = (loan.principalRemaining *\r\n            loan.interestRate) / 10000;\r\n        address _baseToken = baseToken;\r\n        loan.paymentsMade++;\r\n        //reduce accounts receiveable and loan principal if principal + interest payment\r\n        bool finalPayment = loan.paymentsMade == loan.numberOfPayments;\r\n\r\n        if (!loan.interestOnly) {\r\n            uint256 principalPortion = paymentAmount - interestPortion;\r\n            loan.principalRemaining -= principalPortion;\r\n            accountsReceiveable -= principalPortion;\r\n        } else {\r\n            //interest only, principal change only on final payment\r\n            if (finalPayment) {\r\n                accountsReceiveable -= loan.principalRemaining;\r\n                loan.principalRemaining = 0;\r\n            }\r\n        }\r\n        //make payment\r\n        TransferHelper.safeTransferFrom(\r\n            _baseToken,\r\n            msg.sender,\r\n            address(this),\r\n            paymentAmount\r\n        );\r\n        //deposit the tokens into AAVE on behalf of the pool contract, withholding 30% and the interest as baseToken\r\n        _depositToLendingPool(\r\n            _baseToken,\r\n            paymentAmount - ((interestPortion * 3) / 10)\r\n        );\r\n        //remove if final payment\r\n        if (finalPayment) {\r\n            _removeCurrentLoan(loanId);\r\n        }\r\n        //increment the loan status\r\n\r\n        emit loanPaymentMade(loanId);\r\n    }\r\n\r\n    /**\r\n     * Repay remaining balance to save on interest cost\r\n     * Payment amount is remaining principal + 1 period of interest\r\n     */\r\n    function repayEarly(uint256 loanId)\r\n        external\r\n        ensurePrincipalRemaining(loanId)\r\n    {\r\n        Loan storage loan = idToLoan[loanId];\r\n        uint256 principalLeft = loan.principalRemaining;\r\n        //make a payment of remaining principal + 1 period of interest\r\n        uint256 interestAmount = (principalLeft * loan.interestRate) / 10000;\r\n        uint256 paymentAmount = principalLeft + interestAmount;\r\n        address _baseToken = baseToken;\r\n\r\n        //update accounts\r\n        accountsReceiveable -= principalLeft;\r\n        loan.principalRemaining = 0;\r\n        //increment the loan status to final and remove from current loans array\r\n        loan.paymentsMade = loan.numberOfPayments;\r\n        _removeCurrentLoan(loanId);\r\n\r\n        //make payment\r\n        TransferHelper.safeTransferFrom(\r\n            _baseToken,\r\n            msg.sender,\r\n            address(this),\r\n            paymentAmount\r\n        );\r\n        //deposit withholding 30% of the interest as fees\r\n        _depositToLendingPool(\r\n            _baseToken,\r\n            paymentAmount - ((interestAmount * 3) / 10)\r\n        );\r\n\r\n        emit loanRepaidEarly(loanId);\r\n    }\r\n\r\n    /**\r\n     * Converts the baseToken (e.g. USDT) 20% BNPL for stakers, and sends 10% to the Banking Node Operator\r\n     * Slippage set to 0 here as they would be small purchases of BNPL\r\n     */\r\n    function collectFees() external {\r\n        //requirement check for nonzero inside of _swap\r\n        //33% to go to operator as baseToken\r\n        address _baseToken = baseToken;\r\n        address _bnpl = BNPL;\r\n        address _operator = operator;\r\n        uint256 _operatorFees = IERC20(_baseToken).balanceOf(address(this)) / 3;\r\n        TransferHelper.safeTransfer(_baseToken, _operator, _operatorFees);\r\n        //remainder (67%) is traded for staking rewards\r\n        //no need for slippage on small trade\r\n        uint256 _stakingRewards = _swapToken(\r\n            _baseToken,\r\n            _bnpl,\r\n            0,\r\n            IERC20(_baseToken).balanceOf(address(this))\r\n        );\r\n        emit feesCollected(_operatorFees, _stakingRewards);\r\n    }\r\n\r\n    /**\r\n     * Deposit liquidity to the banking node in the baseToken (e.g. usdt) specified\r\n     * Mints tokens, with check on decimals of base tokens\r\n     */\r\n    function deposit(uint256 _amount)\r\n        external\r\n        ensureNodeActive\r\n        nonZeroInput(_amount)\r\n    {\r\n        //First deposit must be at least 10M wei to prevent initial attack\r\n        if (getTotalAssetValue() == 0 && _amount < 10000000) {\r\n            revert InvalidInitialDeposit();\r\n        }\r\n        //check the decimals of the baseTokens\r\n        address _baseToken = baseToken;\r\n        uint256 decimalAdjust = 1;\r\n        uint256 tokenDecimals = ERC20(_baseToken).decimals();\r\n        if (tokenDecimals != 18) {\r\n            decimalAdjust = 10**(18 - tokenDecimals);\r\n        }\r\n        //get the amount of tokens to mint\r\n        uint256 what = _amount * decimalAdjust;\r\n        if (totalSupply() != 0) {\r\n            //no need to decimal adjust here as total asset value adjusts\r\n            //unable to deposit if getTotalAssetValue() == 0 and totalSupply() != 0, but this\r\n            //should never occur as defaults will get slashed for some base token recovery\r\n            what = (_amount * totalSupply()) / getTotalAssetValue();\r\n        }\r\n        //transfer tokens from the user and mint\r\n        TransferHelper.safeTransferFrom(\r\n            _baseToken,\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        _mint(msg.sender, what);\r\n\r\n        _depositToLendingPool(_baseToken, _amount);\r\n\r\n        emit baseTokenDeposit(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw liquidity from the banking node\r\n     * To avoid need to decimal adjust, input _amount is in USDT(or equiv) to withdraw\r\n     * , not BNPL USD to burn\r\n     */\r\n    function withdraw(uint256 _amount) external nonZeroInput(_amount) {\r\n        uint256 userBaseBalance = getBaseTokenBalance(msg.sender);\r\n        if (userBaseBalance < _amount) {\r\n            revert InsufficientBalance();\r\n        }\r\n        //safe div, if _amount > 0, asset value always >0;\r\n        uint256 what = (_amount * totalSupply()) / getTotalAssetValue();\r\n        address _baseToken = baseToken;\r\n        _burn(msg.sender, what);\r\n        //non-zero revert with checked in \"_withdrawFromLendingPool\"\r\n        _withdrawFromLendingPool(_baseToken, _amount, msg.sender);\r\n\r\n        emit baseTokenWithdrawn(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Stake BNPL into a node\r\n     */\r\n    function stake(uint256 _amount)\r\n        external\r\n        ensureNodeActive\r\n        nonZeroInput(_amount)\r\n    {\r\n        address staker = msg.sender;\r\n        //factory initial bond counted as operator\r\n        if (msg.sender == bnplFactory) {\r\n            staker = operator;\r\n        }\r\n        //calcualte the number of shares to give\r\n        uint256 what = _amount;\r\n        uint256 _totalStakingShares = totalStakingShares;\r\n        if (_totalStakingShares > 0) {\r\n            //edge case - if totalStakingShares != 0, but all bnpl has been slashed:\r\n            //node will require a donation to work again\r\n            uint256 totalStakedBNPL = getStakedBNPL();\r\n            if (totalStakedBNPL == 0) {\r\n                revert DonationRequired();\r\n            }\r\n            what = (_amount * _totalStakingShares) / totalStakedBNPL;\r\n        }\r\n        //collect the BNPL\r\n        address _bnpl = BNPL;\r\n        TransferHelper.safeTransferFrom(\r\n            _bnpl,\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        //issue the shares\r\n        stakingShares[staker] += what;\r\n        totalStakingShares += what;\r\n\r\n        emit bnplStaked(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Unbond BNPL from a node, input is the number shares (sBNPL)\r\n     * Requires a 7 day unbond to prevent frontrun of slashing events or interest repayments\r\n     * Operator can not unstake unless there are no loans active\r\n     */\r\n    function initiateUnstake(uint256 _amount) external nonZeroInput(_amount) {\r\n        //operator cannot withdraw unless there are no active loans\r\n        address _operator = operator;\r\n        if (msg.sender == _operator && currentLoans.length > 0) {\r\n            revert ActiveLoansOngoing();\r\n        }\r\n        uint256 stakingSharesUser = stakingShares[msg.sender];\r\n        //require the user has enough\r\n        if (stakingShares[msg.sender] < _amount) {\r\n            revert InsufficientBalance();\r\n        }\r\n        //set the time of the unbond\r\n        unbondBlock[msg.sender] = block.number;\r\n        //get the amount of BNPL to issue back\r\n        //safe div: if user staking shares >0, totalStakingShares always > 0\r\n        uint256 what = (_amount * getStakedBNPL()) / totalStakingShares;\r\n        //subtract the number of shares of BNPL from the user\r\n        stakingShares[msg.sender] -= _amount;\r\n        totalStakingShares -= _amount;\r\n        //initiate as 1:1 for unbonding shares with BNPL sent\r\n        uint256 _newUnbondingShares = what;\r\n        uint256 _unbondingAmount = unbondingAmount;\r\n        //update amount if there is a pool of unbonding\r\n        if (_unbondingAmount != 0) {\r\n            _newUnbondingShares =\r\n                (what * totalUnbondingShares) /\r\n                _unbondingAmount;\r\n        }\r\n        //add the balance to their unbonding\r\n        unbondingShares[msg.sender] += _newUnbondingShares;\r\n        totalUnbondingShares += _newUnbondingShares;\r\n        unbondingAmount += what;\r\n\r\n        emit unbondingInitiated(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw BNPL from a bond once unbond period ends\r\n     * Unbonding period is 46523 blocks (~7 days assuming a 13s avg. block time)\r\n     */\r\n    function unstake() external {\r\n        uint256 _userAmount = unbondingShares[msg.sender];\r\n        if (_userAmount == 0) {\r\n            revert ZeroInput();\r\n        }\r\n        //assuming 13s block, 46523 blocks for 1 week\r\n        if (block.number < unbondBlock[msg.sender] + 46523) {\r\n            revert LoanStillUnbonding();\r\n        }\r\n        uint256 _unbondingAmount = unbondingAmount;\r\n        uint256 _totalUnbondingShares = totalUnbondingShares;\r\n        address _bnpl = BNPL;\r\n        //safe div: if user amount > 0, then totalUnbondingShares always > 0\r\n        uint256 _what = (_userAmount * _unbondingAmount) /\r\n            _totalUnbondingShares;\r\n        //update the balances\r\n        unbondingShares[msg.sender] = 0;\r\n        unbondingAmount -= _what;\r\n        totalUnbondingShares -= _userAmount;\r\n\r\n        //transfer the tokens to user\r\n        TransferHelper.safeTransfer(_bnpl, msg.sender, _what);\r\n        emit bnplWithdrawn(msg.sender, _what);\r\n    }\r\n\r\n    /**\r\n     * Declare a loan defaulted and slash the loan\r\n     * Can be called by anyone\r\n     * Move BNPL to a slashing balance, to be sold in seperate function\r\n     * minOut used for sale of collateral, if no collateral, put 0\r\n     */\r\n    function slashLoan(uint256 loanId, uint256 minOut)\r\n        external\r\n        ensurePrincipalRemaining(loanId)\r\n    {\r\n        //Step 1. load loan as local variable\r\n        Loan storage loan = idToLoan[loanId];\r\n\r\n        //Step 2. requirement checks: loan is ongoing and expired past grace period\r\n        if (loan.isSlashed) {\r\n            revert LoanAlreadySlashed();\r\n        }\r\n        if (block.timestamp <= getNextDueDate(loanId) + gracePeriod) {\r\n            revert LoanNotExpired();\r\n        }\r\n\r\n        //Step 3, Check if theres any collateral to slash\r\n        uint256 _collateralPosted = loan.collateralAmount;\r\n        uint256 baseTokenOut = 0;\r\n        address _baseToken = baseToken;\r\n        if (_collateralPosted > 0) {\r\n            //Step 3a. load local variables\r\n            address _collateral = loan.collateral;\r\n\r\n            //Step 3b. update the colleral owed and loan amounts\r\n            collateralOwed[_collateral] -= _collateralPosted;\r\n            loan.collateralAmount = 0;\r\n\r\n            //Step 3c. withdraw collateral from aave\r\n            _withdrawFromLendingPool(\r\n                _collateral,\r\n                _collateralPosted,\r\n                address(this)\r\n            );\r\n            //Step 3d. sell collateral for baseToken\r\n            baseTokenOut = _swapToken(\r\n                _collateral,\r\n                _baseToken,\r\n                minOut,\r\n                _collateralPosted\r\n            );\r\n            //Step 3e. deposit the recovered baseTokens to aave\r\n            _depositToLendingPool(_baseToken, baseTokenOut);\r\n        }\r\n        //Step 4. calculate the amount to be slashed\r\n        uint256 principalLost = loan.principalRemaining;\r\n        //Check if there was a full recovery for the loan, if so\r\n        if (baseTokenOut >= principalLost) {\r\n            //return excess to the lender (if any)\r\n            _withdrawFromLendingPool(\r\n                _baseToken,\r\n                baseTokenOut - principalLost,\r\n                loan.borrower\r\n            );\r\n        }\r\n        //slash loan only if losses are greater than recovered\r\n        else {\r\n            principalLost -= baseTokenOut;\r\n            //safe div: principal > 0 => totalassetvalue > 0\r\n            uint256 slashPercent = (1e12 * principalLost) /\r\n                getTotalAssetValue();\r\n            uint256 unbondingSlash = (unbondingAmount * slashPercent) / 1e12;\r\n            uint256 stakingSlash = (getStakedBNPL() * slashPercent) / 1e12;\r\n            //Step 5. deduct slashed from respective balances\r\n            accountsReceiveable -= principalLost;\r\n            slashingBalance += unbondingSlash + stakingSlash;\r\n            unbondingAmount -= unbondingSlash;\r\n        }\r\n\r\n        //Step 6. remove loan from currentLoans and add to defaulted loans\r\n        defaultedLoans[defaultedLoanCount] = loanId;\r\n        defaultedLoanCount++;\r\n\r\n        loan.isSlashed = true;\r\n        _removeCurrentLoan(loanId);\r\n        emit loanSlashed(loanId);\r\n    }\r\n\r\n    /**\r\n     * Sell the slashing balance of BNPL to give to lenders as <aBaseToken>\r\n     * Slashing sale moved to seperate function to simplify logic with minOut\r\n     */\r\n    function sellSlashed(uint256 minOut) external {\r\n        //Step 1. load local variables\r\n        address _baseToken = baseToken;\r\n        address _bnpl = BNPL;\r\n        uint256 _slashingBalance = slashingBalance;\r\n        //Step 2. check there is a balance to sell\r\n        if (_slashingBalance == 0) {\r\n            revert ZeroInput();\r\n        }\r\n        //Step 3. sell the slashed BNPL for baseToken\r\n        uint256 baseTokenOut = _swapToken(\r\n            _bnpl,\r\n            _baseToken,\r\n            minOut,\r\n            _slashingBalance\r\n        );\r\n        //Step 4. deposit baseToken received to aave and update slashing balance\r\n        slashingBalance = 0;\r\n        _depositToLendingPool(_baseToken, baseTokenOut);\r\n\r\n        emit slashingSale(_slashingBalance, baseTokenOut);\r\n    }\r\n\r\n    /**\r\n     * Donate baseToken for when debt is collected post default\r\n     * BNPL can be donated by simply sending it to the contract\r\n     */\r\n    function donateBaseToken(uint256 _amount) external nonZeroInput(_amount) {\r\n        //Step 1. load local variables\r\n        address _baseToken = baseToken;\r\n        //Step 2. collect the baseTokens\r\n        TransferHelper.safeTransferFrom(\r\n            _baseToken,\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        //Step 3. deposit baseToken to aave\r\n        _depositToLendingPool(_baseToken, _amount);\r\n\r\n        emit baseTokensDonated(_amount);\r\n    }\r\n\r\n    //OPERATOR ONLY FUNCTIONS\r\n\r\n    /**\r\n     * Approve a pending loan request\r\n     * Ensures collateral amount has been posted to prevent front run withdrawal\r\n     */\r\n    function approveLoan(uint256 loanId, uint256 requiredCollateralAmount)\r\n        external\r\n        operatorOnly\r\n    {\r\n        Loan storage loan = idToLoan[loanId];\r\n        uint256 length = pendingRequests.length;\r\n        uint256 loanSize = loan.loanAmount;\r\n        address _baseToken = baseToken;\r\n\r\n        if (getBNPLBalance(operator) < 0x13DA329B6336471800000) {\r\n            revert NodeInactive();\r\n        }\r\n        //ensure the loan was never started and collateral enough\r\n        if (loan.loanStartTime > 0) {\r\n            revert LoanAlreadyStarted();\r\n        }\r\n        if (loan.collateralAmount < requiredCollateralAmount) {\r\n            revert InsufficientCollateral();\r\n        }\r\n\r\n        //remove from loanRequests and add loan to current loans\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (loanId == pendingRequests[i]) {\r\n                pendingRequests[i] = pendingRequests[length - 1];\r\n                pendingRequests.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        currentLoans.push(loanId);\r\n\r\n        //add the principal remaining and start the loan\r\n\r\n        loan.principalRemaining = loanSize;\r\n        loan.loanStartTime = block.timestamp;\r\n        accountsReceiveable += loanSize;\r\n        //send the funds and update accounts (minus 0.5% origination fee)\r\n\r\n        _withdrawFromLendingPool(\r\n            _baseToken,\r\n            (loanSize * 199) / 200,\r\n            loan.borrower\r\n        );\r\n        //send the 0.25% origination fee to treasury and agent\r\n        _withdrawFromLendingPool(_baseToken, loanSize / 400, treasury);\r\n        _withdrawFromLendingPool(\r\n            _baseToken,\r\n            loanSize / 400,\r\n            loanToAgent[loanId]\r\n        );\r\n\r\n        emit approvedLoan(loanId);\r\n    }\r\n\r\n    /**\r\n     * Used to reject all current pending loan requests\r\n     */\r\n    function clearPendingLoans() external operatorOnly {\r\n        pendingRequests = new uint256[](0);\r\n    }\r\n\r\n    /**\r\n     * Whitelist or delist a given list of addresses\r\n     * Only relevant on KYC nodes\r\n     */\r\n    function whitelistAddresses(\r\n        address[] memory whitelistAddition,\r\n        bool _status\r\n    ) external operatorOnly {\r\n        uint256 length = whitelistAddition.length;\r\n        for (uint256 i; i < length; i++) {\r\n            address newWhistelist = whitelistAddition[i];\r\n            whitelistedAddresses[newWhistelist] = _status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the KYC Status of a node\r\n     */\r\n    function setKYC(bool _newStatus) external operatorOnly {\r\n        requireKYC = _newStatus;\r\n        emit KYCRequirementChanged(_newStatus);\r\n    }\r\n\r\n    //PRIVATE FUNCTIONS\r\n\r\n    /**\r\n     * Deposit token onto AAVE lending pool, receiving aTokens in return\r\n     */\r\n    function _depositToLendingPool(address tokenIn, uint256 amountIn) private {\r\n        address _lendingPool = address(_getLendingPool());\r\n        TransferHelper.safeApprove(tokenIn, _lendingPool, 0);\r\n        TransferHelper.safeApprove(tokenIn, _lendingPool, amountIn);\r\n        _getLendingPool().deposit(tokenIn, amountIn, address(this), 0);\r\n    }\r\n\r\n    /**\r\n     * Withdraw token from AAVE lending pool, converting from aTokens to ERC20 equiv\r\n     */\r\n    function _withdrawFromLendingPool(\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        address to\r\n    ) private nonZeroInput(amountOut) {\r\n        _getLendingPool().withdraw(tokenOut, amountOut, to);\r\n    }\r\n\r\n    /**\r\n     * Get the latest AAVE Lending Pool contract\r\n     */\r\n    function _getLendingPool() private view returns (ILendingPool) {\r\n        return ILendingPool(lendingPoolProvider.getLendingPool());\r\n    }\r\n\r\n    /**\r\n     * Remove given loan from current loan list\r\n     */\r\n    function _removeCurrentLoan(uint256 loanId) private {\r\n        for (uint256 i = 0; i < currentLoans.length; i++) {\r\n            if (loanId == currentLoans[i]) {\r\n                currentLoans[i] = currentLoans[currentLoans.length - 1];\r\n                currentLoans.pop();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Swaps given token, with path of length 3, tokenIn => WETH => tokenOut\r\n     * Uses Sushiswap pairs only\r\n     * Ensures slippage with minOut\r\n     */\r\n    function _swapToken(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 minOut,\r\n        uint256 amountIn\r\n    ) private returns (uint256 tokenOutput) {\r\n        if (amountIn == 0) {\r\n            revert ZeroInput();\r\n        }\r\n        //Step 1. load data to local variables\r\n        address _uniswapFactory = uniswapFactory;\r\n        address _weth = WETH;\r\n        address pair1 = UniswapV2Library.pairFor(\r\n            _uniswapFactory,\r\n            tokenIn,\r\n            _weth\r\n        );\r\n        address pair2 = UniswapV2Library.pairFor(\r\n            _uniswapFactory,\r\n            _weth,\r\n            tokenOut\r\n        );\r\n        //if tokenIn = weth, only need to swap with pair2 with amountIn as input\r\n        if (tokenIn == _weth) {\r\n            pair1 = pair2;\r\n            tokenOutput = amountIn;\r\n        }\r\n        //Step 2. transfer the tokens to first pair (pair 2 if tokenIn == weth)\r\n        TransferHelper.safeTransfer(tokenIn, pair1, amountIn);\r\n        //Step 3. Swap tokenIn to WETH (only if tokenIn != weth)\r\n        if (tokenIn != _weth) {\r\n            tokenOutput = _swap(tokenIn, _weth, amountIn, pair1, pair2);\r\n        }\r\n        //Step 4. Swap ETH for tokenOut\r\n        tokenOutput = _swap(_weth, tokenOut, tokenOutput, pair2, address(this));\r\n        //Step 5. Check slippage parameters\r\n        if (minOut > tokenOutput) {\r\n            revert InsufficentOutput();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function for _swapToken\r\n     * Modified from uniswap router to save gas, makes a single trade\r\n     * with uniswap pair without needing address[] path or uit256[] amounts\r\n     */\r\n    function _swap(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        address pair,\r\n        address to\r\n    ) private returns (uint256 tokenOutput) {\r\n        address _uniswapFactory = uniswapFactory;\r\n        //Step 1. get the reserves of each token\r\n        (uint256 reserveIn, uint256 reserveOut) = UniswapV2Library.getReserves(\r\n            _uniswapFactory,\r\n            tokenIn,\r\n            tokenOut\r\n        );\r\n        //Step 2. get the tokens that will be received\r\n        tokenOutput = UniswapV2Library.getAmountOut(\r\n            amountIn,\r\n            reserveIn,\r\n            reserveOut\r\n        );\r\n        //Step 3. sort the tokens to pass IUniswapV2Pair\r\n        (address token0, ) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\r\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == token0\r\n            ? (uint256(0), tokenOutput)\r\n            : (tokenOutput, uint256(0));\r\n        //Step 4. make the trade\r\n        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\r\n    }\r\n\r\n    //VIEW ONLY FUNCTIONS\r\n\r\n    /**\r\n     * Get the total BNPL in the staking account\r\n     * Given by (total BNPL of node) - (unbonding balance) - (slashing balance)\r\n     */\r\n    function getStakedBNPL() public view returns (uint256) {\r\n        return\r\n            IERC20(BNPL).balanceOf(address(this)) -\r\n            unbondingAmount -\r\n            slashingBalance;\r\n    }\r\n\r\n    /**\r\n     * Gets the given users balance in baseToken\r\n     */\r\n    function getBaseTokenBalance(address user) public view returns (uint256) {\r\n        uint256 _balance = balanceOf(user);\r\n        if (totalSupply() == 0) {\r\n            return 0;\r\n        }\r\n        return (_balance * getTotalAssetValue()) / totalSupply();\r\n    }\r\n\r\n    /**\r\n     * Get the value of the BNPL staked by user\r\n     * Given by (user's shares) * (total BNPL staked) / (total number of shares)\r\n     */\r\n    function getBNPLBalance(address user) public view returns (uint256 what) {\r\n        uint256 _balance = stakingShares[user];\r\n        uint256 _totalStakingShares = totalStakingShares;\r\n        if (_totalStakingShares == 0) {\r\n            what = 0;\r\n        } else {\r\n            what = (_balance * getStakedBNPL()) / _totalStakingShares;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the amount a user has that is being unbonded\r\n     * Given by (user's unbonding shares) * (total unbonding BNPL) / (total unbonding shares)\r\n     */\r\n    function getUnbondingBalance(address user) external view returns (uint256) {\r\n        uint256 _totalUnbondingShares = totalUnbondingShares;\r\n        uint256 _userUnbondingShare = unbondingShares[user];\r\n        if (_totalUnbondingShares == 0) {\r\n            return 0;\r\n        }\r\n        return (_userUnbondingShare * unbondingAmount) / _totalUnbondingShares;\r\n    }\r\n\r\n    /**\r\n     * Gets the next payment amount due\r\n     * If loan is completed or not approved, returns 0\r\n     */\r\n    function getNextPayment(uint256 loanId) public view returns (uint256) {\r\n        //if loan is completed or not approved, return 0\r\n        Loan storage loan = idToLoan[loanId];\r\n        if (loan.principalRemaining == 0) {\r\n            return 0;\r\n        }\r\n        uint256 _interestRate = loan.interestRate;\r\n        uint256 _loanAmount = loan.loanAmount;\r\n        uint256 _numberOfPayments = loan.numberOfPayments;\r\n        //check if it is an interest only loan\r\n        if (loan.interestOnly) {\r\n            //check if its the final payment\r\n            if (loan.paymentsMade + 1 == _numberOfPayments) {\r\n                //if final payment, then principal + final interest amount\r\n                return _loanAmount + ((_loanAmount * _interestRate) / 10000);\r\n            } else {\r\n                //if not final payment, simple interest amount\r\n                return (_loanAmount * _interestRate) / 10000;\r\n            }\r\n        } else {\r\n            //principal + interest payments, payment given by the formula:\r\n            //p : principal\r\n            //i : interest rate per period\r\n            //d : duration\r\n            // p * (i * (1+i) ** d) / ((1+i) ** d - 1)\r\n            uint256 numerator = _loanAmount *\r\n                _interestRate *\r\n                (10000 + _interestRate)**_numberOfPayments;\r\n            uint256 denominator = (10000 + _interestRate)**_numberOfPayments -\r\n                (10**(4 * _numberOfPayments));\r\n            return numerator / (denominator * 10000);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the next due date (unix timestamp) of a given loan\r\n     * Returns 0 if loan is not a current loan or loan has already been paid\r\n     */\r\n    function getNextDueDate(uint256 loanId) public view returns (uint256) {\r\n        //check that the loan has been approved and loan is not completed;\r\n        Loan storage loan = idToLoan[loanId];\r\n        if (loan.principalRemaining == 0) {\r\n            return 0;\r\n        }\r\n        return\r\n            loan.loanStartTime +\r\n            ((loan.paymentsMade + 1) * loan.paymentInterval);\r\n    }\r\n\r\n    /**\r\n     * Get the total assets (accounts receivable + aToken balance)\r\n     * Only principal owed is counted as accounts receivable\r\n     */\r\n    function getTotalAssetValue() public view returns (uint256) {\r\n        return\r\n            IERC20(_getLendingPool().getReserveData(baseToken).aTokenAddress)\r\n                .balanceOf(address(this)) + accountsReceiveable;\r\n    }\r\n\r\n    /**\r\n     * Get number of pending requests\r\n     */\r\n    function getPendingRequestCount() external view returns (uint256) {\r\n        return pendingRequests.length;\r\n    }\r\n\r\n    /**\r\n     * Get the current number of active loans\r\n     */\r\n    function getCurrentLoansCount() external view returns (uint256) {\r\n        return currentLoans.length;\r\n    }\r\n\r\n    /**\r\n     * Get the total Losses occurred\r\n     */\r\n    function getTotalDefaultLoss() external view returns (uint256) {\r\n        uint256 totalLosses = 0;\r\n        for (uint256 i; i < defaultedLoanCount; i++) {\r\n            Loan storage loan = idToLoan[defaultedLoans[i]];\r\n            totalLosses += loan.principalRemaining;\r\n        }\r\n        return totalLosses;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/BNPLFactory.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n//CUSTOM ERRORS\r\n\r\n//occurs when trying to create a node without a whitelisted baseToken\r\nerror InvalidBaseToken();\r\n//occurs when a user tries to set up a second node from same account\r\nerror OneNodePerAccountOnly();\r\n\r\ncontract BNPLFactory is Initializable, OwnableUpgradeable {\r\n\r\n    mapping(address => address) public operatorToNode;\r\n    address[] public bankingNodesList;\r\n    address public BNPL;\r\n    address public lendingPoolAddressesProvider;\r\n    address public WETH;\r\n    address public uniswapFactory;\r\n    mapping(address => bool) public approvedBaseTokens;\r\n    address public aaveDistributionController;\r\n\r\n    event NewNode(address indexed _operator, address indexed _node);\r\n\r\n    /**\r\n     * Upgradeable contracts uses an initializer function instead of a constructor\r\n     * Reference: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\r\n    */\r\n    function initialize(\r\n        address _BNPL,\r\n        address _lendingPoolAddressesProvider,\r\n        address _WETH,\r\n        address _aaveDistributionController,\r\n        address _uniswapFactory\r\n    ) public initializer {\r\n        __Ownable_init();\r\n\r\n        BNPL = _BNPL;\r\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\r\n        WETH = _WETH;\r\n        aaveDistributionController = _aaveDistributionController;\r\n        uniswapFactory = _uniswapFactory;\r\n    }\r\n\r\n    //STATE CHANGING FUNCTIONS\r\n\r\n    /**\r\n     * Creates a new banking node\r\n     */\r\n    function createNewNode(\r\n        address _baseToken,\r\n        bool _requireKYC,\r\n        uint256 _gracePeriod\r\n    ) external returns (address node) {\r\n        //collect the 2M BNPL\r\n        uint256 bondAmount = 0x1A784379D99DB42000000; //2M BNPL to bond a node\r\n        address _bnpl = BNPL;\r\n        TransferHelper.safeTransferFrom(\r\n            _bnpl,\r\n            msg.sender,\r\n            address(this),\r\n            bondAmount\r\n        );\r\n        //one node per operator and base token must be approved\r\n        if (!approvedBaseTokens[_baseToken]) {\r\n            revert InvalidBaseToken();\r\n        }\r\n        if (operatorToNode[msg.sender] != address(0)) {\r\n            revert OneNodePerAccountOnly();\r\n        }\r\n        //create a new node\r\n        bytes memory bytecode = type(BankingNode).creationCode;\r\n        bytes32 salt = keccak256(\r\n            abi.encodePacked(_baseToken, _requireKYC, _gracePeriod, msg.sender)\r\n        );\r\n        assembly {\r\n            node := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        BankingNode(node).initialize(\r\n            _baseToken,\r\n            _bnpl,\r\n            _requireKYC,\r\n            msg.sender,\r\n            _gracePeriod,\r\n            lendingPoolAddressesProvider,\r\n            WETH,\r\n            aaveDistributionController,\r\n            uniswapFactory\r\n        );\r\n\r\n        bankingNodesList.push(node);\r\n        operatorToNode[msg.sender] = node;\r\n        \r\n        TransferHelper.safeApprove(_bnpl, node, bondAmount);\r\n        BankingNode(node).stake(bondAmount);\r\n    }\r\n\r\n    //ONLY OWNER FUNCTIONS\r\n\r\n    /**\r\n     * Whitelist or Delist a base token for banking nodes(e.g. USDC)\r\n     */\r\n    function whitelistToken(address _baseToken, bool _status)\r\n        external\r\n        onlyOwner\r\n    {\r\n        if (_baseToken == BNPL) {\r\n            revert InvalidBaseToken();\r\n        }\r\n        approvedBaseTokens[_baseToken] = _status;\r\n    }\r\n\r\n    /**\r\n     * Get number of current nodes\r\n     */\r\n    function bankingNodeCount() external view returns (uint256) {\r\n        return bankingNodesList.length;\r\n    }\r\n}\r\n\r\n// File: contracts/BNPLRewardsController.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nerror InvalidToken();\r\nerror InsufficientUserBalance(uint256 userBalance);\r\nerror PoolExists();\r\nerror RewardsCannotIncrease();\r\n\r\n/**\r\n * Modified version of Sushiswap MasterChef.sol contract\r\n * - Migrator functionality removed\r\n * - Uses timestamp instead of block number\r\n * - Adding LP token is public instead of onlyOwner, but requires the LP token to be saved to bnplFactory\r\n * - Alloc points are based on amount of BNPL staked to the node\r\n * - Minting functions for BNPL not possible, they are transfered from treasury instead\r\n * - Removed safeMath as using solidity ^0.8.0\r\n * - Require checks changed to custom errors to save gas\r\n */\r\n\r\ncontract BNPLRewardsController is Ownable {\r\n    BNPLFactory public immutable bnplFactory;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    address public immutable bnpl;\r\n    address public treasury;\r\n    uint256 public bnplPerSecond; //initiated to\r\n    uint256 public immutable startTime; //unix time of start\r\n    uint256 public endTime; //3 years of emmisions\r\n    uint256 public totalAllocPoint = 0; //total allocation points, no need for max alloc points as max is the supply of BNPL\r\n    PoolInfo[] public poolInfo;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IBankingNode lpToken; //changed from IERC20\r\n        uint256 allocPoint;\r\n        uint256 lastRewardTime;\r\n        uint256 accBnplPerShare;\r\n    }\r\n\r\n    //EVENTS\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(\r\n        address indexed user,\r\n        uint256 indexed pid,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor(\r\n        BNPLFactory _bnplFactory,\r\n        address _bnpl,\r\n        address _treasury,\r\n        uint256 _startTime\r\n    ) {\r\n        bnplFactory = _bnplFactory;\r\n        startTime = _startTime;\r\n        endTime = _startTime + 94608000; //94,608,000 seconds in 3 years\r\n        bnpl = _bnpl;\r\n        treasury = _treasury;\r\n        bnplPerSecond = 4492220531033316000; //425,000,000 BNPL to be distributed over 3 years = ~4.49 BNPL per second\r\n    }\r\n\r\n    //STATE CHANGING FUNCTIONS\r\n\r\n    /**\r\n     * Add a pool to be allocated rewards\r\n     * Modified from MasterChef to be public, but requires the pool to be saved in BNPL Factory\r\n     * _allocPoints to be based on the number of bnpl staked in the given node\r\n     */\r\n    function add(IBankingNode _lpToken) public {\r\n        checkValidNode(address(_lpToken));\r\n\r\n        massUpdatePools();\r\n\r\n        uint256 _allocPoint = _lpToken.getStakedBNPL();\r\n        checkForDuplicate(_lpToken);\r\n\r\n        uint256 lastRewardTime = block.timestamp > startTime\r\n            ? block.timestamp\r\n            : startTime;\r\n        totalAllocPoint += _allocPoint;\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                lpToken: _lpToken,\r\n                allocPoint: _allocPoint,\r\n                lastRewardTime: lastRewardTime,\r\n                accBnplPerShare: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Update the given pool's bnpl allocation point, changed from Masterchef to be:\r\n     * - Public, but sets _allocPoints to the number of bnpl staked to a node\r\n     */\r\n    function set(uint256 _pid) external {\r\n        //get the new _allocPoints\r\n        uint256 _allocPoint = poolInfo[_pid].lpToken.getStakedBNPL();\r\n\r\n        massUpdatePools();\r\n\r\n        totalAllocPoint =\r\n            totalAllocPoint +\r\n            _allocPoint -\r\n            poolInfo[_pid].allocPoint;\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    /**\r\n     * Update reward variables for all pools\r\n     */\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update reward variables for a pool given pool to be up-to-date\r\n     */\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.timestamp <= pool.lastRewardTime) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTime == block.timestamp;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(\r\n            pool.lastRewardTime,\r\n            block.timestamp\r\n        );\r\n        uint256 bnplReward = (multiplier * bnplPerSecond * pool.allocPoint) /\r\n            totalAllocPoint;\r\n\r\n        //instead of minting, simply transfers the tokens from the owner\r\n        //ensure owner has approved the tokens to the contract\r\n\r\n        address _bnpl = bnpl;\r\n        address _treasury = treasury;\r\n        TransferHelper.safeTransferFrom(\r\n            _bnpl,\r\n            _treasury,\r\n            address(this),\r\n            bnplReward\r\n        );\r\n\r\n        pool.accBnplPerShare += (bnplReward * 1e12) / lpSupply;\r\n        pool.lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Deposit LP tokens from the user\r\n     */\r\n    function deposit(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n\r\n        updatePool(_pid);\r\n\r\n        uint256 pending = ((user.amount * pool.accBnplPerShare) / 1e12) -\r\n            user.rewardDebt;\r\n\r\n        user.amount += _amount;\r\n        user.rewardDebt = (user.amount * pool.accBnplPerShare) / 1e12;\r\n\r\n        if (pending > 0) {\r\n            safeBnplTransfer(msg.sender, pending);\r\n        }\r\n        TransferHelper.safeTransferFrom(\r\n            address(pool.lpToken),\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw LP tokens from the user\r\n     */\r\n    function withdraw(uint256 _pid, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n\r\n        if (_amount > user.amount) {\r\n            revert InsufficientUserBalance(user.amount);\r\n        }\r\n\r\n        updatePool(_pid);\r\n\r\n        uint256 pending = ((user.amount * pool.accBnplPerShare) / 1e12) -\r\n            user.rewardDebt;\r\n\r\n        user.amount -= _amount;\r\n        user.rewardDebt = (user.amount * pool.accBnplPerShare) / 1e12;\r\n\r\n        if (pending > 0) {\r\n            safeBnplTransfer(msg.sender, pending);\r\n        }\r\n        TransferHelper.safeTransfer(address(pool.lpToken), msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraw without caring about rewards. EMERGENCY ONLY.\r\n     */\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256 oldUserAmount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        TransferHelper.safeTransfer(\r\n            address(pool.lpToken),\r\n            msg.sender,\r\n            oldUserAmount\r\n        );\r\n        emit EmergencyWithdraw(msg.sender, _pid, oldUserAmount);\r\n    }\r\n\r\n    /**\r\n     * Safe BNPL transfer function, just in case if rounding error causes pool to not have enough BNPL.\r\n     */\r\n    function safeBnplTransfer(address _to, uint256 _amount) internal {\r\n        address _bnpl = bnpl;\r\n        uint256 bnplBalance = IERC20(_bnpl).balanceOf(address(this));\r\n        if (_amount > bnplBalance) {\r\n            TransferHelper.safeTransfer(_bnpl, _to, bnplBalance);\r\n        } else {\r\n            TransferHelper.safeTransfer(_bnpl, _to, _amount);\r\n        }\r\n    }\r\n\r\n    //OWNER ONLY FUNCTIONS\r\n\r\n    /**\r\n     * Update the BNPL per second emmisions, emmisions can only be decreased\r\n     */\r\n    function updateRewards(uint256 _bnplPerSecond) public onlyOwner {\r\n        if (_bnplPerSecond > bnplPerSecond) {\r\n            revert RewardsCannotIncrease();\r\n        }\r\n        bnplPerSecond = _bnplPerSecond;\r\n\r\n        massUpdatePools();\r\n    }\r\n\r\n    /**\r\n     * Update the treasury address that bnpl is transfered from\r\n     */\r\n    function updateTreasury(address _treasury) public onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    //VIEW FUNCTIONS\r\n\r\n    /**\r\n     * Return reward multiplier over the given _from to _to timestamps\r\n     */\r\n    function getMultiplier(uint256 _from, uint256 _to)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //get the start time to be minimum\r\n        _from = _from > startTime ? _from : startTime;\r\n        if (_to < startTime || _from >= endTime) {\r\n            return 0;\r\n        } else if (_to <= endTime) {\r\n            return _to - _from;\r\n        } else {\r\n            return endTime - _from;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the number of pools\r\n     */\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    /**\r\n     * Check if the pool already exists\r\n     */\r\n    function checkForDuplicate(IBankingNode _lpToken) internal view {\r\n        for (uint256 i = 0; i < poolInfo.length; i++) {\r\n            if (poolInfo[i].lpToken == _lpToken) {\r\n                revert PoolExists();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * View function to get the pending bnpl to harvest\r\n     * Modifed by removing safe math\r\n     */\r\n    function pendingBnpl(uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accBnplPerShare = pool.accBnplPerShare;\r\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\r\n\r\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(\r\n                pool.lastRewardTime,\r\n                block.timestamp\r\n            );\r\n            uint256 bnplReward = (multiplier *\r\n                bnplPerSecond *\r\n                pool.allocPoint) / totalAllocPoint;\r\n            accBnplPerShare += (bnplReward * 1e12) / lpSupply;\r\n        }\r\n        return (user.amount * accBnplPerShare) / (1e12) - user.rewardDebt;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given address is a valid banking node registered\r\n     * Reverts with InvalidToken() if node not found\r\n     */\r\n    function checkValidNode(address _bankingNode) private view {\r\n        BNPLFactory _bnplFactory = bnplFactory;\r\n        uint256 length = _bnplFactory.bankingNodeCount();\r\n        for (uint256 i; i < length; i++) {\r\n            if (_bnplFactory.bankingNodesList(i) == _bankingNode) {\r\n                return;\r\n            }\r\n        }\r\n        revert InvalidToken();\r\n    }\r\n\r\n    /**\r\n     * Get the Apy for front end for a given pool\r\n     * - assumes rewards are active\r\n     * - assumes poolTokens have $1 value\r\n     * - must multiply by BNPL price / 1e18 to get USD APR\r\n     * If return == 0, APR = NaN\r\n     */\r\n    function getBnplApr(uint256 _pid) external view returns (uint256 bnplApr) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        uint256 lpBalanceStaked = pool.lpToken.balanceOf(address(this));\r\n        if (lpBalanceStaked == 0) {\r\n            bnplApr = 0;\r\n        } else {\r\n            uint256 poolBnplPerYear = (bnplPerSecond *\r\n                pool.allocPoint *\r\n                31536000) / totalAllocPoint; //31536000 seconds in a year\r\n            bnplApr = (poolBnplPerYear * 1e18) / lpBalanceStaked;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function for front end\r\n     * Get the pid+1 given a node address\r\n     * Returns 0xFFFF if node not found\r\n     */\r\n    function getPid(address node) external view returns (uint256) {\r\n        for (uint256 i; i < poolInfo.length; ++i) {\r\n            if (address(poolInfo[i].lpToken) == node) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0xFFFF;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract BNPLFactory\",\"name\":\"_bnplFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bnpl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"}],\"name\":\"InsufficientUserBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardsCannotIncrease\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IBankingNode\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnplFactory\",\"outputs\":[{\"internalType\":\"contract BNPLFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnplPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getBnplApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bnplApr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"}],\"name\":\"getPid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingBnpl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBankingNode\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accBnplPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnplPerSecond\",\"type\":\"uint256\"}],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BNPLRewardsController", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007edb0c8b428b97ea1ca44ea9fcda0835fbd8802900000000000000000000000084d821f7fbdd595c4c4a50842913e6b1e07d7a530000000000000000000000008a997b73c367879d24afe8cdd23ddd2ec1473ebd00000000000000000000000000000000000000000000000000000000628b6930", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c8ff47d180f3f3149676fc86a812c0645bc72cb03bc9396c885266cdb140d0c"}]}