{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.14;\\n\\nimport \\\"./interfaces/IStaking.sol\\\";\\nimport \\\"./interfaces/InitializableOwnable.sol\\\";\\n\\ncontract Staking is InitializableOwnable, IStaking {\\n\\n    /* ========== HELPER STRUCTURES ========== */\\n\\n    struct UserInfo {\\n        uint amount;\\n        uint rewardAccountedForHarvest;\\n        uint availableHarvest;\\n        uint lastHarvestTimestamp;\\n    }\\n\\n    /* ========== CONSTANTS ========== */\\n\\n    IERC20 public immutable stakingToken;\\n\\n    string public name;\\n    string public symbol;\\n    uint public immutable harvestInterval;\\n    uint8 public immutable decimals;\\n\\n    uint public constant calcDecimals = 1e14;\\n    uint public constant secondsInYear = 31557600;\\n    uint public constant aprDenominator = 10000;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public admin;\\n    bool public paused;\\n    bool public unstakePermitted;\\n    uint public aprBasisPoints;\\n\\n    uint public amountStaked;\\n    uint public accumulatedRewardPerShare;\\n    uint public lastRewardTimestamp;\\n\\n    mapping(address => UserInfo) public userInfo;\\n    mapping(address => mapping(address => uint)) public allowances;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        IERC20 token_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint aprBasisPoints_,\\n        uint harvestInterval_\\n    ) {\\n        initOwner(msg.sender);\\n        stakingToken = token_;\\n        name = name_;\\n        symbol = symbol_;\\n        aprBasisPoints = aprBasisPoints_;\\n        harvestInterval = harvestInterval_;\\n        lastRewardTimestamp = block.timestamp;\\n        decimals = IERC20Metadata(address(token_)).decimals();\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function totalSupply() external view returns (uint256) {\\n        return amountStaked; \\n    }\\n\\n    function currentRewardDelta() public view returns (uint) {\\n        uint timeDelta = block.timestamp - lastRewardTimestamp;\\n        return (timeDelta * aprBasisPoints * calcDecimals) / (aprDenominator * secondsInYear);\\n    }\\n\\n    function calculateRewardForStake(uint amount) internal view returns (uint) {\\n        return accumulatedRewardPerShare * amount / calcDecimals;\\n    }\\n\\n    function balanceOf(address user_) external view returns(uint) {\\n        UserInfo storage user = userInfo[user_];\\n        uint updAccumulatedRewardPerShare = accumulatedRewardPerShare + currentRewardDelta();\\n\\n        uint virtualReward = \\n            updAccumulatedRewardPerShare * user.amount / calcDecimals \\n            - user.rewardAccountedForHarvest;\\n        return user.amount + user.availableHarvest + virtualReward;\\n    }\\n\\n    function allowance(address owner, address spender) external view returns (uint256) {\\n        return allowances[owner][spender];\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function approve(\\n        address spender, \\n        uint amount\\n    ) external whenNotPaused virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender_,\\n        address recipient_,\\n        uint amount\\n    ) internal {\\n        updateRewardPool();\\n        require(sender_ != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient_ != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        UserInfo storage sender = userInfo[sender_];\\n        UserInfo storage recipient = userInfo[recipient_];\\n        require(amount <= sender.amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n        sender.availableHarvest += calculateRewardForStake(sender.amount) - sender.rewardAccountedForHarvest;\\n        sender.amount -= amount; \\n        sender.rewardAccountedForHarvest = calculateRewardForStake(sender.amount);\\n\\n        recipient.availableHarvest += calculateRewardForStake(recipient.amount) - recipient.rewardAccountedForHarvest;\\n        recipient.amount += amount; \\n        recipient.rewardAccountedForHarvest = calculateRewardForStake(recipient.amount);\\n\\n        emit Transfer(sender_, recipient_, amount);\\n    }\\n\\n    function transfer(\\n        address recipient, \\n        uint256 amount\\n    ) external whenNotPaused virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    } \\n\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external whenNotPaused virtual override returns (bool) {\\n        _transfer(spender, recipient, amount);\\n        uint256 currentAllowance = allowances[spender][msg.sender];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(spender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    function updateRewardPool() public canUnstake {\\n        accumulatedRewardPerShare += currentRewardDelta();\\n        lastRewardTimestamp = block.timestamp;\\n    }\\n\\n    function stake(\\n        uint amount, \\n        address to\\n    ) external whenNotPaused {\\n        updateRewardPool();\\n        require(amount > 0, \\\"Staking: Nothing to deposit\\\");\\n        require(to != address(0));\\n        require(stakingToken.transferFrom(msg.sender, address(this), amount), \\\"Staking: transfer failed\\\");\\n\\n        UserInfo storage user = userInfo[to];\\n        user.availableHarvest += calculateRewardForStake(user.amount) - user.rewardAccountedForHarvest;\\n        amountStaked += amount;\\n        user.amount += amount;\\n        user.rewardAccountedForHarvest = calculateRewardForStake(user.amount);\\n        emit Transfer(address(0), to, amount);\\n        emit Stake(to, amount);\\n    }\\n\\n    function harvest(uint256 amount) external whenNotPaused {\\n        updateRewardPool();\\n        UserInfo storage user = userInfo[msg.sender];\\n        require(user.lastHarvestTimestamp + harvestInterval <= block.timestamp || \\n            user.lastHarvestTimestamp == 0, \\\"Staking: less than 24 hours since last harvest\\\");\\n        user.lastHarvestTimestamp = block.timestamp;\\n        uint reward = calculateRewardForStake(user.amount);\\n        user.availableHarvest += reward - user.rewardAccountedForHarvest;\\n        user.rewardAccountedForHarvest = reward;\\n\\n        require(amount > 0, \\\"Staking: Nothing to harvest\\\");\\n        require(amount <= user.availableHarvest, \\\"Staking: Insufficient to harvest\\\");\\n        user.availableHarvest -= amount;\\n        require(stakingToken.transfer(msg.sender, amount), \\\"Staking: transfer failed\\\");\\n        emit Harvest(msg.sender, amount);\\n    }\\n\\n    function unstake(\\n        address to, \\n        uint256 amount\\n    ) external canUnstake {\\n        updateRewardPool();\\n        require(amount > 0, \\\"Staking: Nothing to unstake\\\");\\n        require(to != address(0));\\n\\n        UserInfo storage user = userInfo[msg.sender];\\n        require(amount <= user.amount, \\\"Staking: Insufficient share\\\");\\n        user.availableHarvest += calculateRewardForStake(user.amount) - user.rewardAccountedForHarvest;\\n        amountStaked -= amount;\\n        user.amount -= amount;\\n        user.rewardAccountedForHarvest = calculateRewardForStake(user.amount);\\n\\n        require(stakingToken.transfer(to, amount), \\\"Staking: Not enough token to transfer\\\");\\n        emit Transfer(to, address(0), amount);\\n        emit Unstake(to, amount);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setApr(uint aprBasisPoints_) external onlyOwner {\\n        updateRewardPool();\\n        uint oldAprBasisPoints = aprBasisPoints;\\n        aprBasisPoints = aprBasisPoints_;\\n        emit SetApr(oldAprBasisPoints, aprBasisPoints);\\n    }\\n\\n    function togglePause() external onlyOwner {\\n        paused = !paused;\\n        emit Pause(paused);\\n    }\\n\\n    function toggleUnstake() external onlyOwner {\\n        unstakePermitted = !unstakePermitted;\\n        emit UnstakePermit(unstakePermitted);\\n    }\\n\\n    function withdrawToken(\\n        IERC20 tokenToWithdraw, \\n        address to, \\n        uint amount\\n    ) external onlyOwner {\\n        require(tokenToWithdraw.transfer(to, amount));\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Staking: contract paused.\\\");\\n        _;\\n    }\\n\\n    modifier canUnstake() {\\n        require(unstakePermitted || (!paused), \\\"Staking: contract paused or unstake denied.\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IStaking is IERC20, IERC20Metadata {\\n\\n     /* ========== CONSTANTS ========== */\\n\\n    function calcDecimals() external view returns (uint);\\n\\n    function secondsInYear() external view returns (uint);\\n\\n    function aprDenominator() external view returns (uint);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    function aprBasisPoints() external view returns (uint);\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function updateRewardPool() external;\\n\\n    function stake(uint amount, address to) external;\\n\\n    function harvest(uint256 amount) external;\\n\\n    function unstake(address to, uint256 amount) external;\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setApr(uint _aprBasisPoints) external;\\n\\n    function togglePause() external;\\n\\n    function toggleUnstake() external;\\n\\n    function withdrawToken(IERC20 tokenToWithdraw, address to, uint amount) external;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Pause(bool indexed flag);\\n    event UnstakePermit(bool indexed flag);\\n    event SetApr(uint indexed oldBasisPoints, uint indexed newBasisPoints);\\n    event Stake(address indexed user, uint indexed amount);\\n    event Unstake(address indexed user, uint indexed amount);\\n    event Harvest(address indexed user, uint indexed amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/InitializableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.8.14;\\n\\ncontract InitializableOwnable {\\n\\n    address public owner;\\n    address public newOwner;\\n\\n    bool internal initialized;\\n\\n    // ============ Events ============\\n\\n    event OwnerTransferRequested(\\n        address indexed oldOwner, \\n        address indexed newOwner\\n    );\\n\\n    event OwnershipTransferred(\\n        address indexed oldOwner, \\n        address indexed newOwner\\n    );\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function initOwner(address _newOwner) public notInitialized {\\n        initialized = true;\\n        owner = _newOwner;\\n    }\\n\\n    function transferOwnership(address _newOwner) public onlyOwner {\\n        emit OwnerTransferRequested(owner, _newOwner);\\n        newOwner = _newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == newOwner, \\\"Claim from wrong address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier notInitialized() {\\n        require(!initialized, \\\"Not initialized\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"aprBasisPoints_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvestInterval_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldBasisPoints\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newBasisPoints\",\"type\":\"uint256\"}],\"name\":\"SetApr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"UnstakePermit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulatedRewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRewardDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsInYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aprBasisPoints_\",\"type\":\"uint256\"}],\"name\":\"setApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakePermitted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAccountedForHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastHarvestTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToWithdraw\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000001e0e2e61f554ecaaec0cc933e739ad90f24a86d00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000008b80000000000000000000000000000000000000000000000000000000000015180000000000000000000000000000000000000000000000000000000000000000c5374616b696e672047544f4e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000057347544f4e000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}