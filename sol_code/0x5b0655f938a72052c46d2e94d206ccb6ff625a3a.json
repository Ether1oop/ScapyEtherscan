{"status": "1", "message": "OK", "result": [{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Token Minter\r\n@author Curve Finance\r\n@license MIT\r\n\"\"\"\r\n\r\ninterface LiquidityGauge:\r\n    # Presumably, other gauges will provide the same interfaces\r\n    def integrate_fraction(addr: address) -> uint256: view\r\n    def user_checkpoint(addr: address) -> bool: nonpayable\r\n\r\ninterface ERC20:\r\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\r\n    def balanceOf(account: address) -> uint256: nonpayable\r\n\r\ninterface GaugeController:\r\n    def gauge_types(addr: address) -> int128: view\r\n\r\nevent Minted:\r\n    recipient: indexed(address)\r\n    gauge: address\r\n    minted: uint256\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n\r\nevent CommitNextEmission:\r\n    rate: uint256\r\n\r\nevent CommitEmergencyReturn:\r\n    admin: address\r\n\r\nevent ApplyEmergencyReturn:\r\n    admin: address\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\n# General constants\r\nWEEK: constant(uint256) = 86400 * 7\r\n\r\n# 250K RBN / WEEK\r\nINITIAL_RATE: constant(uint256) = 250_000 * 10 ** 18 / WEEK\r\n# Weekly\r\nMAX_ABS_RATE: constant(uint256) = 10_000_000 * 10 ** 18\r\nRATE_REDUCTION_TIME: constant(uint256) = WEEK * 2\r\nINFLATION_DELAY: constant(uint256) = 86400\r\n\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\ncommitted_rate: public(uint256)\r\nis_start: public(bool)\r\n\r\ntoken: public(address)\r\ncontroller: public(address)\r\n\r\n# user -> gauge -> value\r\nminted: public(HashMap[address, HashMap[address, uint256]])\r\n\r\n# minter -> user -> can mint?\r\nallowed_to_mint_for: public(HashMap[address, HashMap[address, bool]])\r\n\r\nfuture_emergency_return: public(address)\r\nemergency_return: public(address)\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)  # Can and will be a smart contract\r\n\r\n@external\r\ndef __init__(_token: address, _controller: address, _emergency_return: address, _admin: address):\r\n    self.token = _token\r\n    self.controller = _controller\r\n    self.emergency_return = _emergency_return\r\n    self.admin = _admin\r\n\r\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\r\n    self.mining_epoch = -1\r\n    self.is_start = True\r\n    self.committed_rate = MAX_UINT256\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n\r\n    self.start_epoch_time += RATE_REDUCTION_TIME\r\n    self.mining_epoch += 1\r\n\r\n    if _rate == 0 and self.is_start:\r\n        _rate = INITIAL_RATE\r\n        self.is_start = False\r\n    else:\r\n        _committed_rate: uint256 = self.committed_rate\r\n        if _committed_rate != MAX_UINT256:\r\n          _rate = _committed_rate\r\n          self.committed_rate = MAX_UINT256\r\n\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate)\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_REDUCTION_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_REDUCTION_TIME\r\n\r\n@internal\r\ndef _mint_for(gauge_addr: address, _for: address):\r\n    assert GaugeController(self.controller).gauge_types(gauge_addr) >= 0  # dev: gauge is not added\r\n\r\n    LiquidityGauge(gauge_addr).user_checkpoint(_for)\r\n    total_mint: uint256 = LiquidityGauge(gauge_addr).integrate_fraction(_for)\r\n    to_mint: uint256 = total_mint - self.minted[_for][gauge_addr]\r\n\r\n    if to_mint != 0:\r\n        ERC20(self.token).transfer(_for, to_mint)\r\n        if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\r\n          self._update_mining_parameters()\r\n        self.minted[_for][gauge_addr] = total_mint\r\n\r\n        log Minted(_for, gauge_addr, total_mint)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint(gauge_addr: address):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` and send to them\r\n    @param gauge_addr `LiquidityGauge` address to get mintable amount from\r\n    \"\"\"\r\n    self._mint_for(gauge_addr, msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint_many(gauge_addrs: address[8]):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` across multiple gauges\r\n    @param gauge_addrs List of `LiquidityGauge` addresses\r\n    \"\"\"\r\n    for i in range(8):\r\n        if gauge_addrs[i] == ZERO_ADDRESS:\r\n            break\r\n        self._mint_for(gauge_addrs[i], msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint_for(gauge_addr: address, _for: address):\r\n    \"\"\"\r\n    @notice Mint tokens for `_for`\r\n    @dev Only possible when `msg.sender` has been approved via `toggle_approve_mint`\r\n    @param gauge_addr `LiquidityGauge` address to get mintable amount from\r\n    @param _for Address to mint to\r\n    \"\"\"\r\n    if self.allowed_to_mint_for[msg.sender][_for]:\r\n        self._mint_for(gauge_addr, _for)\r\n\r\n\r\n@external\r\ndef toggle_approve_mint(minting_user: address):\r\n    \"\"\"\r\n    @notice allow `minting_user` to mint for `msg.sender`\r\n    @param minting_user Address to toggle permission for\r\n    \"\"\"\r\n    self.allowed_to_mint_for[minting_user][msg.sender] = not self.allowed_to_mint_for[minting_user][msg.sender]\r\n\r\n@external\r\ndef recover_balance(_coin: address) -> bool:\r\n    \"\"\"\r\n    @notice Recover ERC20 tokens from this contract\r\n    @dev Tokens are sent to the emergency return address.\r\n    @param _coin Token address\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.admin # dev: admin only\r\n\r\n    amount: uint256 = ERC20(_coin).balanceOf(self)\r\n    response: Bytes[32] = raw_call(\r\n        _coin,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(self.emergency_return, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    return True\r\n\r\n@external\r\ndef commit_next_emission(_rate_per_week: uint256):\r\n  \"\"\"\r\n  @notice Commit a new rate for the following week (we update by weeks).\r\n          _rate_per_week should have no decimals (ex: if we want to reward 600_000 RBN over the course of a week, we pass in 600_000 * 10 ** 18)\r\n  \"\"\"\r\n  assert msg.sender == self.admin # dev: admin only\r\n  assert _rate_per_week <= MAX_ABS_RATE # dev: preventing fatfinger\r\n  new_rate: uint256 = _rate_per_week / WEEK\r\n  self.committed_rate = new_rate\r\n  log CommitNextEmission(new_rate)\r\n\r\n@external\r\ndef commit_transfer_emergency_return(addr: address):\r\n    \"\"\"\r\n    @notice Update emergency ret. of Minter to `addr`\r\n    @param addr Address to have emergency ret. transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_emergency_return = addr\r\n    log CommitEmergencyReturn(addr)\r\n\r\n@external\r\ndef apply_transfer_emergency_return():\r\n    \"\"\"\r\n    @notice Apply pending emergency ret. update\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _emergency_return: address = self.future_emergency_return\r\n    assert _emergency_return != ZERO_ADDRESS  # dev: emergency return not set\r\n    self.emergency_return = _emergency_return\r\n    log ApplyEmergencyReturn(_emergency_return)\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of GaugeController to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply pending ownership transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)", "ABI": "[{\"name\":\"Minted\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":false},{\"name\":\"minted\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMiningParameters\",\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNextEmission\",\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitEmergencyReturn\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyEmergencyReturn\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_emergency_return\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_mining_parameters\",\"inputs\":[],\"outputs\":[],\"gas\":155943},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_epoch_time_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":158152},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"future_epoch_time_write\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":158341},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"gauge_addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":268280},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint_many\",\"inputs\":[{\"name\":\"gauge_addrs\",\"type\":\"address[8]\"}],\"outputs\":[],\"gas\":1745103},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint_for\",\"inputs\":[{\"name\":\"gauge_addr\",\"type\":\"address\"},{\"name\":\"_for\",\"type\":\"address\"}],\"outputs\":[],\"gas\":270873},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_approve_mint\",\"inputs\":[{\"name\":\"minting_user\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38141},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover_balance\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":14650},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_next_emission\",\"inputs\":[{\"name\":\"_rate_per_week\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":39683},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_emergency_return\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39715},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_emergency_return\",\"inputs\":[],\"outputs\":[],\"gas\":41806},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39775},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":41866},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mining_epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":2850},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"start_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2880},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2910},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"committed_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2940},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_start\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2970},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3000},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3030},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3592},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_to_mint_for\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3622},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_emergency_return\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3120},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"emergency_return\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3150},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3180},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3210}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000006123b0049f904d730db3c36a31167d9d4121fa6b000000000000000000000000ff351a4a9840e3f47f0844dbe93c8e48bf1439c9000000000000000000000000223d59fa315d7693df4238d1a5748c964e61592300000000000000000000000077da011d5314d80be59e939c2f7ec2f702e1dcc4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}