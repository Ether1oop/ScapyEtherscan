{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/marketplace/GigaMart.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport {\\r\\n\\tReentrancyGuard\\r\\n} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\nimport \\\"./core/Executor.sol\\\";\\r\\n\\r\\n/// Thrown if the count of items in required argument arrays differ.\\r\\nerror ArgumentsLengthMismatched ();\\r\\n\\r\\n/**\\r\\n\\tThrown during mass-cancelation if the provided nonce is lower than current \\r\\n\\tnonce.\\r\\n\\r\\n\\t@param nonce The nonce used to indicate the current set of uncanceled user \\r\\n\\t\\torders.\\r\\n*/\\r\\nerror NonceLowerThanCurrent (\\r\\n\\tuint256 nonce\\r\\n);\\r\\n\\r\\n/// Thrown if attempting to send items to the zero address.\\r\\nerror InvalidRecipient ();\\r\\n\\r\\n/**\\r\\n\\tThrown if attempting to execute an order that is not valid for fulfillment; \\r\\n\\tthis prevents offers from being executed as if they were listings.\\r\\n*/\\r\\nerror WrongOrderType ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title GigaMart Exchange\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\t@custom:contributor throw; <@0xthrpw>\\r\\n\\t\\r\\n\\tGigaMart is a new NFT platform built for the world by the SuperVerse DAO. \\r\\n\\tThis is the first iteration of the exchange and is based on a delegated user \\r\\n\\tproxy architecture.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\ncontract GigaMart is Executor, ReentrancyGuard {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEmitted when a user cancels all of their orders. All orders with a nonce \\r\\n\\t\\tless than `minNonce` will be canceled.\\r\\n\\r\\n\\t\\t@param sender The caller who is canceling their orders.\\r\\n\\t\\t@param minNonce The new nonce to use in mass-cancelation.\\r\\n\\t*/\\r\\n\\tevent AllOrdersCancelled (\\r\\n\\t\\taddress indexed sender,\\r\\n\\t\\tuint256 minNonce\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new instance of the GigaMart exchange.\\r\\n\\r\\n\\t\\t@param _registry The address of the existing proxy registry.\\r\\n\\t\\t@param _tokenTransferProxy The address of the token transfer proxy contract.\\r\\n\\t\\t@param _validator The address of a privileged validator for permitting \\r\\n\\t\\t\\tcollection administrators to control their royalty fees.\\r\\n\\t\\t@param _protocolFeeRecipient The address which receives fees from the \\r\\n\\t\\t\\texchange.\\r\\n\\t\\t@param _protocolFeePercent The percent of fees taken by \\r\\n\\t\\t\\t`_protocolFeeRecipient` in basis points (1/100th %; i.e. 200 = 2%).\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\tIProxyRegistry _registry,\\r\\n\\t\\tTokenTransferProxy _tokenTransferProxy,\\r\\n\\t\\taddress _validator,\\r\\n\\t\\taddress _protocolFeeRecipient,\\r\\n\\t\\tuint96 _protocolFeePercent\\r\\n\\t) Executor(\\r\\n\\t\\t_registry,\\r\\n\\t\\t_tokenTransferProxy,\\r\\n\\t\\t_validator,\\r\\n\\t\\t_protocolFeeRecipient,\\r\\n\\t\\t_protocolFeePercent\\r\\n\\t) { }\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAllow the caller to cancel an order so long as they are the maker of the \\r\\n\\t\\torder.\\r\\n\\r\\n\\t\\t@param _order The `Order` data to cancel.\\r\\n\\t*/\\r\\n\\tfunction cancelOrder (\\r\\n\\t\\tEntities.Order calldata _order\\r\\n\\t) external {\\r\\n\\t\\t_cancelOrder(_order);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAllow the caller to cancel a set of particular orders so long as they are \\r\\n\\t\\tthe maker of each order.\\r\\n\\r\\n\\t\\t@param _orders An array of `Order` data to cancel.\\r\\n\\t*/\\r\\n\\tfunction cancelOrders (\\r\\n\\t\\tEntities.Order[] calldata _orders\\r\\n\\t) public {\\r\\n\\t\\tfor (uint256 i; i < _orders.length; ) {\\r\\n\\t\\t\\t_cancelOrder(_orders[i]);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAllow the caller to cancel all of their orders created with a nonce lower \\r\\n\\t\\tthan the new `_minNonce`.\\r\\n\\r\\n\\t\\t@param _minNonce The new nonce to use in mass-cancelation.\\r\\n\\r\\n\\t\\t@custom:throws NonceLowerThanCurrent if the provided nonce is not less than \\r\\n\\t\\t\\tthe current nonce.\\r\\n\\t*/\\r\\n\\tfunction cancelAllOrders (\\r\\n\\t\\tuint256 _minNonce\\r\\n\\t) external {\\r\\n\\r\\n\\t\\t// Verify that the new nonce is not less than the current nonce.\\r\\n\\t\\tif (_minNonce < minOrderNonces[msg.sender]) {\\r\\n\\t\\t\\trevert NonceLowerThanCurrent(minOrderNonces[msg.sender]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Set the new minimum nonce and emit an event.\\r\\n\\t\\tminOrderNonces[msg.sender] = _minNonce;\\r\\n\\t\\temit AllOrdersCancelled(msg.sender, _minNonce);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tTransfer multiple items using the user-proxy and executable bytecode.\\r\\n\\r\\n\\t\\t@param _targets The array of addresses which should be called with the \\r\\n\\t\\t\\tfunction calls encoded in `_data`.\\r\\n\\t\\t@param _data The array of encoded function calls performed against the \\r\\n\\t\\t\\taddresses in `_targets`.\\r\\n\\r\\n\\t\\t@custom:throws ArgumentsLengthMismatched if the `_targets` and `_data` \\r\\n\\t\\t\\tarrays are mismatched.\\r\\n\\t*/\\r\\n\\tfunction transferMultipleItems (\\r\\n\\t\\taddress[] calldata _targets,\\r\\n\\t\\tbytes[] calldata _data\\r\\n\\t) external {\\r\\n\\t\\tif (_targets.length != _data.length) {\\r\\n\\t\\t\\trevert ArgumentsLengthMismatched();\\r\\n\\t\\t}\\r\\n\\t\\t_multiTransfer(_targets, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tExchange a single ERC-721 or ERC-1155 item for Ether or ERC-20 tokens.\\r\\n\\r\\n\\t\\t@param _recipient The address which will receive the item.\\r\\n\\t\\t@param _order The `Order` to execute.\\r\\n\\t\\t@param _signature The signature provided for fulfilling the order.\\r\\n\\t\\t@param _tokenId The unique token ID of the item.\\r\\n\\t\\t@param _toInvalidate An optional array of `Order`s by the same caller to \\r\\n\\t\\t\\tcancel while fulfilling the exchange.\\r\\n\\r\\n\\t\\t@custom:throws InvalidRecipient if the item `_recipient` is the zero \\r\\n\\t\\t\\taddress.\\r\\n\\t*/\\r\\n\\tfunction exchangeSingleItem (\\r\\n\\t\\taddress _recipient,\\r\\n\\t\\tEntities.Order memory _order,\\r\\n\\t\\tEntities.Sig calldata _signature,\\r\\n\\t\\tuint256 _tokenId,\\r\\n\\t\\tEntities.Order[] calldata _toInvalidate\\r\\n\\t) external payable nonReentrant {\\r\\n\\r\\n\\t\\t// Prevent the item from being sent to the zero address.\\r\\n\\t\\tif (_recipient == address(0)) {\\r\\n\\t\\t\\trevert InvalidRecipient();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Perform the exchange.\\r\\n\\t\\t_exchange(_recipient, _order, _signature, _tokenId);\\r\\n\\t\\t\\r\\n\\t\\t// Optionally invalidate other orders while performing this exchange.\\r\\n\\t\\tif (_toInvalidate.length > 0) {\\r\\n\\t\\t\\tcancelOrders(_toInvalidate);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tExchange multiple ERC-721 or ERC-1155 items for Ether or ERC-20 tokens.\\r\\n\\r\\n\\t\\t@param _recipient The address which will receive the items.\\r\\n\\t\\t@param _orders The array of orders that are being executed.\\r\\n\\t\\t@param _signatures The array of signatures provided for fulfilling the \\r\\n\\t\\t\\torders.\\r\\n\\t\\t@param _toInvalidate An optional array of `Order`s by the same caller to \\r\\n\\t\\t\\tcancel while fulfilling the exchange.\\r\\n\\r\\n\\t\\t@custom:throws ArgumentsLengthMismatched if the `_orders` and `_signatures` \\r\\n\\t\\t\\tarrays are mismatched.\\r\\n\\t\\t@custom:throws InvalidRecipient if the item `_recipient` is the zero \\r\\n\\t\\t\\taddress.\\r\\n\\t\\t@custom:throws WrongOrderType if attempting to fulfill an offer using this \\r\\n\\t\\t\\tfunction.\\r\\n\\t*/\\r\\n\\tfunction exchangeMultipleItems (\\r\\n\\t\\taddress _recipient,\\r\\n\\t\\tEntities.Order[] memory _orders,\\r\\n\\t\\tEntities.Sig[] calldata _signatures,\\r\\n\\t\\tEntities.Order[] calldata _toInvalidate\\r\\n\\t) external payable nonReentrant {\\r\\n\\t\\tif (_orders.length != _signatures.length) {\\r\\n\\t\\t\\trevert ArgumentsLengthMismatched();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Prevent the item from being sent to the zero address.\\r\\n\\t\\tif (_recipient == address(0)) {\\r\\n\\t\\t\\trevert InvalidRecipient();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Prepare an accumulator array for collecting payments.\\r\\n\\t\\tbytes memory payments = new bytes(32);\\r\\n\\t\\tfor (uint256 i; i < _orders.length; ) {\\r\\n\\r\\n\\t\\t\\t// Prevent offers from being fulfilled by this function.\\r\\n\\t\\t\\tif (uint8(_orders[i].outline.saleKind) > 2) {\\r\\n\\t\\t\\t\\trevert WrongOrderType();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Perform each exchange and accumulate payments.\\r\\n\\t\\t\\t_exchangeUnchecked(_recipient, _orders[i], _signatures[i], payments);\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\ti++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Fulfill the accumulated payment.\\r\\n\\t\\t_pay(payments, msg.sender, address(tokenTransferProxy));\\r\\n\\r\\n\\t\\t// Optionally invalidate other orders after performing this exchange.\\r\\n\\t\\tif (_toInvalidate.length > 0) {\\r\\n\\t\\t\\tcancelOrders(_toInvalidate);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/core/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport {\\r\\n\\tEntities,\\r\\n\\tSales,\\r\\n\\tAuthenticatedProxy\\r\\n} from \\\"./Entities.sol\\\";\\r\\nimport {\\r\\n\\tRoyaltyManager\\r\\n} from \\\"./RoyaltyManager.sol\\\";\\r\\nimport {\\r\\n\\tNativeTransfer\\r\\n} from \\\"../libraries/NativeTransfer.sol\\\";\\r\\nimport {\\r\\n\\tOwnableDelegateProxy\\r\\n} from \\\"../proxy/OwnableDelegateProxy.sol\\\";\\r\\nimport {\\r\\n\\tTokenTransferProxy,\\r\\n\\tIProxyRegistry,\\r\\n\\tAddress\\r\\n} from \\\"../proxy/TokenTransferProxy.sol\\\";\\r\\n\\r\\n/// Thrown if the user proxy does not exist (bytecode length is zero).\\r\\nerror UserProxyDoesNotExist ();\\r\\n\\r\\n/**\\r\\n\\tThrown if the user-proxy implementation is pointing to an unexpected \\r\\n\\timplementation.\\r\\n*/\\r\\nerror UnknownUserProxyImplementation ();\\r\\n\\r\\n/// Thrown if a call to the user-proxy are fails.\\r\\nerror CallToProxyFailed ();\\r\\n\\r\\n/**\\r\\n\\tThrown on order cancelation if the order already has been fulfilled or \\r\\n\\tcanceled.\\r\\n*/\\r\\nerror OrderIsAlreadyCancelled ();\\r\\n\\r\\n/**\\r\\n\\tThrown when attempting order cancelation functions, if checks for msg.sender,\\r\\n\\torder nonce or signatures are failed. \\r\\n*/\\r\\nerror CannotAuthenticateOrder ();\\r\\n\\r\\n/**\\r\\n\\tThrown if order terms are invalid, expired, or the provided exchange address \\r\\n\\tdoes not match this contract.\\r\\n*/\\r\\nerror InvalidOrder ();\\r\\n\\r\\n/**\\r\\n\\tThrown if insufficient value is sent to fulfill an order price.\\r\\n*/\\r\\nerror NotEnoughValueSent ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title GigaMart Executor\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\t@custom:contributor throw; <@0xthrpw>\\r\\n\\t\\r\\n\\tThis first iteration of the exchange executor is inspired by the old Wyvern \\r\\n\\tarchitecture `ExchangeCore`.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nabstract contract Executor is RoyaltyManager {\\r\\n\\tusing Entities for Entities.Order;\\r\\n\\tusing NativeTransfer for address;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA specific 13 second duration, slightly longer than the duration of one \\r\\n\\t\\tblock, so as to allow the successful execution of orders within a leeway of \\r\\n\\t\\tapproximately one block.\\r\\n\\t*/\\r\\n\\tuint256 private constant LUCKY_NUMBER = 13;\\r\\n\\r\\n\\t/// The selector for EIP-1271 contract-based signatures.\\r\\n\\tbytes4 internal constant EIP_1271_SELECTOR = bytes4(\\r\\n\\t\\tkeccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\r\\n\\t);\\r\\n\\r\\n\\t/// A reference to the immutable proxy registry.\\r\\n\\tIProxyRegistry public immutable registry;\\r\\n\\r\\n\\t/// A global, shared token transfer proxy for fulfilling exchanges.\\r\\n\\tTokenTransferProxy public immutable tokenTransferProxy;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA mapping from each caller to the minimum nonce of their order books. When \\r\\n\\t\\ta caller increments their nonce, all user offers with nonces below the \\r\\n\\t\\tvalue in this mapping are canceled.\\r\\n\\t*/\\r\\n\\tmapping ( address => uint256 ) public minOrderNonces;\\r\\n\\r\\n\\t/// A mapping of all orders which have been canceled or finalized.\\r\\n\\tmapping ( bytes32 => bool ) public cancelledOrFinalized;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEmitted when an order is canceled.\\r\\n\\r\\n\\t\\t@param maker The order maker's address.\\r\\n\\t\\t@param hash The hash of the order.\\r\\n\\t\\t@param data The parameters of the order concatenated together, e.g. \\r\\n\\t\\t\\t{collection address, encoded transfer function call}.\\r\\n\\t*/\\r\\n\\tevent OrderCancelled (\\r\\n\\t\\taddress indexed maker,\\r\\n\\t\\tbytes32 hash,\\r\\n\\t\\tbytes data\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEmitted when an item has been successfully exchanged.\\r\\n\\r\\n\\t\\t@param order The hash of the order.\\r\\n\\t\\t@param maker The order maker's address.\\r\\n\\t\\t@param taker The order taker's address.\\r\\n\\t\\t@param data An array of bytes that contains the order sale kind, price, \\r\\n\\t\\t\\ttarget, data, and success status.\\r\\n\\t*/\\r\\n\\tevent OrderResult (\\r\\n\\t\\tbytes32 order,\\r\\n\\t\\taddress indexed maker,\\r\\n\\t\\taddress indexed taker,\\r\\n\\t\\tbytes data\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new instance of the GigaMart order executor.\\r\\n\\r\\n\\t\\t@param _registry The address of the existing proxy registry.\\r\\n\\t\\t@param _tokenTransferProxy The address of the token transfer proxy contract.\\r\\n\\t\\t@param _validator The address of a privileged validator for permitting \\r\\n\\t\\t\\tcollection administrators to control their royalty fees.\\r\\n\\t\\t@param _protocolFeeRecipient The address which receives fees from the \\r\\n\\t\\t\\texchange.\\r\\n\\t\\t@param _protocolFeePercent The percent of fees taken by \\r\\n\\t\\t\\t`_protocolFeeRecipient` in basis points (1/100th %; i.e. 200 = 2%).\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\tIProxyRegistry _registry,\\r\\n\\t\\tTokenTransferProxy _tokenTransferProxy,\\r\\n\\t\\taddress _validator,\\r\\n\\t\\taddress _protocolFeeRecipient,\\r\\n\\t\\tuint96 _protocolFeePercent\\r\\n\\t) RoyaltyManager(_validator, _protocolFeeRecipient, _protocolFeePercent) {\\r\\n\\t\\ttokenTransferProxy = _tokenTransferProxy;\\r\\n\\t\\tregistry = _registry;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tHash an order and return the hash that a client must sign, including the \\r\\n\\t\\tstandard message prefix.\\r\\n\\r\\n\\t\\t@param _order The order to sign.\\r\\n\\r\\n\\t\\t@return _ The order hash that must be signed by the client.\\r\\n\\t*/\\r\\n\\tfunction _hashToSign (\\r\\n\\t\\tEntities.Order memory _order\\r\\n\\t) private view returns (bytes32) {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t\\tabi.encodePacked(\\r\\n\\t\\t\\t\\t\\\"\\\\x19\\\\x01\\\",\\r\\n\\t\\t\\t\\t_deriveDomainSeparator(),\\r\\n\\t\\t\\t\\t_order.hash()\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tCancel an order, preventing it from being matched. An order must be \\r\\n\\t\\tcanceled by its maker.\\r\\n\\t\\t\\r\\n\\t\\t@param order The `Order` to cancel.\\r\\n\\r\\n\\t\\t@custom:throws OrderAlreadyCancelled if the order has already been \\r\\n\\t\\t\\tfulfilled, individually canceled, or mass-canceled.\\r\\n\\t\\t@custom:throws CannotAuthenticateOrder if the caller is not the maker of \\r\\n\\t\\t\\tthe order.\\r\\n\\t*/\\r\\n\\tfunction _cancelOrder (\\r\\n\\t\\tEntities.Order calldata order\\r\\n\\t) internal {\\r\\n\\r\\n\\t\\t// Calculate the order hash.\\r\\n\\t\\tbytes32 hash = _hashToSign(order);\\r\\n\\r\\n\\t\\t// Verify order is still live.\\r\\n\\t\\tif (\\r\\n\\t\\t\\tcancelledOrFinalized[hash] ||\\torder.nonce < minOrderNonces[msg.sender]\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert OrderIsAlreadyCancelled();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Verify the order is being canceled by its maker.\\r\\n\\t\\tif (order.outline.maker != msg.sender) {\\r\\n\\t\\t\\trevert CannotAuthenticateOrder();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Cancel the order and log the event.\\r\\n\\t\\tcancelledOrFinalized[hash] = true;\\r\\n\\t\\temit OrderCancelled(\\r\\n\\t\\t\\torder.outline.maker,\\r\\n\\t\\t\\thash,\\r\\n\\t\\t\\tabi.encode(order.outline.target, order.data)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tTransfer multiple items using the user-proxy and executable bytecode.\\r\\n\\r\\n\\t\\t@param _targets The array of addresses which should be called with the \\r\\n\\t\\t\\tfunction calls encoded in `_data`.\\r\\n\\t\\t@param _data The array of encoded function calls performed against the \\r\\n\\t\\t\\taddresses in `_targets`.\\r\\n\\r\\n\\t\\t@custom:throws UserProxyDoesNotExist if the targeted delegate proxy for the \\r\\n\\t\\t\\tuser does not exist.\\r\\n\\t\\t@custom:throws UnknownUserProxyImplementation if the targeted delegate \\r\\n\\t\\t\\tproxy implementation is not as expected.\\r\\n\\t\\t@custom:throws CallToProxyFailed if an encoded call to the proxy fails.\\r\\n\\t*/\\r\\n\\tfunction _multiTransfer (\\r\\n\\t\\taddress[] calldata _targets,\\r\\n\\t\\tbytes[] calldata _data\\r\\n\\t) internal {\\r\\n\\r\\n\\t\\t// Store the registry object in memory to save gas.\\r\\n\\t\\tIProxyRegistry proxyRegistry = registry;\\r\\n\\r\\n\\t\\t// Retrieve the caller's delegate proxy, verifying that it exists.\\r\\n\\t\\taddress delegateProxy = proxyRegistry.proxies(msg.sender);\\r\\n\\t\\tif (!Address.isContract(delegateProxy)) {\\r\\n\\t\\t\\trevert UserProxyDoesNotExist();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Verify that the implementation of the user's delegate proxy is expected.\\r\\n\\t\\tif (\\r\\n\\t\\t\\tOwnableDelegateProxy(payable(delegateProxy)).implementation() !=\\r\\n\\t\\t\\tproxyRegistry.delegateProxyImplementation()\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert UnknownUserProxyImplementation();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Access the passthrough `AuthenticatedProxy` to make transfer calls.\\r\\n\\t\\tAuthenticatedProxy proxy = AuthenticatedProxy(payable(delegateProxy));\\r\\n\\t\\tfor (uint256 i; i < _targets.length; ) {\\r\\n\\r\\n\\t\\t\\t// Perform each encoded call and verify that they succeeded.\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\t!proxy.call(\\r\\n\\t\\t\\t\\t\\t_targets[i],\\r\\n\\t\\t\\t\\t\\tAuthenticatedProxy.CallType.Call,\\r\\n\\t\\t\\t\\t\\t_data[i]\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\trevert CallToProxyFailed();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\t++i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tPerform validation on the supplied `_taker` and `_order` address. This \\r\\n\\t\\tvalidation ensures that the correct exchange is used and that the order \\r\\n\\t\\tmaker is neither the recipient, message sender, or zero address. This \\r\\n\\t\\tvalidation also ensures that the salekind is sensible and matches the \\r\\n\\t\\tprovided order parameters.\\r\\n\\r\\n\\t\\t@param _taker The address of the order taker.\\r\\n\\t\\t@param _order The order to perform parameter validation against.\\r\\n\\r\\n\\t\\t@return _ Whether or not the specified `_order` is valid to be fulfilled by \\r\\n\\t\\t\\tthe `_taker`.\\r\\n\\t*/\\r\\n\\tfunction _validateOrderParameters (\\r\\n\\t\\taddress _taker,\\r\\n\\t\\tEntities.Order memory _order\\r\\n\\t) private view returns (bool) {\\r\\n\\r\\n\\t\\t// Verify that the order is targeted at this exchange contract.\\r\\n\\t\\tif (_order.outline.exchange != address(this)) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tVerify that the order maker is not the `_taker`, nor the msg.sender, nor \\r\\n\\t\\t\\tthe zero address.\\r\\n\\t\\t*/\\r\\n\\t\\tif (\\r\\n\\t\\t\\t_order.outline.maker == _taker ||\\r\\n\\t\\t\\t_order.outline.maker == msg.sender ||\\r\\n\\t\\t\\t_order.outline.maker == address(0)\\r\\n\\t\\t) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tIn a typical Wyvern order flow, this is the point where one would ensure \\r\\n\\t\\t\\tthat the order target exists. This is done to prevent the low-hanging \\r\\n\\t\\t\\tattack of a malicious item collection self-destructing and rendering \\r\\n\\t\\t\\torders worthless. This protection uses a not-insignificant amount of gas \\r\\n\\t\\t\\tand does not prevent against additional malicious attacks such as \\r\\n\\t\\t\\tfront-running from an upgradeable contract. Given the number of other \\r\\n\\t\\t\\tpossible rugpulls that an item collection could pull against its holders, \\r\\n\\t\\t\\tthis seems like a reasonable trade-off.\\r\\n\\t\\t*/\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tAllow the fulfillment of an order if the current block time is within the \\r\\n\\t\\t\\tlisting and expiration time of that order, less a small gap to support \\r\\n\\t\\t\\tthe case of immediate signature creation and fulfillment within a single \\r\\n\\t\\t\\tblock.\\r\\n\\t\\t*/\\r\\n\\t\\tif (\\r\\n\\t\\t\\t!Sales._canSettleOrder(\\r\\n\\t\\t\\t\\t_order.outline.listingTime - LUCKY_NUMBER,\\r\\n\\t\\t\\t\\t_order.outline.expirationTime\\r\\n\\t\\t\\t)\\r\\n\\t\\t) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Validate the call to ensure the correct function selector is being used.\\r\\n\\t\\tif (!_order.validateCall()) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// The order must possess a valid sale kind parameter.\\r\\n\\t\\tuint8 saleKind = uint8(_order.outline.saleKind);\\r\\n\\t\\tif (saleKind > 5) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Reject item sales which are presented as buy-sided.\\r\\n\\t\\tif (saleKind < 3 && _order.outline.side == Sales.Side.Buy) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Reject item offers which are presented as sell-sided.\\r\\n\\t\\tif (saleKind > 2 && _order.outline.side == Sales.Side.Sell) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tThere is no need to validate the `_taker` that may be later inserted into \\r\\n\\t\\t\\tthe order call data for our `FixedPrice` or `DecreasingPrice` sale kinds. \\r\\n\\t\\t\\tIn each of these cases, the message sender cannot achieve anything \\r\\n\\t\\t\\tmalicious by attempting to modify the `_taker` which is later inserted \\r\\n\\t\\t\\tinto the order.\\r\\n\\t\\t*/\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tThis sale kind is a `DirectListing`, which is meant to be a private \\r\\n\\t\\t\\tlisting of an item fulfillable by a single specific taker. For this kind \\r\\n\\t\\t\\tof order, we validate that the `_taker` specified is the same as the \\r\\n\\t\\t\\ttaker encoded in the order.\\r\\n\\t\\t*/\\r\\n\\t\\tif (saleKind == 2 && _taker != _order.outline.taker) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tThis sale kind is a `DirectOffer`, which is meant to be a private offer \\r\\n\\t\\t\\tfulfillable against only a single item by a single specific taker. In \\r\\n\\t\\t\\tother words, the offer does not follow the item if the item finds itself \\r\\n\\t\\t\\tin the hands of a new holder. For this kind of order, we validate that \\r\\n\\t\\t\\tthe `_taker` is both the message sender and the taker encoded in the \\r\\n\\t\\t\\torder.\\r\\n\\t\\t*/\\r\\n\\t\\tif (\\r\\n\\t\\t\\tsaleKind == 3 &&\\r\\n\\t\\t\\t(_order.outline.taker != msg.sender || _taker != _order.outline.taker)\\r\\n\\t\\t) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tThese two sale kinds correspond to `Offer` and `CollectionOffer`, each of \\r\\n\\t\\t\\twhich are publically fulfillable by multiple potential takers. For \\r\\n\\t\\t\\tfulfilling these kinds of orders, the `_taker` specified must be the \\r\\n\\t\\t\\tmessage sender, lest an item holder be forced to accept an offer against \\r\\n\\t\\t\\ttheir will.\\r\\n\\t\\t*/\\r\\n\\t\\tif ((saleKind == 4 || saleKind == 5) && _taker != msg.sender) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// All is validated successfully.\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA helper function to validate an EIP-1271 contract signature.\\r\\n\\r\\n\\t\\t@param _orderMaker The smart contract maker of the order.\\r\\n\\t\\t@param _hash The hash of the order.\\r\\n\\t\\t@param _sig The signature of the order to validate.\\r\\n\\r\\n\\t\\t@return _ Whether or not `_sig` is a valid signature of `_hash` by the \\r\\n\\t\\t\\t`_orderMaker` smart contract.\\r\\n\\t*/\\r\\n\\tfunction _recoverContractSignature (\\r\\n\\t\\taddress _orderMaker,\\r\\n\\t\\tbytes32 _hash,\\r\\n\\t\\tEntities.Sig memory _sig\\r\\n\\t) private view returns (bool) {\\r\\n\\t\\tbytes memory isValidSignatureData = abi.encodeWithSelector(\\r\\n\\t\\t\\tEIP_1271_SELECTOR,\\r\\n\\t\\t\\t_hash,\\r\\n\\t\\t\\tabi.encodePacked(_sig.r, _sig.s, _sig.v)\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tCall the `_orderMaker` smart contract and check for the specific magic \\r\\n\\t\\t\\tEIP-1271 result.\\r\\n\\t\\t*/\\r\\n\\t\\tbytes4 result;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlet success := staticcall(\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t// Forward all available gas.\\r\\n\\t\\t\\t\\tgas(),\\r\\n\\t\\t\\t\\t_orderMaker,\\r\\n\\t\\t\\r\\n\\t\\t\\t\\t// The calldata offset comes after length.\\r\\n\\t\\t\\t\\tadd(isValidSignatureData, 0x20),\\r\\n\\r\\n\\t\\t\\t\\t// Load calldata length.\\r\\n\\t\\t\\t\\tmload(isValidSignatureData), // load calldata length\\r\\n\\r\\n\\t\\t\\t\\t// Do not use memory for return data.\\r\\n\\t\\t\\t\\t0,\\r\\n\\t\\t\\t\\t0\\r\\n\\t\\t\\t)\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIf the call failed, copy return data to memory and pass through revert \\r\\n\\t\\t\\t\\tdata.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tif iszero(success) {\\r\\n\\t\\t\\t\\treturndatacopy(0, 0, returndatasize())\\r\\n\\t\\t\\t\\trevert(0, returndatasize())\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIf the return data is the expected size, copy it to memory and load it \\r\\n\\t\\t\\t\\tto our `result` on the stack.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tif eq(returndatasize(), 0x20) {\\r\\n\\t\\t\\t\\treturndatacopy(0, 0, 0x20)\\r\\n\\t\\t\\t\\tresult := mload(0)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// If the collected result is the expected selector, the signature is valid.\\r\\n\\t\\treturn result == EIP_1271_SELECTOR;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tValidate that a provided order `_hash` does not correspond to a finalized \\r\\n\\t\\torder, was not created with an invalidated nonce, and was actually signed \\r\\n\\t\\tby its maker `_maker` with signature `_sig`.\\r\\n\\r\\n\\t\\t@param _hash A hash of an `Order` to validate.\\r\\n\\t\\t@param _maker The address of the maker who signed the order `_hash`.\\r\\n\\t\\t@param _nonce A nonce in the order for checking validity in \\r\\n\\t\\t\\tmass-cancelation.\\r\\n\\t\\t@param _sig The ECDSA signature of the order `_hash`, which must have been \\r\\n\\t\\t\\tsigned by the order `_maker`.\\r\\n\\r\\n\\t\\t@return _ Whether or not the specified order `_hash` is authenticated as \\r\\n\\t\\t\\tvalid to continue fulfilling.\\r\\n\\t*/\\r\\n\\tfunction _authenticateOrder (\\r\\n\\t\\tbytes32 _hash,\\r\\n\\t\\taddress _maker,\\r\\n\\t\\tuint256 _nonce,\\r\\n\\t\\tEntities.Sig calldata _sig\\r\\n\\t) private view returns (bool) {\\r\\n\\r\\n\\t\\t// Verify that the order has not already been canceled or fulfilled.\\r\\n\\t\\tif (cancelledOrFinalized[_hash]) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Verify that the order was not createed with an expired nonce.\\r\\n\\t\\tif (_nonce < minOrderNonces[_maker]) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/* EOA-only authentication: ECDSA-signed by maker. */\\r\\n\\t\\t// Verify that the order hash was actually signed by the provided `_maker`.\\r\\n\\t\\tif (ecrecover(_hash, _sig.v, _sig.r, _sig.s) == _maker) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tIf the `_maker` is a smart contract, recover an EIP-1271 contract \\r\\n\\t\\t\\tsignature for attempted authentication.\\r\\n\\t\\t*/\\r\\n\\t\\tif (Address.isContract(_maker)) {\\r\\n\\t\\t\\treturn _recoverContractSignature(_maker, _hash, _sig);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tThe signature is not validated against either an EOA or smart contract \\r\\n\\t\\t\\tsigner and is therefore not valid.\\r\\n\\t\\t*/\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tExecute all ERC-20 token or Ether transfers associated with an order match, \\r\\n\\t\\tpaid for by the message sender.\\r\\n\\r\\n\\t\\t@param _order The order whose payment is being matched.\\r\\n\\t\\t@param _royaltyIndex Th\\r\\n\\r\\n\\t\\t@return _ The amount of payment required for order fulfillment in ERC-20 \\r\\n\\t\\t\\ttoken or Ether.\\r\\n\\r\\n\\t\\t@custom:throws NotEnoughValueSent if message value is insufficient to cover \\r\\n\\t\\t\\tan Ether payment.\\r\\n\\t*/\\r\\n\\tfunction _pay (\\r\\n\\t\\tEntities.Order memory _order,\\r\\n\\t\\tuint256 _royaltyIndex\\r\\n\\t) private returns (uint256) {\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tIf the order being fulfilled is an offer, the message sender is the party \\r\\n\\t\\t\\tselling an item. If the order being fulfilled is a listing, the message \\r\\n\\t\\t\\tsender is the party buying an item.\\r\\n\\t\\t*/\\r\\n\\t\\t(address seller, address buyer) = _order.outline.side == Sales.Side.Buy\\r\\n\\t\\t\\t? (msg.sender, _order.outline.maker)\\r\\n\\t\\t\\t: (_order.outline.maker, msg.sender);\\r\\n\\r\\n\\t\\t// Calculate a total price for fulfilling the order.\\r\\n\\t\\tuint256 requiredAmount = Sales._calculateFinalPrice(\\r\\n\\t\\t\\t_order.outline.saleKind,\\r\\n\\t\\t\\t_order.outline.basePrice,\\r\\n\\t\\t\\t_order.extra,\\r\\n\\t\\t\\t_order.outline.listingTime\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t// If the amount required for order fulfillment is not zero, then transfer.\\r\\n\\t\\tif (requiredAmount > 0) {\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tTrack the amount of payment that the seller will ultimately receive \\r\\n\\t\\t\\t\\tafter fees are deducted.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tuint256 receiveAmount = requiredAmount;\\r\\n\\r\\n\\t\\t\\t// Handle a payment in ERC-20 token.\\r\\n\\t\\t\\tif (_order.outline.paymentToken != address(0)) {\\r\\n\\r\\n\\t\\t\\t\\t// Store the token transfer proxy in memory to save gas.\\r\\n\\t\\t\\t\\tTokenTransferProxy proxy = tokenTransferProxy;\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\tStore fee configuration and charge platform fees. Platform fees are \\r\\n\\t\\t\\t\\t\\tconfigured in basis points.\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\tuint256 config = _protocolFee;\\r\\n\\t\\t\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\t\\t\\tuint256 fee = (requiredAmount * uint96(config)) / 10_000;\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tExtract the fee recipient address from the fee configuration and \\r\\n\\t\\t\\t\\t\\t\\ttransfer the platform fee. Deduct the fee from the maker's receipt.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tproxy.transferERC20(\\r\\n\\t\\t\\t\\t\\t\\t_order.outline.paymentToken,\\r\\n\\t\\t\\t\\t\\t\\tbuyer,\\r\\n\\t\\t\\t\\t\\t\\taddress(uint160(config >> 96)),\\r\\n\\t\\t\\t\\t\\t\\tfee\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\treceiveAmount -= fee;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Charge creator royalty fees based on the royalty index.\\r\\n\\t\\t\\t\\tconfig = royalties[_order.outline.target][_royaltyIndex];\\r\\n\\t\\t\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\t\\t\\tuint256 fee = (requiredAmount * uint96(config)) / 10_000;\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tExtract the fee recipient address from the fee configuration and \\r\\n\\t\\t\\t\\t\\t\\ttransfer the royalty fee. Deduct the fee from the maker's receipt.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tproxy.transferERC20(\\r\\n\\t\\t\\t\\t\\t\\t_order.outline.paymentToken,\\r\\n\\t\\t\\t\\t\\t\\tbuyer,\\r\\n\\t\\t\\t\\t\\t\\taddress(uint160(config >> 96)),\\r\\n\\t\\t\\t\\t\\t\\tfee\\r\\n\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\treceiveAmount -= fee;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Transfer the remainder of the payment to the item seller.\\r\\n\\t\\t\\t\\tproxy.transferERC20(\\r\\n\\t\\t\\t\\t\\t_order.outline.paymentToken,\\r\\n\\t\\t\\t\\t\\tbuyer,\\r\\n\\t\\t\\t\\t\\tseller,\\r\\n\\t\\t\\t\\t\\treceiveAmount\\r\\n\\t\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t// Handle a payment in Ether.\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tif (msg.value < requiredAmount) {\\r\\n\\t\\t\\t\\t\\trevert NotEnoughValueSent();\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\tStore fee configuration and charge platform fees. Platform fees are \\r\\n\\t\\t\\t\\t\\tconfigured in basis points.\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\tuint256 config = _protocolFee;\\r\\n\\t\\t\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\t\\t\\tuint256 fee = (requiredAmount * uint96(config)) / 10_000;\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tExtract the fee recipient address from the fee configuration and \\r\\n\\t\\t\\t\\t\\t\\ttransfer the platform fee. Deduct the fee from the maker's receipt.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\taddress(uint160(config >> 96)).transferEth(fee);\\r\\n\\t\\t\\t\\t\\treceiveAmount -= fee;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Charge creator royalty fees based on the the royalty index.\\r\\n\\t\\t\\t\\tconfig = royalties[_order.outline.target][_royaltyIndex];\\r\\n\\t\\t\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\t\\t\\tuint256 fee = (requiredAmount * uint96(config)) / 10_000;\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tExtract the fee recipient address from the fee configuration and \\r\\n\\t\\t\\t\\t\\t\\ttransfer the royalty fee. Deduct the fee from the maker's receipt.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\taddress(uint160(config >> 96)).transferEth(fee);\\r\\n\\t\\t\\t\\t\\treceiveAmount -= fee;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Transfer the remainder of the payment to the item seller.\\r\\n\\t\\t\\t\\tseller.transferEth(receiveAmount);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Return the required payment amount.\\r\\n\\t\\treturn requiredAmount;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tPerform the exchange of an item for an ERC-20 token or Ether in fulfilling \\r\\n\\t\\tthe given `_order`.\\r\\n\\r\\n\\t\\t@param _taker The address of the caller who fulfills the order.\\r\\n\\t\\t@param _order The `Order` to execute.\\r\\n\\t\\t@param _signature The signature provided for fulfilling the order, signed \\r\\n\\t\\t\\tby the order maker.\\r\\n\\t\\t@param _tokenId The unique token ID of the item involved in the order.\\r\\n\\r\\n\\t\\t@custom:throws InvalidOrder if the order parameters cannot be validated.\\r\\n\\t\\t@custom:throws CannotAuthenticateOrder if the order parameters cannot be \\r\\n\\t\\t\\tauthenticated.\\r\\n\\t\\t@custom:throws UserProxyDoesNotExist if the targeted delegate proxy for the \\r\\n\\t\\t\\tuser does not exist.\\r\\n\\t\\t@custom:throws UnknownUserProxyImplementation if the targeted delegate \\r\\n\\t\\t\\tproxy implementation is not as expected.\\r\\n\\t\\t@custom:throws CallToProxyFailed if the encoded call to the proxy fails.\\r\\n\\t*/\\r\\n\\tfunction _exchange (\\r\\n\\t\\taddress _taker,\\r\\n\\t\\tEntities.Order memory _order,\\r\\n\\t\\tEntities.Sig calldata _signature,\\r\\n\\t\\tuint256 _tokenId\\r\\n\\t) internal {\\r\\n\\r\\n\\t\\t// Retrieve the order hash.\\r\\n\\t\\tbytes32 hash = _hashToSign(_order);\\r\\n\\r\\n\\t\\t// Validate the order.\\r\\n\\t\\tif (!_validateOrderParameters(_taker, _order)) {\\r\\n\\t\\t\\trevert InvalidOrder();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Authenticate the order.\\r\\n\\t\\tif (\\r\\n\\t\\t\\t!_authenticateOrder(\\r\\n\\t\\t\\t\\thash,\\r\\n\\t\\t\\t\\t_order.outline.maker,\\r\\n\\t\\t\\t\\t_order.nonce,\\r\\n\\t\\t\\t\\t_signature\\r\\n\\t\\t\\t)\\r\\n\\t\\t) { \\r\\n\\t\\t\\trevert CannotAuthenticateOrder();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Store the registry object in memory to save gas.\\r\\n\\t\\tIProxyRegistry proxyRegistry = registry;\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tRetrieve the delegate proxy address and implementation contract address \\r\\n\\t\\t\\tof the side of the order exchanging their item for an ERC-20 token or \\r\\n\\t\\t\\tEther.\\r\\n\\t\\t*/\\r\\n\\t\\t(address delegateProxy, address implementation) = proxyRegistry\\r\\n\\t\\t\\t.userProxyConfig(\\r\\n\\t\\t\\t\\t_order.outline.side == Sales.Side.Buy\\r\\n\\t\\t\\t\\t\\t? msg.sender\\r\\n\\t\\t\\t\\t\\t: _order.outline.maker\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t// Verify that the user's delegate proxy exists.\\r\\n\\t\\tif (!Address.isContract(delegateProxy)) {\\r\\n\\t\\t\\trevert UserProxyDoesNotExist();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Verify that the implementation of the user's delegate proxy is expected.\\r\\n\\t\\tif (\\r\\n\\t\\t\\tOwnableDelegateProxy(payable(delegateProxy)).implementation() !=\\r\\n\\t\\t\\timplementation\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert UnknownUserProxyImplementation();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Access the passthrough `AuthenticatedProxy` to make transfer calls.\\r\\n\\t\\tAuthenticatedProxy proxy = AuthenticatedProxy(payable(delegateProxy));\\r\\n\\r\\n\\t\\t// Populate the order call data depending on the sale type.\\r\\n\\t\\t_order.generateCall(_taker, _tokenId);\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tPerform the encoded call against the delegate proxy and verify that it \\r\\n\\t\\t\\tsucceeded.\\r\\n\\t\\t*/\\r\\n\\t\\tif (\\r\\n\\t\\t\\t!proxy.call(\\r\\n\\t\\t\\t\\t_order.outline.target,\\r\\n\\t\\t\\t\\tAuthenticatedProxy.CallType.Call,\\r\\n\\t\\t\\t\\t_order.data\\r\\n\\t\\t\\t)\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert CallToProxyFailed();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tFulfill order payment and refund the message sender if needed. The first \\r\\n\\t\\t\\telement of the order extra field contains the royalty index corresponding \\r\\n\\t\\t\\tto the collection royalty fee that was created at the time of order \\r\\n\\t\\t\\tsigning.\\r\\n\\t\\t*/\\r\\n\\t\\tuint256 price = _pay(_order, _order.extra[0]);\\r\\n\\t\\tif (msg.value > price) {\\r\\n\\t\\t\\tmsg.sender.transferEth(msg.value - price);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Mark the order as finalized.\\r\\n\\t\\tcancelledOrFinalized[hash] = true;\\r\\n\\r\\n\\t\\t// Condense order settlement status for event emission.\\r\\n\\t\\tbytes memory settledParameters = abi.encodePacked(\\r\\n\\t\\t\\t_order.outline.saleKind,\\r\\n\\t\\t\\tprice,\\r\\n\\t\\t\\t_order.outline.target,\\r\\n\\t\\t\\t_order.data,\\r\\n\\t\\t\\tbytes1(0xFF)\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t// Emit an event with the results of this order.\\r\\n\\t\\temit OrderResult(\\r\\n\\t\\t\\thash,\\r\\n\\t\\t\\t_order.outline.maker,\\r\\n\\t\\t\\t_taker,\\r\\n\\t\\t\\tsettledParameters\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA helper function to emit an `OrderResult` event while avoiding a \\r\\n\\t\\tstack-depth error.\\r\\n\\r\\n\\t\\t@param _recipient The address which will receive the item.\\r\\n\\t\\t@param _order The `Order` to execute.\\r\\n\\t\\t@param _hash The hash of the order.\\r\\n\\t\\t@param _code Error codes for the reason of order failure.\\r\\n\\t\\t@param _price The price at which the order was fulfilled.\\r\\n\\t*/\\r\\n\\tfunction _emitResult (\\r\\n\\t\\taddress _recipient,\\r\\n\\t\\tEntities.Order memory _order,\\r\\n\\t\\tbytes32 _hash,\\r\\n\\t\\tbytes1 _code,\\r\\n\\t\\tuint256 _price\\r\\n\\t) private {\\r\\n\\t\\temit OrderResult(\\r\\n\\t\\t\\t_hash,\\r\\n\\t\\t\\t_order.outline.maker,\\r\\n\\t\\t\\t_recipient,\\r\\n\\t\\t\\tabi.encodePacked(\\r\\n\\t\\t\\t\\t_order.outline.saleKind,\\r\\n\\t\\t\\t\\t_price,\\r\\n\\t\\t\\t\\t_order.outline.target,\\r\\n\\t\\t\\t\\t_order.data,\\r\\n\\t\\t\\t\\t_code\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tFind similiar existing payment token addresses and increases their amount.\\r\\n\\t\\tIf payment tokens are not found, create a new payment element.\\r\\n\\r\\n\\t\\t@param _payments An array to accumulate payment elements.\\r\\n\\t\\t@param _paymentToken The payment token used in fulfilling the order.\\r\\n\\t\\t@param _recipient The order maker.\\r\\n\\t\\t@param _price The price of fulfilling the order.\\r\\n\\t*/\\r\\n\\tfunction _insert (\\r\\n\\t\\tbytes memory _payments,\\r\\n\\t\\taddress _paymentToken,\\r\\n\\t\\tuint256 _recipient,\\r\\n\\t\\tuint256 _price\\r\\n\\t) private pure {\\r\\n\\t\\tassembly {\\r\\n\\r\\n\\t\\t\\t// Iterate through the `_payments` array in chunks of size 0x60.\\r\\n\\t\\t\\tlet len := div(mload(add(_payments, 0x00)), 0x60)\\r\\n\\t\\t\\tlet found := false\\r\\n\\t\\t\\tfor {\\r\\n\\t\\t\\t\\tlet i := 0\\r\\n\\t\\t\\t} lt(i, len) {\\r\\n\\t\\t\\t\\ti := add(i, 1)\\r\\n\\t\\t\\t} {\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\tLoad the token at this position of the array. If it is equal to the \\r\\n\\t\\t\\t\\t\\tpayment token, check the payment destination.\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\tlet token := mload(add(_payments, add(mul(i, 0x60), 0x20)))\\r\\n\\t\\t\\t\\tif eq(token, _paymentToken) {\\r\\n\\t\\t\\t\\t\\tlet offset := add(_payments, add(mul(i, 0x60), 0x60))\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tIf the payment destination is the recipient, increase the amount \\r\\n\\t\\t\\t\\t\\t\\tthey are already being paid.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tlet to := mload(add(_payments, add(mul(i, 0x60), 0x40)))\\r\\n\\t\\t\\t\\t\\tif eq(to, _recipient) {\\r\\n\\t\\t\\t\\t\\t\\tlet amount := mload(offset)\\r\\n\\t\\t\\t\\t\\t\\tmstore(offset, add(amount, _price))\\r\\n\\t\\t\\t\\t\\t\\tfound := true\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// If the payment recipient was not found, insert their payment.\\r\\n\\t\\t\\tif eq(found, 0) {\\r\\n\\t\\t\\t\\tswitch len\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\tIn the event of the initial insert, we've already allocated 0x20 \\r\\n\\t\\t\\t\\t\\tbytes and only need to allocate 0x40 more to fit our three payment \\r\\n\\t\\t\\t\\t\\tvariables.\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\t\\tmstore(\\r\\n\\t\\t\\t\\t\\t\\tadd(_payments, 0x00),\\r\\n\\t\\t\\t\\t\\t\\tadd(mload(add(_payments, 0x00)), 0x40)\\r\\n\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Increase the size of the array by 0x60.\\r\\n\\t\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\t\\tmstore(\\r\\n\\t\\t\\t\\t\\t\\tadd(_payments, 0x00),\\r\\n\\t\\t\\t\\t\\t\\tadd(mload(add(_payments, 0x00)), 0x60)\\r\\n\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Store the payment token, recipient, and amount.\\r\\n\\t\\t\\t\\tlet offset := add(_payments, mul(len, 0x60))\\r\\n\\t\\t\\t\\tmstore(add(offset, 0x20), _paymentToken)\\r\\n\\t\\t\\t\\tmstore(add(offset, 0x40), _recipient)\\r\\n\\t\\t\\t\\tmstore(add(offset, 0x60), _price)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tGenerates a unique payment token transfer calls and adds it to the \\r\\n\\t\\t`_payments` array.\\r\\n\\r\\n\\t\\t@param _payments An array to accumulate payment elements.\\r\\n\\t\\t@param _paymentToken The payment token used in fulfilling the order.\\r\\n\\t\\t@param _royaltyIndex The index of the royalty for the item collection with \\r\\n\\t\\t\\twhich royalty fees should be calculated.\\r\\n\\t\\t@param _recipient The order maker.\\r\\n\\t\\t@param _price The price of fulfilling the order.\\r\\n\\t\\t@param _collection The item collection address.\\r\\n\\t*/\\r\\n\\tfunction _addPayment (\\r\\n\\t\\tbytes memory _payments,\\r\\n\\t\\taddress _paymentToken,\\r\\n\\t\\tuint256 _royaltyIndex,\\r\\n\\t\\tuint256 _recipient,\\r\\n\\t\\tuint256 _price,\\r\\n\\t\\taddress _collection\\r\\n\\t) private view {\\r\\n\\t\\tuint256 finalPrice = _price;\\r\\n\\r\\n\\t\\t// Insert the protocol fee.\\r\\n\\t\\tuint256 config = _protocolFee;\\r\\n\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\tuint256 fee = (_price * uint96(config)) / 10_000;\\r\\n\\t\\t\\t\\tconfig = (config >> 96);\\r\\n\\t\\t\\t\\t_insert(_payments, _paymentToken, config, fee);\\r\\n\\t\\t\\t\\tfinalPrice -= fee;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Insert the royalty payment.\\r\\n\\t\\tconfig = royalties[_collection][_royaltyIndex];\\r\\n\\t\\tif (uint96(config) != 0) {\\r\\n\\t\\t\\tunchecked {\\r\\n\\t\\t\\t\\tuint256 fee = (_price * uint96(config)) / 10_000;\\r\\n\\t\\t\\t\\tconfig = (config >> 96);\\r\\n\\t\\t\\t\\t_insert(_payments, _paymentToken, config, fee);\\r\\n\\t\\t\\t\\tfinalPrice -= fee;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Insert the final payment to the end recipient into the payment array.\\r\\n\\t\\t_insert(_payments, _paymentToken, _recipient, finalPrice);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tExecutes orders in the context of fulfilling potentially-multiple item \\r\\n\\t\\tlistings. This function cannot be used for fulfilling offers. This function \\r\\n\\t\\taccumulates payment information in `_payments` for single-shot processing.\\r\\n\\r\\n\\t\\t@param _recipient The address which will receive the item.\\r\\n\\t\\t@param _order The `Order` to execute.\\r\\n\\t\\t@param _signature The signature provided for fulfilling the order, signed \\r\\n\\t\\t\\tby the order maker.\\r\\n\\t\\t@param _payments An array for accumulating payment information.\\r\\n\\t*/\\r\\n\\tfunction _exchangeUnchecked (\\r\\n\\t\\taddress _recipient,\\r\\n\\t\\tEntities.Order memory _order,\\r\\n\\t\\tEntities.Sig calldata _signature,\\r\\n\\t\\tbytes memory _payments\\r\\n\\t) internal {\\r\\n\\r\\n\\t\\t// Retrieve the order hash.\\r\\n\\t\\tbytes32 hash = _hashToSign(_order);\\r\\n\\t\\t{\\r\\n\\r\\n\\t\\t\\t// Validate the order.\\r\\n\\t\\t\\tif (!_validateOrderParameters(_recipient, _order)) {\\r\\n\\t\\t\\t\\t_emitResult(_recipient, _order, hash, 0x11, 0);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Authenticate the order.\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\t!_authenticateOrder(\\r\\n\\t\\t\\t\\t\\thash,\\r\\n\\t\\t\\t\\t\\t_order.outline.maker,\\r\\n\\t\\t\\t\\t\\t_order.nonce,\\r\\n\\t\\t\\t\\t\\t_signature\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\t_emitResult(_recipient, _order, hash, 0x12, 0);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Store the registry object in memory to save gas.\\r\\n\\t\\t\\tIProxyRegistry proxyRegistry = registry;\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tRetrieve the delegate proxy address and implementation contract address \\r\\n\\t\\t\\t\\tof the side of the order exchanging their item for an ERC-20 token or \\r\\n\\t\\t\\t\\tEther.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\t(address delegateProxy, address implementation) = proxyRegistry\\r\\n\\t\\t\\t\\t.userProxyConfig(_order.outline.maker);\\r\\n\\r\\n\\t\\t\\t// Verify that the user's delegate proxy exists.\\r\\n\\t\\t\\tif (!Address.isContract(delegateProxy)) {\\r\\n\\t\\t\\t\\t_emitResult(_recipient, _order, hash, 0x43, 0);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Verify the implementation of the user's delegate proxy is expected.\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\tOwnableDelegateProxy(payable(delegateProxy)).implementation() !=\\r\\n\\t\\t\\t\\timplementation\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\t_emitResult(_recipient, _order, hash, 0x44, 0);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Access the passthrough `AuthenticatedProxy` to make transfer calls.\\r\\n\\t\\t\\tAuthenticatedProxy proxy = AuthenticatedProxy(payable(delegateProxy));\\r\\n\\r\\n\\t\\t\\t// Populate the order call data depending on the sale type.\\r\\n\\t\\t\\t_order.generateCall(_recipient, 0);\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tPerform the encoded call against the delegate proxy and verify that it \\r\\n\\t\\t\\t\\tsucceeded.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\t!proxy.call(\\r\\n\\t\\t\\t\\t\\t_order.outline.target,\\r\\n\\t\\t\\t\\t\\tAuthenticatedProxy.CallType.Call,\\r\\n\\t\\t\\t\\t\\t_order.data\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\t_emitResult(_recipient, _order, hash, 0x50, 0);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t{\\r\\n\\r\\n\\t\\t\\t// Calculate a total price for fulfilling the order.\\r\\n\\t\\t\\tuint256 price = Sales._calculateFinalPrice(\\r\\n\\t\\t\\t\\t_order.outline.saleKind,\\r\\n\\t\\t\\t\\t_order.outline.basePrice,\\r\\n\\t\\t\\t\\t_order.extra,\\r\\n\\t\\t\\t\\t_order.outline.listingTime\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t// Add the calculated price to the payments accumulator.\\r\\n\\t\\t\\t_addPayment(\\r\\n\\t\\t\\t\\t_payments,\\r\\n\\t\\t\\t\\t_order.outline.paymentToken,\\r\\n\\t\\t\\t\\t_order.extra[0],\\r\\n\\t\\t\\t\\tuint256(uint160(_order.outline.maker)),\\r\\n\\t\\t\\t\\tprice,\\r\\n\\t\\t\\t\\t_order.outline.target\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t\\t\\t// Mark the order as finalized and emit the final result.\\r\\n\\t\\t\\tcancelledOrFinalized[hash] = true;\\r\\n\\t\\t\\t_emitResult(_recipient, _order, hash, 0xFF, price);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tExecute all payments from the provided `_payments` array.\\r\\n\\r\\n\\t\\t@param _payments A bytes array of accumulated payment data, populated by \\r\\n\\t\\t\\t`_exchangeUnchecked` and `_addPayment`.\\r\\n\\t\\t@param _buyer The caller paying to fulfill these payments.\\r\\n\\t\\t@param _proxy The address of a token transfer proxy.\\r\\n\\t*/\\r\\n\\tfunction _pay (\\r\\n\\t\\tbytes memory _payments,\\r\\n\\t\\taddress _buyer,\\r\\n\\t\\taddress _proxy\\r\\n\\t) internal {\\r\\n\\t\\tbytes4 sig = TokenTransferProxy.transferERC20.selector;\\r\\n\\t\\tuint256 ethPayment;\\r\\n\\t\\tassembly {\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tTake the `_payments` and determine the length in discrete chunks of \\r\\n\\t\\t\\t\\tsize 0x60. Iterate through each chunk.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tlet len := div(mload(add(_payments, 0x00)), 0x60)\\r\\n\\t\\t\\tfor {\\r\\n\\t\\t\\t\\tlet i := 0\\r\\n\\t\\t\\t} lt(i, len) {\\r\\n\\t\\t\\t\\ti := add(i, 1)\\r\\n\\t\\t\\t} {\\r\\n\\r\\n\\t\\t\\t\\t// Extract the token, to, and amount tuples from the array chunks.\\r\\n\\t\\t\\t\\tlet token := mload(add(_payments, add(mul(i, 0x60), 0x20)))\\r\\n\\t\\t\\t\\tlet to := mload(add(_payments, add(mul(i, 0x60), 0x40)))\\r\\n\\t\\t\\t\\tlet amount := mload(add(_payments, add(mul(i, 0x60), 0x60)))\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t// Switch and handle the case of sending and accumulating Ether.\\r\\n\\t\\t\\t\\tswitch token\\r\\n\\t\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\t\\tethPayment := add(ethPayment, amount)\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tAttempt to pay `amount` Ether to the `to` destination, reverting if \\r\\n\\t\\t\\t\\t\\t\\tunsuccessful.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tlet result := call(gas(), to, amount, 0, 0, 0, 0)\\r\\n\\t\\t\\t\\t\\tif iszero(result) {\\r\\n\\t\\t\\t\\t\\t\\trevert(0, 0)\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Handle the case of ERC-20 token transfers.\\r\\n\\t\\t\\t\\tdefault {\\r\\n\\r\\n\\t\\t\\t\\t\\t// Create a pointer at position 0x40.\\r\\n\\t\\t\\t\\t\\tlet data := mload(0x40)\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tCreate a valid `transferERC20` payload in data. TransferERC20 takes \\r\\n\\t\\t\\t\\t\\t\\tas parameters `_token`, `_from`, `_to`, and `_amount`.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tmstore(data, sig)\\r\\n\\t\\t\\t\\t\\tmstore(add(data, 0x04), token)\\r\\n\\t\\t\\t\\t\\tmstore(add(data, 0x24), _buyer)\\r\\n\\t\\t\\t\\t\\tmstore(add(data, 0x44), to)\\r\\n\\t\\t\\t\\t\\tmstore(add(data, 0x64), amount)\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\tAttempt to execute the ERC-20 transfer, reverting upon failure. The \\r\\n\\t\\t\\t\\t\\t\\tsize of the data is 0x84.\\r\\n\\t\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t\\tlet result := call(gas(), _proxy, 0, data, 0x84, 0, 0)\\r\\n\\t\\t\\t\\t\\tif iszero(result) {\\r\\n\\t\\t\\t\\t\\t\\trevert(0, 0)\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Refund any excess Ether to the buyer.\\r\\n\\t\\tif (msg.value > ethPayment) {\\r\\n\\t\\t\\t_buyer.transferEth(msg.value - ethPayment);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/core/Entities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"../libraries/Sales.sol\\\";\\r\\nimport \\\"../proxy/AuthenticatedProxy.sol\\\";\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Entities Library\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA library for managing supported order entities and helper functions.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nlibrary Entities {\\r\\n\\r\\n\\t/// The function selector for an ERC-1155 transfer.\\r\\n\\tbytes4 internal constant _ERC1155_TRANSFER_SELECTOR = 0xf242432a;\\r\\n\\r\\n\\t/// The function selector for an ERC-721 transfer.\\r\\n\\tbytes4 internal constant _ERC721_TRANSFER_SELECTOR = 0x23b872dd;\\r\\n\\r\\n\\t/// The EIP-712 typehash of an order outline.\\r\\n\\tbytes32 public constant OUTLINE_TYPEHASH =\\r\\n\\t\\tkeccak256(\\r\\n\\t\\t\\t\\\"Outline(uint256 basePrice,uint256 listingTime,uint256 expirationTime,address exchange,address maker,uint8 side,address taker,uint8 saleKind,address target,uint8 callType,address paymentToken)\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t/// The EIP-712 typehash of an order.\\r\\n\\tbytes32 public constant ORDER_TYPEHASH =\\r\\n\\t\\tkeccak256(\\r\\n\\t\\t\\t\\\"Order(uint256 nonce,Outline outline,uint256[] extra,bytes data)Outline(uint256 basePrice,uint256 listingTime,uint256 expirationTime,address exchange,address maker,uint8 side,address taker,uint8 saleKind,address target,uint8 callType,address paymentToken)\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA struct for supporting internal Order details in order to avoidd \\r\\n\\t\\tstack-depth issues.\\r\\n\\r\\n\\t\\t@param basePrice The base price of the order in `paymentToken`. This is the \\r\\n\\t\\t\\tprice of fulfillment for static sale kinds. This is the starting price \\r\\n\\t\\t\\tfor `DecreasingPrice` sale kinds.\\r\\n\\t\\t@param listingTime The listing time of the order.\\r\\n\\t\\t@param expirationTime The expiration time of the order.\\r\\n\\t\\t@param exchange The address of the exchange contract, intended as a \\r\\n\\t\\t\\tversioning mechanism if the exchange is upgraded.\\r\\n\\t\\t@param maker The address of the order maker.\\r\\n\\t\\t@param side The sale side of the deal (Buy or Sell). This is a handy flag \\r\\n\\t\\t\\tfor determining which delegate proxy to use depending for participants on \\r\\n\\t\\t\\tdifferent ends of the order.\\r\\n\\t\\t@param taker The order taker address if one is specified. This \\r\\n\\t\\t\\tspepcification is only honored in `DirectListing` and `DirectOffer` sale \\r\\n\\t\\t\\tkinds; in other cases we write dynamic addresses.\\r\\n\\t\\t@param saleKind The kind of sale to fulfill in this order.\\r\\n\\t\\t@param target The target of the order. This should be the address of an \\r\\n\\t\\t\\titem collection to perform a transfer on.\\r\\n\\t\\t@param callType The type of proxy call to perform in fulfilling this order.\\r\\n\\t\\t@param paymentToken The address of an ERC-20 token used to pay for the \\r\\n\\t\\t\\torder, or the zero address to fulfill payment with Ether.\\r\\n\\t*/\\r\\n\\tstruct Outline {\\r\\n\\t\\tuint256 basePrice;\\r\\n\\t\\tuint256 listingTime;\\r\\n\\t\\tuint256 expirationTime;\\r\\n\\t\\taddress exchange;\\r\\n\\t\\taddress maker;\\r\\n\\t\\tSales.Side side;\\r\\n\\t\\taddress taker;\\r\\n\\t\\tSales.SaleKind saleKind;\\r\\n\\t\\taddress target;\\r\\n\\t\\tAuthenticatedProxy.CallType callType;\\r\\n\\t\\taddress paymentToken;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA struct for managing an order on the exchange.\\r\\n\\r\\n\\t\\t@param nonce The order nonce used to prevent duplicate order hashes.\\r\\n\\t\\t@param outline A struct of internal order details.\\r\\n\\t\\t@param extra An array of extra order information. The first element of this \\r\\n\\t\\t\\tarray should be the index for on-chain royalties of the collection \\r\\n\\t\\t\\tinvolved in the order. In the event of a `DecreasingPrice` sale kind, the \\r\\n\\t\\t\\tsecond element should be the targeted floor price of the listing and the \\r\\n\\t\\t\\tthird element should be the time at which the floor price is reached.\\r\\n\\t\\t@param data The call data of the order.\\r\\n\\t*/\\r\\n\\tstruct Order {\\r\\n\\t\\tuint256 nonce;\\r\\n\\t\\tOutline outline;\\r\\n\\t\\tuint256[] extra;\\r\\n\\t\\tbytes data;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA struct for an ECDSA signature.\\r\\n\\r\\n\\t\\t@param v The v component of the signature.\\r\\n\\t\\t@param r The r component of the signature.\\r\\n\\t\\t@param s The s component of the signature.\\r\\n\\t*/\\r\\n\\tstruct Sig {\\r\\n\\t\\tuint8 v;\\r\\n\\t\\tbytes32 r;\\r\\n\\t\\tbytes32 s;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA helper function to hash the outline of an `Order`.\\r\\n\\r\\n\\t\\t@param _outline The outline of an `Order` to hash.\\r\\n\\r\\n\\t\\t@return _ A hash of the order outline.\\r\\n\\t*/\\r\\n\\tfunction _hash (\\r\\n\\t\\tOutline memory _outline\\r\\n\\t) private pure returns (bytes32) {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\tOUTLINE_TYPEHASH,\\r\\n\\t\\t\\t\\t_outline.basePrice,\\r\\n\\t\\t\\t\\t_outline.listingTime,\\r\\n\\t\\t\\t\\t_outline.expirationTime,\\r\\n\\t\\t\\t\\t_outline.exchange,\\r\\n\\t\\t\\t\\t_outline.maker,\\r\\n\\t\\t\\t\\t_outline.side,\\r\\n\\t\\t\\t\\t_outline.taker,\\r\\n\\t\\t\\t\\t_outline.saleKind,\\r\\n\\t\\t\\t\\t_outline.target,\\r\\n\\t\\t\\t\\t_outline.callType,\\r\\n\\t\\t\\t\\t_outline.paymentToken\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tHash an order and return the canonical order hash without a message prefix.\\r\\n\\r\\n\\t\\t@param _order The `Order` to hash.\\r\\n\\r\\n\\t\\t@return _ The hash of `_order`.\\r\\n\\t*/\\r\\n\\tfunction hash (\\r\\n\\t\\tOrder memory _order\\r\\n\\t) internal pure returns (bytes32) {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\tORDER_TYPEHASH,\\r\\n\\t\\t\\t\\t_order.nonce,\\r\\n\\t\\t\\t\\t_hash(_order.outline),\\r\\n\\t\\t\\t\\tkeccak256(abi.encodePacked(_order.extra)),\\r\\n\\t\\t\\t\\tkeccak256(_order.data)\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tValidate the selector of the call data of the provided `Order` `_order`. \\r\\n\\t\\tThis prevents callers from executing arbitrary functions; only attempted \\r\\n\\t\\ttransfers. The transfers may still be arbitrary and malicious, however.\\r\\n\\r\\n\\t\\t@param _order The `Order` to validate the call data selector for.\\r\\n\\r\\n\\t\\t@return _ Whether or not the call has been validated.\\r\\n\\t*/\\r\\n\\tfunction validateCall (\\r\\n\\t\\tOrder memory _order\\r\\n\\t) internal pure returns (bool) {\\r\\n\\t\\tbytes memory data = _order.data;\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tRetrieve the selector and verify that it matches either of the ERC-721 or \\r\\n\\t\\t\\tERC-1155 transfer functions.\\r\\n\\t\\t*/\\r\\n\\t\\tbytes4 selector;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tselector := mload(add(data, 0x20))\\r\\n\\t\\t}\\r\\n\\t\\treturn\\r\\n\\t\\t\\tselector == _ERC1155_TRANSFER_SELECTOR ||\\r\\n\\t\\t\\tselector == _ERC721_TRANSFER_SELECTOR;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tPopulate the call data of the provided `Order` `_order` with the `_taker` \\r\\n\\t\\taddress and item `_tokenId` based on the kind of sale specified in the \\r\\n\\t\\t`_order`.\\r\\n\\r\\n\\t\\tThis function uses assembly to directly manipulate the order data. The \\r\\n\\t\\toffsets are determined based on the length of the order data array and the \\r\\n\\t\\tlocation of the call parameter being inserted.\\r\\n\\r\\n\\t\\tIn both the ERC-721 `transferFrom` function and the ERC-1155 \\r\\n\\t\\t`safeTransferFrom` functions, the `_from` address is the first parameter, \\r\\n\\t\\tthe `_to` address is the second parameter and the `_tokenId` is the third \\r\\n\\t\\tparameter.\\r\\n\\r\\n\\t\\tThe length of the order data is always 0x20 and the function selector is \\r\\n\\t\\t0x04. Therefore the first parameter begins at 0x24. The second parameter \\r\\n\\t\\tlands at 0x44, and the third parameter lands at 0x64. Depending on the sale \\r\\n\\t\\tkind of the order, this function inserts any required dynamic information \\r\\n\\t\\tinto the order data.\\r\\n\\r\\n\\t\\t@param _order The `Order` to populate call data for based on its sale kind.\\r\\n\\t\\t@param _taker The address of the caller who fulfills the order.\\r\\n\\t\\t@param _tokenId The token ID of the item involved in the `_order`.\\r\\n\\r\\n\\t\\t@param data The order call data with the new fields inserted as needed.\\r\\n\\t*/\\r\\n\\tfunction generateCall (\\r\\n\\t\\tOrder memory _order,\\r\\n\\t\\taddress _taker,\\r\\n\\t\\tuint256 _tokenId\\r\\n\\t) internal pure returns (bytes memory data) {\\r\\n\\r\\n\\t\\tdata = _order.data;\\r\\n\\t\\tuint8 saleKind = uint8(_order.outline.saleKind);\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tswitch saleKind\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIn a `FixedPrice` order, insert the `taker` address as the `_to` \\r\\n\\t\\t\\t\\tparameter in the transfer call.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\tmstore(add(data, 0x44), _taker)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIn a `DecreasingPrice` order, insert the `taker` address as the `_to` \\r\\n\\t\\t\\t\\tparameter in the transfer call.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tcase 1 {\\r\\n\\t\\t\\t\\tmstore(add(data, 0x44), _taker)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIn an `Offer` order, insert the `taker` address as the `_from` \\r\\n\\t\\t\\t\\tparameter in the transfer call.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tcase 4 {\\r\\n\\t\\t\\t\\tmstore(add(data, 0x24), _taker)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIn a `CollectionOffer` order, insert the `taker` address as the \\r\\n\\t\\t\\t\\t`_from` parameter and the `_tokenId` as the `_tokenId` parameter in the \\r\\n\\t\\t\\t\\ttransfer call.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tcase 5 {\\r\\n\\t\\t\\t\\tmstore(add(data, 0x24), _taker)\\r\\n\\t\\t\\t\\tmstore(add(data, 0x64), _tokenId)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIn the `DirectListing` and `DirectOffer` sale kinds, all elements of \\r\\n\\t\\t\\t\\tthe order are fully specified and no generation occurs.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/core/RoyaltyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport {\\r\\n\\tBaseFeeManager\\r\\n} from \\\"./BaseFeeManager.sol\\\";\\r\\nimport {\\r\\n\\tEIP712\\r\\n} from \\\"../libraries/EIP712.sol\\\";\\r\\n\\r\\n/// Thrown if attempting to set the validator address to zero.\\r\\nerror ValidatorAddressCannotBeZero ();\\r\\n\\r\\n/// Thrown if the signature provided by the validator is expired.\\r\\nerror SignatureExpired ();\\r\\n\\r\\n/// Thrown if the signature provided by the validator is invalid.\\r\\nerror BadSignature ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title GigaMart Royalty Manager\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA contract for providing an EIP-712 signature-based approach for on-chain \\r\\n\\tdirect royalty payments with royalty management as gated by an off-chain \\r\\n\\tvalidator.\\r\\n\\r\\n\\tThis approach to royalty management is a point of centralization on GigaMart. \\r\\n\\tThe validator key gives its controller the ability to arbitrarily change \\r\\n\\tcollection royalty fees.\\r\\n\\r\\n\\tThis approach is justified based on the fact that it allows GigaMart to offer \\r\\n\\ta gas-optimized middle ground where royalty fees are paid out directly to \\r\\n\\tcollection owners while still allowing an arbitrary number of collection \\r\\n\\tadministrators to manage collection royalty fees based on off-chain role \\r\\n\\tmanagement semantics.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nabstract contract RoyaltyManager is EIP712, BaseFeeManager {\\r\\n\\r\\n\\t/// The public identifier for the right to change the validator address.\\r\\n\\tbytes32 public constant VALIDATOR_SETTER = keccak256(\\\"VALIDATOR_SETTER\\\");\\r\\n\\r\\n\\t/// The EIP-712 typehash of a royalty update.\\r\\n\\tbytes32 public constant ROYALTY_TYPEHASH =\\r\\n\\t\\tkeccak256(\\r\\n\\t\\t\\t\\\"Royalty(address setter,address collection,uint256 deadline,uint256 newRoyalties)\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t/// The address of the off-chain validator.\\r\\n\\taddress internal validator;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA double mapping of collection address to index to royalty percent. This \\r\\n\\t\\tallows makers to securely sign their orders safe in the knowledge that \\r\\n\\t\\troyalty fees cannot be altered from beneath them.\\r\\n\\t*/\\r\\n\\tmapping ( address => mapping ( uint256 => uint256 )) public royalties;\\r\\n\\t\\r\\n\\t/// A mapping of collection addresses to the current royalty index.\\r\\n\\tmapping ( address => uint256 ) public indices;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEmitted after altering the royalty fee of a collection.\\r\\n\\r\\n\\t\\t@param setter The address which altered the royalty fee.\\r\\n\\t\\t@param collection The collection which had its royalty fee altered.\\r\\n\\t\\t@param oldRoyalties The old royalty fee of the collection.\\r\\n\\t\\t@param newRoyalties The new royalty fee of the collection.\\r\\n\\t*/\\r\\n\\tevent RoyaltyChanged (\\r\\n\\t\\taddress indexed setter,\\r\\n\\t\\taddress indexed collection,\\r\\n\\t\\tuint256 oldRoyalties,\\r\\n\\t\\tuint256 newRoyalties\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new instance of the GigaMart royalty fee manager.\\r\\n\\r\\n\\t\\t@param _validator The address to use as the royalty change validation \\r\\n\\t\\t\\tsigner.\\r\\n\\t\\t@param _protocolFeeRecipient The address which receives protocol fees.\\r\\n\\t\\t@param _protocolFeePercent The percent in basis points of the protocol fee.\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\taddress _validator,\\r\\n\\t\\taddress _protocolFeeRecipient,\\r\\n\\t\\tuint96 _protocolFeePercent\\r\\n\\t) BaseFeeManager(_protocolFeeRecipient, _protocolFeePercent) {\\r\\n\\t\\tvalidator = _validator;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns the current royalty fees of a collection.\\r\\n\\r\\n\\t\\t@param _collection The collection to return the royalty fees for.\\r\\n\\r\\n\\t\\t@return _ A tuple pairing the address of a collection fee recipient with \\r\\n\\t\\t\\tthe actual royalty fee.\\r\\n\\t*/\\r\\n\\tfunction currentRoyalties (\\r\\n\\t\\taddress _collection\\r\\n\\t) external view returns (address, uint256) {\\r\\n\\t\\tuint256 fee = royalties[_collection][indices[_collection]];\\r\\n\\r\\n\\t\\t// The fee is a packed address-fee pair into a single 256 bit integer.\\r\\n\\t\\treturn (address(uint160(fee >> 96)), uint256(uint96(fee)));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tChange the `validator` address.\\r\\n\\r\\n\\t\\t@param _validator The new `validator` address to set.\\r\\n\\r\\n\\t\\t@custom:throws ValidatorAddressCannotBeZero if attempting to set the \\r\\n\\t\\t\\t`validator` address to the zero address.\\r\\n\\t*/\\r\\n\\tfunction changeValidator (\\r\\n\\t\\taddress _validator\\r\\n\\t) external hasValidPermit(UNIVERSAL, VALIDATOR_SETTER) {\\r\\n\\t\\tif (_validator == address(0)) {\\r\\n\\t\\t\\trevert ValidatorAddressCannotBeZero();\\r\\n\\t\\t}\\r\\n\\t\\tvalidator = _validator;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tGenerate a hash from the royalty changing parameters.\\r\\n\\t\\t\\r\\n\\t\\t@param _setter The caller setting the royalty changes.\\r\\n\\t\\t@param _collection The address of the collection for which royalties will \\r\\n\\t\\t\\tbe altered.\\r\\n\\t\\t@param _deadline The time when the `_setter` loses the right to alter \\r\\n\\t\\t\\troyalties.\\r\\n\\t\\t@param _newRoyalties The new royalty information to set.\\r\\n\\r\\n\\t\\t@return _ The hash of the royalty parameters for checking signature \\r\\n\\t\\t\\tvalidation.\\r\\n\\t*/\\r\\n\\tfunction _hash (\\r\\n\\t\\taddress _setter,\\r\\n\\t\\taddress _collection,\\r\\n\\t\\tuint256 _deadline,\\r\\n\\t\\tuint256 _newRoyalties\\r\\n\\t) internal view returns (bytes32) {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t\\tabi.encodePacked(\\r\\n\\t\\t\\t\\t\\\"\\\\x19\\\\x01\\\",\\r\\n\\t\\t\\t\\t_deriveDomainSeparator(),\\r\\n\\t\\t\\t\\tkeccak256(\\r\\n\\t\\t\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\t\\t\\tROYALTY_TYPEHASH,\\r\\n\\t\\t\\t\\t\\t\\t_setter,\\r\\n\\t\\t\\t\\t\\t\\t_collection,\\r\\n\\t\\t\\t\\t\\t\\t_deadline,\\r\\n\\t\\t\\t\\t\\t\\t_newRoyalties\\r\\n\\t\\t\\t\\t\\t)\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tUpdate the royalty mapping for a collection with a new royalty.\\r\\n\\r\\n\\t\\t@param _collection The address of the collection for which `_newRoyalties` \\r\\n\\t\\t\\tare set.\\r\\n\\t\\t@param _deadline The time until which the `_signature` is valid.\\r\\n\\t\\t@param _newRoyalties The updated royalties to set.\\r\\n\\t\\t@param _signature A signature signed by the `validator`.\\r\\n\\r\\n\\t\\t@custom:throws BadSignature if the signature submitted for setting \\r\\n\\t\\t\\troyalties is invalid.\\r\\n\\t\\t@custom:throws SignatureExpired if the signature is expired.\\r\\n\\t*/\\r\\n\\tfunction setRoyalties (\\r\\n\\t\\taddress _collection,\\r\\n\\t\\tuint256 _deadline,\\r\\n\\t\\tuint256 _newRoyalties,\\r\\n\\t\\tbytes calldata _signature\\r\\n\\t) external {\\r\\n\\r\\n\\t\\t// Verify that the signature was signed by the royalty validator.\\r\\n\\t\\tif (\\r\\n\\t\\t\\t_recover(\\r\\n\\t\\t\\t\\t_hash(msg.sender, _collection, _deadline, _newRoyalties),\\r\\n\\t\\t\\t\\t_signature\\r\\n\\t\\t\\t) != validator\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert BadSignature();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Verify that the signature has not expired.\\r\\n\\t\\tif (_deadline < block.timestamp) {\\r\\n\\t\\t\\trevert SignatureExpired();\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t/*\\r\\n\\t\\t\\tIncrement the current royalty index for the collection and update its \\r\\n\\t\\t\\troyalty information.\\r\\n\\t\\t*/\\r\\n\\t\\tuint256 oldRoyalties = royalties[_collection][indices[_collection]];\\r\\n\\t\\tindices[_collection]++;\\r\\n\\t\\troyalties[_collection][indices[_collection]] = _newRoyalties;\\r\\n\\r\\n\\t\\t// Emit an event notifying about the royalty change.\\r\\n\\t\\temit RoyaltyChanged(msg.sender, _collection, oldRoyalties, _newRoyalties);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/libraries/NativeTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\n/// Emitted in the event that transfer of Ether fails.\\r\\nerror TransferFailed ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Native Ether Transfer Library\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA library for safely conducting Ether transfers and verifying success.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nlibrary NativeTransfer {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA helper function for wrapping a low-level Ether transfer call with modern \\r\\n\\t\\terror reversion.\\r\\n\\r\\n\\t\\t@param _to The address to send Ether to.\\r\\n\\t\\t@param _value The value of Ether to send to `_to`.\\r\\n\\r\\n\\t\\t@custom:throws TransferFailed if the transfer of Ether fails.\\r\\n\\t*/\\r\\n\\tfunction transferEth (\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint _value\\r\\n\\t) internal {\\r\\n\\t\\t(bool success, ) = _to.call{ value: _value }(\\\"\\\");\\r\\n\\t\\tif (!success) {\\r\\n\\t\\t\\trevert TransferFailed();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/proxy/OwnableDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"./DelegateProxy.sol\\\";\\r\\n\\r\\n/// Thrown if the initial delgate call from this proxy is not successful.\\r\\nerror InitialTargetCallFailed ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Ownable Delegate Proxy\\r\\n\\t@author Protinam, Project Wyvern\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\r\\n\\tA call-delegating proxy with an owner. This contract was originally developed \\r\\n\\tby Project Wyvern. It has been modified to support a more modern version of \\r\\n\\tSolidity with associated best practices. The documentation has also been \\r\\n\\timproved to provide more clarity.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\ncontract OwnableDelegateProxy is Ownable, DelegateProxy {\\r\\n\\r\\n\\t/// Whether or not the proxy was initialized.\\r\\n\\tbool public initialized;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tThis is a storage escape slot to match `AuthenticatedProxy` storage.\\r\\n\\t\\tuint8(bool) + uint184 = 192 bits. This prevents target (160 bits) from\\r\\n\\t\\tbeing placed in this storage slot.\\r\\n\\t*/\\r\\n\\tuint184 private _escape;\\r\\n\\r\\n\\t/// The address of the proxy's current target.\\r\\n\\taddress public target;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct this delegate proxy with an owner, initial target, and an initial\\r\\n\\t\\tcall sent to the target.\\r\\n\\r\\n\\t\\t@param _owner The address which should own this proxy.\\r\\n\\t\\t@param _target The initial target of this proxy.\\r\\n\\t\\t@param _data The initial call to delegate to `_target`.\\r\\n\\r\\n\\t\\t@custom:throws InitialTargetCallFailed if the proxy initialization call \\r\\n\\t\\t\\tfails.\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\taddress _owner,\\r\\n\\t\\taddress _target,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) {\\r\\n\\t\\r\\n\\t\\t/*\\r\\n\\t\\t\\tDo not perform a redundant ownership transfer if the deployer should remain as the owner of this contract.\\r\\n\\t\\t*/\\r\\n\\t\\tif (_owner != owner()) {\\r\\n\\t\\t\\ttransferOwnership(_owner);\\r\\n\\t\\t}\\r\\n\\t\\ttarget = _target;\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t\\tImmediately delegate a call to the initial implementation and require it \\r\\n\\t\\t\\tto succeed. This is often used to trigger some kind of initialization \\r\\n\\t\\t\\tfunction on the target.\\r\\n\\t\\t*/\\r\\n\\t\\t(bool success, ) = _target.delegatecall(_data);\\r\\n\\t\\tif (!success) {\\r\\n\\t\\t\\trevert InitialTargetCallFailed();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturn the current address where all calls to this proxy are delegated. If\\r\\n\\t\\t`proxyType()` returns `1`, ERC-897 dictates that this address MUST not\\r\\n\\t\\tchange.\\r\\n\\r\\n\\t\\t@return _ The current address where calls to this proxy are delegated.\\r\\n\\t*/\\r\\n\\tfunction implementation () public view override returns (address) {\\r\\n\\t\\treturn target;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/proxy/TokenTransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IProxyRegistry.sol\\\";\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Token Transfer Proxy\\r\\n\\t@author Project Wyvern Developers\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\t@custom:contributor Rostislav Khlebnikov <@catpic5buck>\\r\\n\\r\\n\\tA token transfer proxy contract. This contract was originally developed by \\r\\n\\tProject Wyvern. It has been modified to support a more modern version of \\r\\n\\tSolidity with associated best practices. The documentation has also been \\r\\n\\timproved to provide more clarity.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\ncontract TokenTransferProxy {\\r\\n\\tusing SafeERC20 for IERC20;\\r\\n\\r\\n\\t/// The address of the immutable authentication registry.\\r\\n\\tIProxyRegistry public immutable registry;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new instance of this token transfer proxy given the associated \\r\\n\\t\\tregistry.\\r\\n\\r\\n\\t\\t@param _registry The address of a proxy registry.\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\taddress _registry\\r\\n\\t) {\\r\\n\\t\\tregistry = IProxyRegistry(_registry);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tPerform a transfer on a targeted ERC-20 token, rejecting unauthorized callers.\\r\\n\\r\\n\\t\\t@param _token The address of the ERC-20 token to transfer.\\r\\n\\t\\t@param _from The address to transfer ERC-20 tokens from.\\r\\n\\t\\t@param _to The address to transfer ERC-20 tokens to.\\r\\n\\t\\t@param _amount The amount of ERC-20 tokens to transfer.\\r\\n\\r\\n\\t\\t@custom:throws NonAuthorizedCaller if the caller is not authorized to \\r\\n\\t\\t\\tperform the ERC-20 token transfer.\\r\\n\\t*/\\r\\n\\tfunction transferERC20 (\\r\\n\\t\\taddress _token,\\r\\n\\t\\taddress _from,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint _amount\\r\\n\\t) public {\\r\\n\\t\\tif (!registry.authorizedCallers(msg.sender)) {\\r\\n\\t\\t\\trevert NonAuthorizedCaller();\\r\\n\\t\\t}\\r\\n\\t\\tIERC20(_token).safeTransferFrom(_from, _to, _amount);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/libraries/Sales.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Sales Library\\r\\n\\t@author Project Wyvern Developers\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA library for managing supported sale types and sale helper functions.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nlibrary Sales {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn enum to track the possible sides of an order to be fulfilled.\\r\\n\\r\\n\\t\\t@param Buy A buy order is one in which an offer was made to buy an item.\\r\\n\\t\\t@param Sell A sell order is one in which a listing was made to sell an item.\\r\\n\\t*/\\r\\n\\tenum Side {\\r\\n\\t\\tBuy,\\r\\n\\t\\tSell\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn enum to track the different types of order that can be fulfilled.\\r\\n\\r\\n\\t\\t@param FixedPrice A listing of an item for sale by a seller at a static \\r\\n\\t\\t\\tprice.\\r\\n\\t\\t@param DecreasingPrice A listing of an item for sale by a seller at a price \\r\\n\\t\\t\\tthat decreases linearly each second based on extra fields specified in an \\r\\n\\t\\t\\torder.\\r\\n\\t\\t@param DirectListing A listing of an item for sale by a seller at a static \\r\\n\\t\\t\\tprice fulfillable only by a single buyer specified by the seller.\\r\\n\\t\\t@param DirectOffer An offer with a static price made by a buyer for an item \\r\\n\\t\\t\\towned by a specific seller.\\r\\n\\t\\t@param Offer An offer with a static price made by a buyer for an item. The \\r\\n\\t\\t\\toffer is valid no matter who the holder of the item is.\\r\\n\\t\\t@param CollectionOffer An offer with a static price made by a buyer for any \\r\\n\\t\\t\\titem in a collection. Any item holder in the collection may fulfill the \\r\\n\\t\\t\\toffer.\\r\\n\\t*/\\r\\n\\tenum SaleKind {\\r\\n\\t\\tFixedPrice,\\r\\n\\t\\tDecreasingPrice,\\r\\n\\t\\tDirectListing,\\r\\n\\t\\tDirectOffer,\\r\\n\\t\\tOffer,\\r\\n\\t\\tCollectionOffer\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturn whether or not an order can be settled, verifying that the current\\r\\n\\t\\tblock time is between order's initial listing and expiration time.\\r\\n\\r\\n\\t\\t@param _listingTime The starting time of the order being listed.\\r\\n\\t\\t@param _expirationTime The ending time where the order expires.\\r\\n\\t*/\\r\\n\\tfunction _canSettleOrder (\\r\\n\\t\\tuint _listingTime,\\r\\n\\t\\tuint _expirationTime\\r\\n\\t) internal view returns (bool) {\\r\\n\\t\\treturn\\r\\n\\t\\t\\t(_listingTime < block.timestamp) &&\\r\\n\\t\\t\\t(_expirationTime == 0 || block.timestamp < _expirationTime);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tCalculate the final settlement price of an order.\\r\\n\\r\\n\\t\\t@param _saleKind The sale kind of an order.\\r\\n\\t\\t@param _basePrice The base price of the order.\\r\\n\\t\\t@param _extra Any extra price or time data for the order; for\\r\\n\\t\\t\\tdecreasing-price orders, `_extra[1]` is the floor price where price decay\\r\\n\\t\\t\\tstops and `_extra[2]` is the timestamp at which the floor price is\\r\\n\\t\\t\\treached.\\r\\n\\t\\t@param _listingTime The listing time of the order.\\r\\n\\r\\n\\t\\t@return _ The final price of fulfilling an order.\\r\\n\\t*/\\r\\n\\tfunction _calculateFinalPrice (\\r\\n\\t\\tSaleKind _saleKind,\\r\\n\\t\\tuint _basePrice,\\r\\n\\t\\tuint[] memory _extra,\\r\\n\\t\\tuint _listingTime\\r\\n\\t) internal view returns (uint) {\\r\\n\\r\\n\\t\\t/*\\r\\n\\t\\t\\tIf the sale type is a decreasing-price Dutch auction, then the price\\r\\n\\t\\t\\tdecreases each minute across its configured price range.\\r\\n\\t\\t*/\\r\\n\\t\\tif (_saleKind == SaleKind.DecreasingPrice) {\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tIf the timestamp at which price decrease concludes has been exceeded,\\r\\n\\t\\t\\t\\tthe item listing price maintains its configured floor price.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tif (block.timestamp >= _extra[2]) {\\r\\n\\t\\t\\t\\treturn _extra[1];\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t\\tCalculate the portion of the decreasing total price that has not yet\\r\\n\\t\\t\\t\\tdecayed.\\r\\n\\t\\t\\t*/\\r\\n\\t\\t\\tuint undecayed =\\r\\n\\r\\n\\t\\t\\t\\t// The total decayable portion of the price.\\r\\n\\t\\t\\t\\t(_basePrice - _extra[1]) *\\r\\n\\r\\n\\t\\t\\t\\t// The duration in seconds of the time remaining until total decay.\\r\\n\\t\\t\\t\\t(_extra[2] - block.timestamp) /\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\tThe duration in seconds between the order listing time and the time\\r\\n\\t\\t\\t\\t\\tof total decay.\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\t(_extra[2] - _listingTime);\\r\\n\\r\\n\\t\\t\\t// Return the current price as the floor price plus the undecayed portion.\\r\\n\\t\\t\\treturn _extra[1] + undecayed;\\r\\n\\r\\n\\t\\t// In all other types of order sale, the price is entirely static.\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn _basePrice;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/proxy/AuthenticatedProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IProxyRegistry.sol\\\";\\r\\n\\r\\n/**\\r\\n\\tThrown if attempting to initialize a proxy which has already been initialized.\\r\\n*/\\r\\nerror ProxyAlreadyInitialized ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Authenticated Proxy\\r\\n\\t@author Protinam, Project Wyvern\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\t@custom:contributor Rostislav Khlebnikov <@catpic5buck>\\r\\n\\r\\n\\tAn ownable call-delegating proxy which can receive tokens and only make calls \\r\\n\\tagainst contracts that have been approved by a `ProxyRegistry`. This contract \\r\\n\\twas originally developed by Project Wyvern. It has been modified to support a \\r\\n\\tmore modern version of Solidity with associated best practices. The \\r\\n\\tdocumentation has also been improved to provide more clarity.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\ncontract AuthenticatedProxy is Ownable {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn enum for selecting the method by which we would like to perform a call \\r\\n\\t\\tin the `proxy` function.\\r\\n\\t*/\\r\\n\\tenum CallType {\\r\\n\\t\\tCall,\\r\\n\\t\\tDelegateCall\\r\\n\\t}\\r\\n\\r\\n\\t/// Whether or not this proxy is initialized. It may only initialize once.\\r\\n\\tbool public initialized = false;\\r\\n\\r\\n\\t/// The associated `ProxyRegistry` contract with authentication information.\\r\\n\\taddress public registry;\\r\\n\\r\\n\\t/// Whether or not access has been revoked.\\r\\n\\tbool public revoked;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn event fired when the proxy contract's access is revoked or unrevoked.\\r\\n\\r\\n\\t\\t@param revoked The status of the revocation call; true if access is \\r\\n\\t\\t\\trevoked and false if access is unrevoked.\\r\\n\\t*/\\r\\n\\tevent Revoked (\\r\\n\\t\\tbool revoked\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tInitialize this authenticated proxy for its owner against a specified\\r\\n\\t\\t`ProxyRegistry`. The registry controls the eligible targets.\\r\\n\\r\\n\\t\\t@param _registry The registry to create this proxy against.\\r\\n\\t*/\\r\\n\\tfunction initialize (\\r\\n\\t\\taddress _registry\\r\\n\\t) external {\\r\\n\\t\\tif (initialized) {\\r\\n\\t\\t\\trevert ProxyAlreadyInitialized();\\r\\n\\t\\t}\\r\\n\\t\\tinitialized = true;\\r\\n\\t\\tregistry = _registry;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAllow the owner of this proxy to set the revocation flag. This permits them\\r\\n\\t\\tto revoke access from the associated `ProxyRegistry` if needed.\\r\\n\\r\\n\\t\\t@param _revoke The revocation flag to set for this proxy.\\r\\n\\t*/\\r\\n\\tfunction setRevoke (\\r\\n\\t\\tbool _revoke\\r\\n\\t) external onlyOwner {\\r\\n\\t\\trevoked = _revoke;\\r\\n\\t\\temit Revoked(_revoke);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tTrigger this proxy to call a specific address with the provided data. The\\r\\n\\t\\tproxy may perform a direct or a delegate call. This proxy can only be called\\r\\n\\t\\tby the owner, or on behalf of the owner by a caller authorized by the\\r\\n\\t\\tregistry. Unless the user has revoked access to the registry, that is.\\r\\n\\r\\n\\t\\t@param _target The target address to make the call to.\\r\\n\\t\\t@param _type The type of call to make: direct or delegated.\\r\\n\\t\\t@param _data The call data to send to `_target`.\\r\\n\\r\\n\\t\\t@return _ Whether or not the call succeeded.\\r\\n\\r\\n\\t\\t@custom:throws NonAuthorizedCaller if the proxy caller is not the owner or \\r\\n\\t\\t\\tan authorized caller from the proxy registry.\\r\\n\\t*/\\r\\n\\tfunction call (\\r\\n\\t\\taddress _target,\\r\\n\\t\\tCallType _type,\\r\\n\\t\\tbytes calldata _data\\r\\n\\t) public returns (bool) {\\r\\n\\t\\tif (\\r\\n\\t\\t\\t_msgSender() != owner() &&\\r\\n\\t\\t\\t(revoked || !IProxyRegistry(registry).authorizedCallers(_msgSender()))\\r\\n\\t\\t) {\\r\\n\\t\\t\\trevert NonAuthorizedCaller();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// The call is authorized to be performed, now select a type and return.\\r\\n\\t\\tif (_type == CallType.Call) {\\r\\n\\t\\t\\t(bool success, ) = _target.call(_data);\\r\\n\\t\\t\\treturn success;\\r\\n\\t\\t} else if (_type == CallType.DelegateCall) {\\r\\n\\t\\t\\t(bool success, ) = _target.delegatecall(_data);\\r\\n\\t\\t\\treturn success;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/interfaces/IProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\n/// Thrown if a caller is not authorized in the proxy registry.\\r\\nerror NonAuthorizedCaller ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Ownable Delegate Proxy\\r\\n\\t@author Protinam, Project Wyvern\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\r\\n\\tA proxy registry contract. This contract was originally developed \\r\\n\\tby Project Wyvern. It has been modified to support a more modern version of \\r\\n\\tSolidity with associated best practices. The documentation has also been \\r\\n\\timproved to provide more clarity.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\ninterface IProxyRegistry {\\r\\n\\r\\n\\t/// Return the address of tje current valid implementation of delegate proxy.\\r\\n\\tfunction delegateProxyImplementation () external view returns (address);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns the address of a proxy which was registered for the user address \\r\\n\\t\\tbefore listing items.\\r\\n\\r\\n\\t\\t@param _owner The address of items lister.\\r\\n\\t*/\\r\\n\\tfunction proxies (\\r\\n\\t\\taddress _owner\\r\\n\\t) external view returns (address);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns true if the `_caller` to the proxy registry is eligible and \\r\\n\\t\\tregistered.\\r\\n\\r\\n\\t\\t@param _caller The address of the caller.\\r\\n\\t*/\\r\\n\\tfunction authorizedCallers (\\r\\n\\t\\taddress _caller\\r\\n\\t) external view returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns the address of the `_caller`'s proxy and current implementation \\r\\n\\t\\taddress.\\r\\n\\r\\n\\t\\t@param _caller The address of the caller.\\r\\n\\t*/\\r\\n\\tfunction userProxyConfig (\\r\\n\\t\\taddress _caller\\r\\n\\t) external view returns (address, address);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEnables an address to register its own proxy contract with this registry.\\r\\n\\r\\n\\t\\t@return _ The new contract with its implementation.\\r\\n\\t*/\\r\\n\\tfunction registerProxy () external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/core/BaseFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport {\\r\\n\\tPermitControl\\r\\n} from \\\"../../access/PermitControl.sol\\\";\\r\\n\\r\\n/// Thrown if attempting to set the protocol fee to zero.\\r\\nerror ProtocolFeeRecipientCannotBeZero();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title GigaMart Base Fee Manager\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA contract for providing platform fee management capabilities to GigaMart.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nabstract contract BaseFeeManager is PermitControl {\\r\\n\\r\\n\\t/// The public identifier for the right to update the fee configuration.\\r\\n\\tbytes32 public constant FEE_CONFIG = keccak256(\\\"FEE_CONFIG\\\");\\r\\n\\r\\n\\t/**\\r\\n\\t\\tIn protocol fee configuration the recipient address takes the left 160 bits \\r\\n\\t\\tand the fee percentage takes the right 96 bits.\\r\\n\\t*/\\r\\n\\tuint256 internal _protocolFee;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tEmmited when protocol fee config is altered.\\r\\n\\r\\n\\t\\t@param oldProtocolFeeRecipient The previous recipient address of protocol \\r\\n\\t\\t\\tfees.\\r\\n\\t\\t@param newProtocolFeeRecipient The new recipient address of protocol fees.\\r\\n\\t\\t@param oldProtocolFeePercent The previous amount of protocol fees.\\r\\n\\t\\t@param newProtocolFeePercent The new amount of protocol fees. \\r\\n\\t*/\\r\\n\\tevent ProtocolFeeChanged (\\r\\n\\t\\taddress oldProtocolFeeRecipient,\\r\\n\\t\\taddress newProtocolFeeRecipient,\\r\\n\\t\\tuint256 oldProtocolFeePercent,\\r\\n\\t\\tuint256 newProtocolFeePercent\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new instance of the GigaMart fee manager.\\r\\n\\r\\n\\t\\t@param _protocolFeeRecipient The address that receives the protocol fee.\\r\\n\\t\\t@param _protocolFeePercent The percentage of the protocol fee in basis \\r\\n\\t\\t\\tpoints, i.e. 200 = 2%.\\r\\n\\t*/\\r\\n\\tconstructor (\\r\\n\\t\\taddress _protocolFeeRecipient,\\r\\n\\t\\tuint96 _protocolFeePercent\\r\\n\\t) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t_protocolFee =\\r\\n\\t\\t\\t\\t(uint256(uint160(_protocolFeeRecipient)) << 96) +\\r\\n\\t\\t\\t\\tuint256(_protocolFeePercent);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturns current protocol fee config.\\r\\n\\t*/\\r\\n\\tfunction currentProtocolFee() public view returns (address, uint256) {\\r\\n\\t\\tuint256 fee = _protocolFee;\\r\\n\\t\\treturn (address(uint160(fee >> 96)), uint256(uint96(fee)));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tChanges the the fee details of the protocol.\\r\\n\\r\\n\\t\\t@param _newProtocolFeeRecipient The address of the new protocol fee \\r\\n\\t\\t\\trecipient.\\r\\n\\t\\t@param _newProtocolFeePercent The new amount of the protocol fees in basis \\r\\n\\t\\t\\tpoints, i.e. 200 = 2%.\\r\\n\\r\\n\\t\\t@custom:throws ProtocolFeeRecipientCannotBeZero if attempting to set the \\r\\n\\t\\t\\trecipient of the protocol fees to the zero address.\\r\\n\\t*/\\r\\n\\tfunction changeProtocolFees (\\r\\n\\t\\taddress _newProtocolFeeRecipient,\\r\\n\\t\\tuint256 _newProtocolFeePercent\\r\\n\\t) external hasValidPermit(UNIVERSAL, FEE_CONFIG) {\\r\\n\\t\\tif (_newProtocolFeeRecipient == address(0)) {\\r\\n\\t\\t\\trevert ProtocolFeeRecipientCannotBeZero();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Update the protocol fee.\\r\\n\\t\\tuint256 oldProtocolFee = _protocolFee;\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t_protocolFee =\\r\\n\\t\\t\\t\\t(uint256(uint160(_newProtocolFeeRecipient)) << 96) +\\r\\n\\t\\t\\t\\tuint256(_newProtocolFeePercent);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Emit an event notifying about the update.\\r\\n\\t\\temit ProtocolFeeChanged(\\r\\n\\t\\t\\taddress(uint160(oldProtocolFee >> 96)),\\r\\n\\t\\t\\t_newProtocolFeeRecipient,\\r\\n\\t\\t\\tuint256(uint96(oldProtocolFee)),\\r\\n\\t\\t\\t_newProtocolFeePercent\\r\\n\\t\\t);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/marketplace/libraries/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\n/// Thrown if attempting to recover a signature of invalid length.\\r\\nerror InvalidSignatureLength ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title EIP-712 Domain Manager\\r\\n\\t@author Rostislav Khlebnikov <@catpic5buck>\\r\\n\\t@custom:contributor Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA contract for providing EIP-712 signature-services.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nabstract contract EIP712 {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tThe typehash of the EIP-712 domain, used in dynamically deriving a domain \\r\\n\\t\\tseparator.\\r\\n\\t*/\\r\\n\\tbytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\\r\\n\\t\\t\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\r\\n\\t);\\r\\n\\r\\n\\t/// A name used in the domain separator.\\r\\n\\tstring public constant name = \\\"GigaMart\\\";\\r\\n\\r\\n\\t/// The immutable chain ID detected during construction.\\r\\n\\tuint256 private immutable CHAIN_ID;\\r\\n\\r\\n\\t/// The immutable chain ID created during construction.\\r\\n\\tbytes32 private immutable DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tConstruct a new EIP-712 domain instance.\\r\\n\\t*/\\r\\n\\tconstructor () {\\r\\n\\t\\tuint chainId;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tchainId := chainid()\\r\\n\\t\\t}\\r\\n\\t\\tCHAIN_ID = chainId;\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(\\r\\n\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\t\\tkeccak256(bytes(name)),\\r\\n\\t\\t\\t\\tkeccak256(bytes(version())),\\r\\n\\t\\t\\t\\tchainId,\\r\\n\\t\\t\\t\\taddress(this)\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturn the version of this EIP-712 domain.\\r\\n\\r\\n\\t\\t@return _ The version of this EIP-712 domain.\\r\\n\\t*/\\r\\n\\tfunction version () public pure returns (string memory) {\\r\\n\\t\\treturn \\\"1\\\";\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tDynamically derive an EIP-712 domain separator.\\r\\n\\r\\n\\t\\t@return _ A constructed domain separator.\\r\\n\\t*/\\r\\n\\tfunction _deriveDomainSeparator () internal view returns (bytes32) {\\r\\n\\t\\tuint chainId;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tchainId := chainid()\\r\\n\\t\\t}\\r\\n\\t\\treturn chainId == CHAIN_ID\\r\\n\\t\\t\\t? DOMAIN_SEPARATOR\\r\\n\\t\\t\\t: keccak256(\\r\\n\\t\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\t\\t\\tkeccak256(bytes(name)),\\r\\n\\t\\t\\t\\t\\tkeccak256(bytes(version())),\\r\\n\\t\\t\\t\\t\\tchainId,\\r\\n\\t\\t\\t\\t\\taddress(this)\\r\\n\\t\\t\\t\\t)\\r\\n\\t\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tRecover the address which signed `_hash` with signature `_signature`.\\r\\n\\r\\n\\t\\t@param _hash A hash signed by an address.\\r\\n\\t\\t@param _signature The signature of the hash.\\r\\n\\r\\n\\t\\t@return _ The address which signed `_hash` with signature `_signature.\\r\\n\\r\\n\\t\\t@custom:throws InvalidSignatureLength if the signature length is not valid.\\r\\n\\t*/\\r\\n\\tfunction _recover (\\r\\n\\t\\tbytes32 _hash,\\r\\n\\t\\tbytes memory _signature\\r\\n\\t) internal pure returns (address) {\\r\\n\\r\\n\\t\\t// Validate that the signature length is as expected.\\r\\n\\t\\tif (_signature.length != 65) {\\r\\n\\t\\t\\trevert InvalidSignatureLength();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Divide the signature into r, s and v variables.\\r\\n\\t\\tbytes32 r;\\r\\n\\t\\tbytes32 s;\\r\\n\\t\\tuint8 v;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tr := mload(add(_signature, 0x20))\\r\\n\\t\\t\\ts := mload(add(_signature, 0x40))\\r\\n\\t\\t\\tv := byte(0, mload(add(_signature, 0x60)))\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Return the recovered address.\\r\\n\\t\\treturn ecrecover(_hash, v, r, s);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/access/PermitControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title An advanced permission-management contract.\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tThis contract allows for a contract owner to delegate specific rights to\\r\\n\\texternal addresses. Additionally, these rights can be gated behind certain\\r\\n\\tsets of circumstances and granted expiration times. This is useful for some\\r\\n\\tmore finely-grained access control in contracts.\\r\\n\\r\\n\\tThe owner of this contract is always a fully-permissioned super-administrator.\\r\\n\\r\\n\\t@custom:date August 23rd, 2021.\\r\\n*/\\r\\nabstract contract PermitControl is Ownable {\\r\\n\\tusing Address for address;\\r\\n\\r\\n\\t/// A special reserved constant for representing no rights.\\r\\n\\tbytes32 public constant ZERO_RIGHT = hex\\\"00000000000000000000000000000000\\\";\\r\\n\\r\\n\\t/// A special constant specifying the unique, universal-rights circumstance.\\r\\n\\tbytes32 public constant UNIVERSAL = hex\\\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA special constant specifying the unique manager right. This right allows an\\r\\n\\t\\taddress to freely-manipulate the `managedRight` mapping.\\r\\n\\t*/\\r\\n\\tbytes32 public constant MANAGER = hex\\\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA mapping of per-address permissions to the circumstances, represented as\\r\\n\\t\\tan additional layer of generic bytes32 data, under which the addresses have\\r\\n\\t\\tvarious permits. A permit in this sense is represented by a per-circumstance\\r\\n\\t\\tmapping which couples some right, represented as a generic bytes32, to an\\r\\n\\t\\texpiration time wherein the right may no longer be exercised. An expiration\\r\\n\\t\\ttime of 0 indicates that there is in fact no permit for the specified\\r\\n\\t\\taddress to exercise the specified right under the specified circumstance.\\r\\n\\r\\n\\t\\t@dev Universal rights MUST be stored under the 0xFFFFFFFFFFFFFFFFFFFFFFFF...\\r\\n\\t\\tmax-integer circumstance. Perpetual rights may be given an expiry time of\\r\\n\\t\\tmax-integer.\\r\\n\\t*/\\r\\n\\tmapping ( address => mapping( bytes32 => mapping( bytes32 => uint256 ))) \\r\\n\\t\\tpublic permissions;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn additional mapping of managed rights to manager rights. This mapping\\r\\n\\t\\trepresents the administrator relationship that various rights have with one\\r\\n\\t\\tanother. An address with a manager right may freely set permits for that\\r\\n\\t\\tmanager right's managed rights. Each right may be managed by only one other\\r\\n\\t\\tright.\\r\\n\\t*/\\r\\n\\tmapping ( bytes32 => bytes32 ) public managerRight;\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn event emitted when an address has a permit updated. This event captures,\\r\\n\\t\\tthrough its various parameter combinations, the cases of granting a permit,\\r\\n\\t\\tupdating the expiration time of a permit, or revoking a permit.\\r\\n\\r\\n\\t\\t@param updater The address which has updated the permit.\\r\\n\\t\\t@param updatee The address whose permit was updated.\\r\\n\\t\\t@param circumstance The circumstance wherein the permit was updated.\\r\\n\\t\\t@param role The role which was updated.\\r\\n\\t\\t@param expirationTime The time when the permit expires.\\r\\n\\t*/\\r\\n\\tevent PermitUpdated (\\r\\n\\t\\taddress indexed updater,\\r\\n\\t\\taddress indexed updatee,\\r\\n\\t\\tbytes32 circumstance,\\r\\n\\t\\tbytes32 indexed role,\\r\\n\\t\\tuint256 expirationTime\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tAn event emitted when a management relationship in `managerRight` is\\r\\n\\t\\tupdated. This event captures adding and revoking management permissions via\\r\\n\\t\\tobserving the update history of the `managerRight` value.\\r\\n\\r\\n\\t\\t@param manager The address of the manager performing this update.\\r\\n\\t\\t@param managedRight The right which had its manager updated.\\r\\n\\t\\t@param managerRight The new manager right which was updated to.\\r\\n\\t*/\\r\\n\\tevent ManagementUpdated (\\r\\n\\t\\taddress indexed manager,\\r\\n\\t\\tbytes32 indexed managedRight,\\r\\n\\t\\tbytes32 indexed managerRight\\r\\n\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t\\tA modifier which allows only the super-administrative owner or addresses\\r\\n\\t\\twith a specified valid right to perform a call.\\r\\n\\r\\n\\t\\t@param _circumstance The circumstance under which to check for the validity\\r\\n\\t\\t\\tof the specified `right`.\\r\\n\\t\\t@param _right The right to validate for the calling address. It must be\\r\\n\\t\\t\\tnon-expired and exist within the specified `_circumstance`.\\r\\n\\t*/\\r\\n\\tmodifier hasValidPermit (\\r\\n\\t\\tbytes32 _circumstance,\\r\\n\\t\\tbytes32 _right\\r\\n\\t) {\\r\\n\\t\\trequire(\\r\\n\\t\\t\\t_msgSender() == owner() || hasRight(_msgSender(), _circumstance, _right),\\r\\n\\t\\t\\t\\\"P1\\\"\\r\\n\\t\\t);\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tSet the `_managerRight` whose `UNIVERSAL` holders may freely manage the\\r\\n\\t\\tspecified `_managedRight`.\\r\\n\\r\\n\\t\\t@param _managedRight The right which is to have its manager set to\\r\\n\\t\\t\\t`_managerRight`.\\r\\n\\t\\t@param _managerRight The right whose `UNIVERSAL` holders may manage\\r\\n\\t\\t\\t`_managedRight`.\\r\\n\\t*/\\r\\n\\tfunction setManagerRight (\\r\\n\\t\\tbytes32 _managedRight,\\r\\n\\t\\tbytes32 _managerRight\\r\\n\\t) external virtual hasValidPermit(UNIVERSAL, MANAGER) {\\r\\n\\t\\trequire(_managedRight != ZERO_RIGHT, \\\"P3\\\");\\r\\n\\t\\tmanagerRight[_managedRight] = _managerRight;\\r\\n\\t\\temit ManagementUpdated(_msgSender(), _managedRight, _managerRight);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tSet the permit to a specific address under some circumstances. A permit may\\r\\n\\t\\tonly be set by the super-administrative contract owner or an address holding\\r\\n\\t\\tsome delegated management permit.\\r\\n\\r\\n\\t\\t@param _address The address to assign the specified `_right` to.\\r\\n\\t\\t@param _circumstance The circumstance in which the `_right` is valid.\\r\\n\\t\\t@param _right The specific right to assign.\\r\\n\\t\\t@param _expirationTime The time when the `_right` expires for the provided\\r\\n\\t\\t\\t`_circumstance`.\\r\\n\\t*/\\r\\n\\tfunction setPermit (\\r\\n\\t\\taddress _address,\\r\\n\\t\\tbytes32 _circumstance,\\r\\n\\t\\tbytes32 _right,\\r\\n\\t\\tuint256 _expirationTime\\r\\n\\t) public virtual hasValidPermit(UNIVERSAL, managerRight[_right]) {\\r\\n\\t\\trequire(_right != ZERO_RIGHT, \\\"P2\\\");\\r\\n\\t\\tpermissions[_address][_circumstance][_right] = _expirationTime;\\r\\n\\t\\temit PermitUpdated(\\r\\n\\t\\t\\t_msgSender(),\\r\\n\\t\\t\\t_address,\\r\\n\\t\\t\\t_circumstance,\\r\\n\\t\\t\\t_right,\\r\\n\\t\\t\\t_expirationTime\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tDetermine whether or not an address has some rights under the given\\r\\n\\t\\tcircumstance, and if they do have the right, until when.\\r\\n\\r\\n\\t\\t@param _address The address to check for the specified `_right`.\\r\\n\\t\\t@param _circumstance The circumstance to check the specified `_right` for.\\r\\n\\t\\t@param _right The right to check for validity.\\r\\n\\r\\n\\t\\t@return The timestamp in seconds when the `_right` expires. If the timestamp\\r\\n\\t\\t\\tis zero, we can assume that the user never had the right.\\r\\n\\t*/\\r\\n\\tfunction hasRightUntil (\\r\\n\\t\\taddress _address,\\r\\n\\t\\tbytes32 _circumstance,\\r\\n\\t\\tbytes32 _right\\r\\n\\t) public view returns (uint256) {\\r\\n\\t\\treturn permissions[_address][_circumstance][_right];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tDetermine whether or not an address has some rights under the given\\r\\n\\t\\tcircumstance,\\r\\n\\r\\n\\t\\t@param _address The address to check for the specified `_right`.\\r\\n\\t\\t@param _circumstance The circumstance to check the specified `_right` for.\\r\\n\\t\\t@param _right The right to check for validity.\\r\\n\\r\\n\\t\\t@return true or false, whether user has rights and time is valid.\\r\\n\\t*/\\r\\n\\tfunction hasRight (\\r\\n\\t\\taddress _address,\\r\\n\\t\\tbytes32 _circumstance,\\r\\n\\t\\tbytes32 _right\\r\\n\\t) public view returns (bool) {\\r\\n\\t\\treturn permissions[_address][_circumstance][_right] > block.timestamp;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/marketplace/proxy/DelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.15;\\r\\n\\r\\n/// Thrown if the proxy's implementation is not set.\\r\\nerror ImplementationIsNotSet ();\\r\\n\\r\\n/**\\r\\n\\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\\r\\n\\t@title Delegate Proxy\\r\\n\\t@author Facu Spagnuolo, OpenZeppelin\\r\\n\\t@author Protinam, Project Wyvern\\r\\n\\t@author Tim Clancy <@_Enoch>\\r\\n\\r\\n\\tA basic call-delegating proxy contract which is compliant with the current \\r\\n\\tdraft version of ERC-897. This contract was originally developed by Project \\r\\n\\tWyvern. It has been modified to support a more modern version of Solidity \\r\\n\\twith associated best practices. The documentation has also been improved to \\r\\n\\tprovide more clarity.\\r\\n\\r\\n\\t@custom:date December 4th, 2022.\\r\\n*/\\r\\nabstract contract DelegateProxy {\\r\\n\\r\\n\\t/**\\r\\n\\t\\tThis payable fallback function exists to automatically delegate all calls to\\r\\n\\t\\tthis proxy to the contract specified from `implementation()`. Anything\\r\\n\\t\\treturned from the delegated call will also be returned here.\\r\\n\\r\\n\\t\\t@custom:throws ImplementationIsNotSet if the contract implementation is not \\r\\n\\t\\t\\tset.\\r\\n\\t*/\\r\\n\\tfallback () external payable virtual {\\r\\n\\t\\taddress target = implementation();\\r\\n\\r\\n\\t\\t// Ensure that the proxy implementation has been set correctly.\\r\\n\\t\\tif (target == address(0)) {\\r\\n\\t\\t\\trevert ImplementationIsNotSet();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Perform the actual call delegation.\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tlet ptr := mload(0x40)\\r\\n\\t\\t\\tcalldatacopy(ptr, 0, calldatasize())\\r\\n\\t\\t\\tlet result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)\\r\\n\\t\\t\\tlet size := returndatasize()\\r\\n\\t\\t\\treturndatacopy(ptr, 0, size)\\r\\n\\t\\t\\tswitch result\\r\\n\\t\\t\\tcase 0 {\\r\\n\\t\\t\\t\\trevert(ptr, size)\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdefault {\\r\\n\\t\\t\\t\\treturn(ptr, size)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t\\tReturn the current address where all calls to this proxy are delegated. If\\r\\n\\t\\t`proxyType()` returns `1`, ERC-897 dictates that this address MUST not\\r\\n\\t\\tchange.\\r\\n\\r\\n\\t\\t@return _ The current address where calls to this proxy are delegated.\\r\\n\\t*/\\r\\n\\tfunction implementation () public view virtual returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1337\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IProxyRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract TokenTransferProxy\",\"name\":\"_tokenTransferProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_protocolFeePercent\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArgumentsLengthMismatched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallToProxyFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotAuthenticateOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonceLowerThanCurrent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughValueSent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderIsAlreadyCancelled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolFeeRecipientCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownUserProxyImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UserProxyDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorAddressCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongOrderType\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minNonce\",\"type\":\"uint256\"}],\"name\":\"AllOrdersCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"managedRight\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"managerRight\",\"type\":\"bytes32\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"order\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"OrderResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"circumstance\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"name\":\"PermitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldProtocolFeeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newProtocolFeeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolFeePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolFeePercent\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRoyalties\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyalties\",\"type\":\"uint256\"}],\"name\":\"RoyaltyChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_CONFIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROYALTY_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNIVERSAL\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_SETTER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_RIGHT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minNonce\",\"type\":\"uint256\"}],\"name\":\"cancelAllOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order\",\"name\":\"_order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order[]\",\"name\":\"_orders\",\"type\":\"tuple[]\"}],\"name\":\"cancelOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelledOrFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProtocolFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newProtocolFeePercent\",\"type\":\"uint256\"}],\"name\":\"changeProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"changeValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentProtocolFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"}],\"name\":\"currentRoyalties\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order[]\",\"name\":\"_orders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Entities.Sig[]\",\"name\":\"_signatures\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order[]\",\"name\":\"_toInvalidate\",\"type\":\"tuple[]\"}],\"name\":\"exchangeMultipleItems\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order\",\"name\":\"_order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Entities.Sig\",\"name\":\"_signature\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"enum Sales.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum AuthenticatedProxy.CallType\",\"name\":\"callType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Entities.Outline\",\"name\":\"outline\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"extra\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Entities.Order[]\",\"name\":\"_toInvalidate\",\"type\":\"tuple[]\"}],\"name\":\"exchangeSingleItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_circumstance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"}],\"name\":\"hasRight\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_circumstance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"}],\"name\":\"hasRightUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"indices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"managerRight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minOrderNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"permissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IProxyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_managedRight\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_managerRight\",\"type\":\"bytes32\"}],\"name\":\"setManagerRight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_circumstance\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_right\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_expirationTime\",\"type\":\"uint256\"}],\"name\":\"setPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newRoyalties\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTransferProxy\",\"outputs\":[{\"internalType\":\"contract TokenTransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"}],\"name\":\"transferMultipleItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "GigaMart", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1337", "ConstructorArguments": "00000000000000000000000072939b9d6fe467d58d9b6cd35f35fa7de9383d010000000000000000000000002f0809aa3f09b19d5e8cd869108427032683e901000000000000000000000000a0f5b64ef8a1665243c5e54660277d9a62e58d0d0000000000000000000000006969b5d5bd910aaaf2b153fc3e2231b81d5d928a0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}