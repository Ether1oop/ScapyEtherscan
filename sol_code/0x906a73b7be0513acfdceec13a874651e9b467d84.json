{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/CrawlerPlayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler Player Profile and Stash Manager\\n/// @author Studio Avante\\n/// @notice Creates and maintain Player profile and stash\\n/// @dev Serves CrawlerToken.sol, depends on ICrawlerToken (chambers tokens)\\n//\\npragma solidity ^0.8.16;\\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\\nimport { ERC165Checker } from '@openzeppelin/contracts/utils/introspection/ERC165Checker.sol';\\nimport { ICrawlerToken } from './ICrawlerToken.sol';\\nimport { ICrawlerQuery } from './ICrawlerQuery.sol';\\nimport { Crawl } from './Crawl.sol';\\n\\ncontract CrawlerPlayer is Ownable {\\n\\n\\tICrawlerQuery public _query;\\n\\n\\tstruct Profile {\\n\\t\\taddress pfpContract;\\n\\t\\tuint256 pfpId;\\n\\t\\tuint8 classId;\\n\\t\\tuint8 style;\\n\\t\\tuint16 value1;\\n\\t\\tuint16 value2;\\n\\t\\tuint16 value3;\\n\\t\\tuint16 value4;\\n\\t\\tuint16 value5;\\n\\t\\tbool hidden;\\n\\t\\tstring name;\\n\\t}\\n\\n\\tstruct Stash {\\n\\t\\tuint128 coins;\\n\\t\\tuint128 worth;\\n\\t\\tuint32[8] gems;\\n\\t}\\n\\n\\tmapping(address => Profile) private _profiles;\\n\\tmapping(address => Stash) private _stash;\\n\\n\\tevent CreatedProfile(address indexed player);\\n\\tevent UpdatedProfile(address indexed player);\\n\\n\\tevent Give(address indexed to, Crawl.Gem indexed gem, uint16 indexed coins, uint16 worth);\\n\\tevent Take(address indexed from, Crawl.Gem indexed gem, uint16 indexed coins, uint16 worth);\\n\\n\\t/// @dev modifier to test profile existence, reverts if it does not\\n\\tmodifier ifExists(address player) {\\n\\t\\trequire(_profiles[player].style != 0, 'Profile not found');\\n\\t\\trequire(!_profiles[player].hidden || msg.sender == player, 'Profile unavailable');\\n\\t\\t_;\\n\\t}\\n\\n\\t//---------------\\n\\t// Admin\\n\\t//\\n\\n\\t/// @notice Admin function\\n\\tfunction setQueryContract(address queryContract_) public onlyOwner {\\n\\t\\t_query = ICrawlerQuery(queryContract_);\\n\\t}\\n\\n\\t//---------------\\n\\t// Public\\n\\t//\\n\\n\\t/// @notice Check if a player has a public profile\\n\\t/// @param player The Player wallet address\\n\\t/// @return result True if the Player has a public profile, False if not, or profile is not public\\n\\tfunction playerHasProfile(address player) public view returns (bool) {\\n\\t\\treturn (_profiles[player].style != 0 && (!_profiles[player].hidden || msg.sender == player));\\n\\t}\\n\\n\\t/// @notice Returns a Player public profile\\n\\t/// @param player The Player wallet address\\n\\t/// @return result Profile struct\\n\\t/// PFP and Class id will return empty if player does not own\\n\\t/// reverts if Player has no profile or profile is not public\\n\\tfunction getPlayerProfile(address player) public view ifExists(player) returns (Profile memory result) {\\n\\t\\tresult = _profiles[player];\\n\\t\\t// Check PFP ownership\\n\\t\\tif(!_query.isOwner(result.pfpContract, result.pfpId, player)) {\\n\\t\\t\\tresult.pfpContract = address(0);\\n\\t\\t\\tresult.pfpId = 0;\\n\\t\\t}\\n\\t\\t// Check class ownership\\n\\t\\tif(result.classId != 0 && !_query.isOwner(address(_query.getCardsContract()), result.classId, player)) {\\n\\t\\t\\tresult.classId = 0;\\n\\t\\t}\\n\\t\\t// Get class from owned cards\\n\\t\\tif(result.classId == 0) {\\n\\t\\t\\tuint256[] memory cards = _query.getOwnedCards(player, 1);\\n\\t\\t\\tfor(uint8 i = 0 ; i < cards.length ; ++i) {\\n\\t\\t\\t\\tif(cards[i] > 0) {\\n\\t\\t\\t\\t\\tresult.classId = i + 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Returns a Player Stash\\n\\t/// @param player The Player wallet address\\n\\t/// @return result Stash struct, reverts if Player has no profile or profile is not public\\n\\tfunction getPlayerStash(address player) public view ifExists(player) returns (Stash memory) {\\n\\t\\treturn _stash[player];\\n\\t}\\n\\n\\t/// @notice Creates a public profile and stash for the sender wallet, reverts if Player already have a profile\\n\\t/// @param name Display name\\n\\t/// @param pfpContract The PFP contract address, or address(0) if no PFP\\n\\t/// @param pfpId The PFP token id, ownership will be validated by getPlayerProfile()\\n\\t/// @param classId Class token id to be used, from CardsMinter, ownership will be validated by getPlayerProfile()\\n\\t/// @param style The PFP style, reverts if 0\\n\\t/// @param value1 Reserved for styling and customization\\n\\t/// @param value2 Reserved for styling and customization\\n\\t/// @param value3 Reserved for styling and customization\\n\\t/// @param value4 Reserved for styling and customization\\n\\t/// @param value5 Reserved for styling and customization\\n\\tfunction createProfile(\\n\\t\\tstring calldata name,\\n\\t\\taddress pfpContract,\\n\\t\\tuint256 pfpId,\\n\\t\\tuint8 classId,\\n\\t\\tuint8 style,\\n\\t\\tuint16 value1,\\n\\t\\tuint16 value2,\\n\\t\\tuint16 value3,\\n\\t\\tuint16 value4,\\n\\t\\tuint16 value5)\\n\\tpublic {\\n\\t\\t// create new profile\\n\\t\\trequire(_profiles[msg.sender].style == 0, 'Your profile already exists');\\n\\t\\t_updateProfile(name, pfpContract, pfpId, classId, style, value1, value2, value3, value4, value5, false);\\n\\n\\t\\t// Create stash from player's Crawler tokens\\n\\t\\tICrawlerToken chambers = _query.getChambersContract();\\n\\t\\tStash memory stash;\\n\\t\\tfor(uint256 i = 0 ; i < chambers.balanceOf(msg.sender) ; ++i) {\\n\\t\\t\\tuint256 tokenId = chambers.tokenOfOwnerByIndex(msg.sender, i);\\n\\t\\t\\tCrawl.Hoard memory hoard = chambers.tokenIdToHoard(tokenId);\\n\\t\\t\\tstash.gems[uint8(hoard.gemType)]++;\\n\\t\\t\\tstash.coins += hoard.coins;\\n\\t\\t\\tstash.worth += hoard.worth;\\n\\t\\t}\\n\\n\\t\\t_stash[msg.sender] = stash;\\n\\n\\t\\temit CreatedProfile(msg.sender);\\n\\t}\\n\\n\\t/// @notice Updates a public profile for the sender wallet, reverts if Player does not have a profile\\n\\t/// @param name Display name\\n\\t/// @param pfpContract The PFP contract address, or address(0) if no PFP\\n\\t/// @param pfpId The PFP token id, ownership will be validated by getPlayerProfile()\\n\\t/// @param classId Class token id to be used, from CardsMinter, ownership will be validated by getPlayerProfile()\\n\\t/// @param style The PFP style, reverts if 0\\n\\t/// @param value1 Reserved for styling and customization\\n\\t/// @param value2 Reserved for styling and customization\\n\\t/// @param value3 Reserved for styling and customization\\n\\t/// @param value4 Reserved for styling and customization\\n\\t/// @param value5 Reserved for styling and customization\\n\\tfunction updateProfile(\\n\\t\\tstring calldata name,\\n\\t\\taddress pfpContract,\\n\\t\\tuint256 pfpId,\\n\\t\\tuint8 classId,\\n\\t\\tuint8 style,\\n\\t\\tuint16 value1,\\n\\t\\tuint16 value2,\\n\\t\\tuint16 value3,\\n\\t\\tuint16 value4,\\n\\t\\tuint16 value5)\\n\\tpublic ifExists(msg.sender) {\\n\\t\\t_updateProfile(name, pfpContract, pfpId, classId, style, value1, value2, value3, value4, value5, _profiles[msg.sender].hidden);\\n\\t\\temit UpdatedProfile(msg.sender);\\n\\t}\\n\\n\\t/// @dev internal profile updater\\n\\tfunction _updateProfile(\\n\\t\\tstring calldata name,\\n\\t\\taddress pfpContract,\\n\\t\\tuint256 pfpId,\\n\\t\\tuint8 classId,\\n\\t\\tuint8 style,\\n\\t\\tuint16 value1,\\n\\t\\tuint16 value2,\\n\\t\\tuint16 value3,\\n\\t\\tuint16 value4,\\n\\t\\tuint16 value5,\\n\\t\\tbool hidden\\n\\t)\\n\\tinternal {\\n\\t\\trequire(style != 0, 'Invalid style');\\n\\t\\t_profiles[msg.sender] = Profile(\\n\\t\\t\\tpfpContract,\\n\\t\\t\\tpfpId,\\n\\t\\t\\tclassId,\\n\\t\\t\\tstyle,\\n\\t\\t\\tvalue1,\\n\\t\\t\\tvalue2,\\n\\t\\t\\tvalue3,\\n\\t\\t\\tvalue4,\\n\\t\\t\\tvalue5,\\n\\t\\t\\thidden,\\n\\t\\t\\tname\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice Updates the profile visibility for the sender wallet, reverts if Player does not have a profile\\n\\t/// @param hidden True to hide, profile will be kept private, False if profile is public\\n\\tfunction hideProfile(bool hidden) public ifExists(msg.sender) {\\n\\t\\t_profiles[msg.sender].hidden = hidden;\\n\\t}\\n\\n\\t//---------------\\n\\t// Crawler only\\n\\t//\\n\\n\\t/// @notice Transfer a Chamber's Hoard to another wallet, works only if called by CrawlerToken contract\\n\\tfunction transferChamberHoard(address from, address to, Crawl.Hoard memory hoard) public {\\n\\t\\tif(address(_query) != address(0) && msg.sender == address(_query.getChambersContract())) {\\n\\t\\t\\t// Take from\\n\\t\\t\\temit Take(from, hoard.gemType, hoard.coins, hoard.worth);\\n\\t\\t\\tif(_profiles[from].style != 0) {\\n\\t\\t\\t\\tStash storage stash = _stash[from];\\n\\t\\t\\t\\tstash.gems[uint8(hoard.gemType)] = safe_sub32(stash.gems[uint8(hoard.gemType)], 1);\\n\\t\\t\\t\\tstash.coins = safe_sub128(stash.coins, hoard.coins);\\n\\t\\t\\t\\tstash.worth = safe_sub128(stash.worth, hoard.worth);\\n\\t\\t\\t}\\n\\t\\t\\t// Give to\\n\\t\\t\\temit Give(to, hoard.gemType, hoard.coins, hoard.worth);\\n\\t\\t\\tif(_profiles[to].style != 0) {\\n\\t\\t\\t\\tStash storage stash = _stash[to];\\n\\t\\t\\t\\tstash.gems[uint8(hoard.gemType)] = safe_add32(stash.gems[uint8(hoard.gemType)], 1);\\n\\t\\t\\t\\tstash.coins = safe_add128(stash.coins, hoard.coins);\\n\\t\\t\\t\\tstash.worth = safe_add128(stash.worth, hoard.worth);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev overflows should not happen, but just to be safe and avoid reverting transfers...\\n\\tfunction safe_add128(uint128 a, uint128 b) internal pure returns (uint128) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint128 c = a + b;\\n\\t\\t\\tif (c < a) return type(uint128).max;\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t}\\n\\tfunction safe_add32(uint32 a, uint32 b) internal pure returns (uint32) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint32 c = a + b;\\n\\t\\t\\tif (c < a) return type(uint32).max;\\n\\t\\t\\treturn c;\\n\\t\\t}\\n\\t}\\n\\tfunction safe_sub128(uint128 a, uint128 b) internal pure returns (uint128) {\\n\\t\\tif (b > a) return 0;\\n\\t\\treturn a - b;\\n\\t}\\n\\tfunction safe_sub32(uint32 a, uint32 b) internal pure returns (uint32) {\\n\\t\\tif (b > a) return 0;\\n\\t\\treturn a - b;\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/extras/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler IERC721Enumerable implementation Interface\\n/// @author Studio Avante\\n//\\npragma solidity ^0.8.0;\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\ninterface IERC721Enumerable is IERC721 {\\n\\tfunction totalSupply() external view returns (uint256);\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\tfunction tokenByIndex(uint256 index) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/contracts/external/ICardsStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Cards Store interface\\n/// @author Studio Avante\\n/// @notice Cards Store interface\\n/// @dev Serves CardsMinter.sol\\npragma solidity ^0.8.16;\\n\\ninterface ICardsStore {\\n\\tfunction getVersion() external view returns (uint8);\\n\\tfunction exists(uint256 id) external view returns (bool);\\n\\tfunction getCardCount() external view returns (uint256);\\n\\tfunction getCardSupply(uint256 id) external view returns (uint256);\\n\\tfunction getCardPrice(uint256 id) external view returns (uint256);\\n\\tfunction beforeMint(uint256 id, uint256 currentSupply, uint256 balance, uint256 value) external view;\\n\\tfunction uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/external/ICardsMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler Cards Minter Interface\\n/// @author Studio Avante\\n/// @dev use this interface for contract interaction\\npragma solidity ^0.8.16;\\nimport { IERC1155 } from '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\\n\\ninterface ICardsMinter is IERC1155 {\\n\\n\\t/// @notice Check if the purchases are paused\\n\\t/// @return bool True if paused, False if unpaused\\n\\tfunction isPaused() external view returns (bool);\\n\\n\\t/// @notice Returns a Token unit price, not considering availability\\n\\t/// @param id Token id\\n\\t/// @return price Price of the token, in WEI\\n\\tfunction getPrice(uint256 id) external view returns (uint256);\\n\\n\\t/// @notice Run all require tests for a successful purchase()\\n\\t/// @param id Token id\\n\\t/// @param value Value that will be sent to purchase(), in WEI\\n\\t/// @return bool True if purchase is allowed, False if not\\n\\t/// @return reason The reason when purchase now allowed\\n\\tfunction canPurchase(uint256 id, uint256 value) external view returns (bool, string memory);\\n\\t/// @notice Purchases 1 Token for the Sender. The message value must be equal or higher than getPrice(id)\\n\\t/// @param id Token id\\n\\t/// @param data Nevermind, use []\\n  function purchase(uint256 id, bytes memory data) external view;\\n\\n\\t/// @notice Burn tokens. Sender must be owner or approved\\n\\t/// @param id Token id\\n\\t/// @param amount The amount of tokens to burn\\n\\tfunction burn(uint256 id, uint256 amount) external view;\\n\\n\\t/// @notice Returns a token metadata, compliant with ERC1155Metadata_URI\\n\\t/// @param id Token id\\n\\t/// @return metadata Token metadata, as json string base64 encoded\\n\\tfunction uri(uint256 id) external view returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/ICrawlerToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler Chamber Minter Interface\\n/// @author Studio Avante\\n//\\npragma solidity ^0.8.16;\\nimport { IERC165 } from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\nimport { IERC721 } from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport { IERC721Metadata } from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\nimport { IERC721Enumerable } from './extras/IERC721Enumerable.sol';\\nimport { Crawl } from './Crawl.sol';\\n\\ninterface ICrawlerToken is IERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n\\tfunction isPaused() external view returns (bool);\\n\\tfunction getPrices() external view returns (uint256, uint256);\\n\\tfunction calculateMintPrice(address to) external view returns (uint256);\\n\\tfunction tokenIdToCoord(uint256 tokenId) external view returns (uint256);\\n\\tfunction coordToSeed(uint256 coord) external view returns (Crawl.ChamberSeed memory);\\n\\tfunction coordToChamberData(uint8 chapterNumber, uint256 coord, bool generateMaps) external view returns (Crawl.ChamberData memory);\\n\\tfunction tokenIdToHoard(uint256 tokenId) external view returns (Crawl.Hoard memory);\\n\\t// Metadata calls\\n\\tfunction getChamberMetadata(uint8 chapterNumber, uint256 coord) external view returns (string memory);\\n\\tfunction getMapMetadata(uint8 chapterNumber, uint256 coord) external view returns (string memory);\\n\\tfunction getTokenMetadata(uint8 chapterNumber, uint256 coord) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/ICrawlerQuery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler Query Utility Interface\\n/// @author Studio Avante\\n//\\npragma solidity ^0.8.16;\\nimport { ICrawlerToken } from './ICrawlerToken.sol';\\nimport { ICardsMinter } from './external/ICardsMinter.sol';\\nimport { ICardsStore } from './external/ICardsStore.sol';\\n\\ninterface ICrawlerQuery {\\n\\tfunction getChambersContract() external view returns (ICrawlerToken);\\n\\tfunction getCardsContract() external view returns (ICardsMinter);\\n\\tfunction getStoreContract() external view returns (ICardsStore);\\n\\tfunction getOwnedChambers(address account) external view returns (uint256[] memory result);\\n\\tfunction getOwnedCards(address account, uint8 cardType) external view returns (uint256[] memory result);\\n\\tfunction isOwner(address tokenContract, uint256 id, address account) external view returns (bool);\\n\\tfunction getURI(address tokenContract, uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/Crawl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//\\n//    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n//   \u2588          \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588            \u2588\\n//  \u2588    \u2591\u2591\u2591\u2591    \u2588\\n//  \u2588   \u2593\u2593\u2593\u2593\u2593\u2593   \u2588\\n//  \u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\\n//\\n// https://endlesscrawler.io\\n// @EndlessCrawler\\n//\\n/// @title Endless Crawler Game Definitions and Library\\n/// @author Studio Avante\\n/// @notice Contains common definitions and functions\\n//\\npragma solidity ^0.8.16;\\n\\nlibrary Crawl {\\n\\n  //-----------------------------------\\n  // ChamberSeed, per token static data\\n  // generated on mint, stored on-chain\\n  //\\n\\tstruct ChamberSeed {\\n\\t\\tuint256 tokenId;\\n\\t\\tuint256 seed;\\n\\t\\tuint232 yonder;\\n\\t\\tuint8 chapter;\\n\\t\\tCrawl.Terrain terrain;\\n\\t\\tCrawl.Dir entryDir;\\n\\t}\\n\\n\\n  //------------------------------------\\n  // ChamberData, per token dynamic data\\n  // generated on demand\\n  //\\n\\tstruct ChamberData {\\n\\t\\t// from ChamberSeed (static)\\n\\t\\tuint256 coord;\\n\\t\\tuint256 tokenId;\\n\\t\\tuint256 seed;\\n\\t\\tuint232 yonder;\\n\\t\\tuint8 chapter;\\t\\t\\t// Chapter minted\\n\\t\\tCrawl.Terrain terrain;\\n\\t\\tCrawl.Dir entryDir;\\n\\n\\t\\t// generated on demand (deterministic)\\n\\t\\tCrawl.Hoard hoard;\\n\\t\\tuint8 gemPos;\\t\\t\\t\\t// gem bitmap position\\n\\n\\t\\t// dynamic until all doors are unlocked\\n\\t\\tuint8[4] doors; \\t\\t// bitmap position in NEWS order\\n\\t\\tuint8[4] locks; \\t\\t// lock status in NEWS order\\n\\n\\t\\t// optional\\n\\t\\tuint256 bitmap;\\t\\t\\t// bit map, 0 is void/walls, 1 is path\\n\\t\\tbytes tilemap;\\t\\t\\t// tile map\\n\\n\\t\\t// custom data\\n\\t\\tCustomData[] customData;\\n\\t}\\n\\n\\tstruct Hoard {\\n\\t\\tCrawl.Gem gemType;\\n\\t\\tuint16 coins;\\t\\t// coins value\\n\\t\\tuint16 worth;\\t\\t// gem + coins value\\n\\t}\\n\\n\\tenum CustomDataType {\\n\\t\\tCustom0, Custom1, Custom2, Custom3, Custom4,\\n\\t\\tCustom5, Custom6, Custom7, Custom8, Custom9,\\n\\t\\tTile,\\n\\t\\tPalette,\\n\\t\\tBackground,\\n\\t\\tForeground,\\n\\t\\tCharSet,\\n\\t\\tMusic\\n\\t}\\n\\n\\tstruct CustomData {\\n\\t\\tCustomDataType dataType;\\n\\t\\tbytes data;\\n\\t}\\n\\n\\n\\t//-----------------------\\n\\t// Terrain types\\n\\t//\\n\\t// 2 Water | 3 Air\\n\\t// --------|--------\\n\\t// 1 Earth | 4 Fire\\n\\t//\\n\\tenum Terrain {\\n\\t\\tEmpty,\\t// 0\\n\\t\\tEarth,\\t// 1\\n\\t\\tWater,\\t// 2\\n\\t\\tAir,\\t\\t// 3\\n\\t\\tFire\\t\\t// 4\\n\\t}\\n\\n\\t/// @dev Returns the opposite of a Terrain\\n\\t// Opposite terrains cannot access to each other\\n\\t// Earth <> Air\\n\\t// Water <> Fire\\n\\tfunction getOppositeTerrain(Crawl.Terrain terrain) internal pure returns (Crawl.Terrain) {\\n\\t\\tuint256 t = uint256(terrain);\\n\\t\\treturn t >= 3 ? Crawl.Terrain(t-2) : t >= 1 ? Crawl.Terrain(t+2) : Crawl.Terrain.Empty;\\n\\t}\\n\\n\\t//-----------------------\\n\\t// Gem types\\n\\t//\\n\\tenum Gem {\\n\\t\\tSilver,\\t\\t\\t// 0\\n\\t\\tGold,\\t\\t\\t\\t// 1\\n\\t\\tSapphire,\\t\\t// 2\\n\\t\\tEmerald,\\t\\t// 3\\n\\t\\tRuby,\\t\\t\\t\\t// 4\\n\\t\\tDiamond,\\t\\t// 5\\n\\t\\tEthernite,\\t// 6\\n\\t\\tKao,\\t\\t\\t\\t// 7\\n\\t\\tCoin\\t\\t\\t\\t// 8 (not a gem!)\\n\\t}\\n\\n\\t/// @dev Returns the Worth value of a Gem\\n\\tfunction getGemValue(Crawl.Gem gem) internal pure returns (uint16) {\\n\\t\\tif (gem == Crawl.Gem.Silver) return 50;\\n\\t\\tif (gem == Crawl.Gem.Gold) return 100;\\n\\t\\tif (gem == Crawl.Gem.Sapphire) return 150;\\n\\t\\tif (gem == Crawl.Gem.Emerald) return 200;\\n\\t\\tif (gem == Crawl.Gem.Ruby) return 300;\\n\\t\\tif (gem == Crawl.Gem.Diamond) return 500;\\n\\t\\tif (gem == Crawl.Gem.Ethernite) return 800;\\n\\t\\treturn 1001; // Crawl.Gem.Kao\\n\\t}\\n\\n\\t/// @dev Calculates a Chamber Worth value\\n\\tfunction calcWorth(Crawl.Gem gem, uint16 coins) internal pure returns (uint16) {\\n\\t\\treturn getGemValue(gem) + coins;\\n\\t}\\n\\n\\t//--------------------------\\n\\t// Directions, in NEWS order\\n\\t//\\n\\tenum Dir {\\n\\t\\tNorth,\\t// 0\\n\\t\\tEast,\\t\\t// 1\\n\\t\\tWest,\\t\\t// 2\\n\\t\\tSouth\\t\\t// 3\\n\\t}\\n\\tuint256 internal constant mask_South = uint256(type(uint64).max);\\n\\tuint256 internal constant mask_West = (mask_South << 64);\\n\\tuint256 internal constant mask_East = (mask_South << 128);\\n\\tuint256 internal constant mask_North = (mask_South << 192);\\n\\n\\t/// @dev Flips a direction\\n\\t/// North <> South\\n\\t/// East <> West\\n\\tfunction flipDir(Crawl.Dir dir) internal pure returns (Crawl.Dir) {\\n\\t\\treturn Crawl.Dir(3 - uint256(dir));\\n\\t}\\n\\n\\t/// @dev Flips a door possition at a direction to connect to neighboring chamber\\n\\tfunction flipDoorPosition(uint8 doorPos, Crawl.Dir dir) internal pure returns (uint8 result) {\\n\\t\\tif (dir == Crawl.Dir.North) return doorPos > 0 ? doorPos + (15 * 16) : 0;\\n\\t\\tif (dir == Crawl.Dir.South) return doorPos > 0 ? doorPos - (15 * 16) : 0;\\n\\t\\tif (dir == Crawl.Dir.West) return doorPos > 0 ? doorPos + 15 : 0;\\n\\t\\treturn doorPos > 0 ? doorPos - 15 : 0; // Crawl.Dir.East\\n\\t}\\n\\n\\t//-----------------------\\n\\t// Coords\\n\\t//\\t\\n\\t// coords have 4 components packed in uint256\\n\\t// in NEWS direction:\\n\\t// (N)orth, (E)ast, (W)est, (S)outh\\n\\t// o-------o-------o-------o-------o\\n\\t// 0       32     128     192    256\\n\\n\\t/// @dev Extracts the North component from a Chamber coordinate\\n\\tfunction getNorth(uint256 coord) internal pure returns (uint256 result) {\\n\\t\\treturn (coord >> 192);\\n\\t}\\n\\t/// @dev Extracts the East component from a Chamber coordinate\\n\\tfunction getEast(uint256 coord) internal pure returns (uint256) {\\n\\t\\treturn ((coord & mask_East) >> 128);\\n\\t}\\n\\t/// @dev Extracts the West component from a Chamber coordinate\\n\\tfunction getWest(uint256 coord) internal pure returns (uint256) {\\n\\t\\treturn ((coord & mask_West) >> 64);\\n\\t}\\n\\t/// @dev Extracts the South component from a Chamber coordinate\\n\\tfunction getSouth(uint256 coord) internal pure returns (uint256) {\\n\\t\\treturn coord & mask_South;\\n\\t}\\n\\n\\t/// @dev Builds a Chamber coordinate from its direction components\\n\\t/// a coord is composed of 4 uint64 components packed in a uint256\\n\\t/// Components are combined in NEWS order: Nort, East, West, South\\n\\t/// @param north North component, zero if South\\n\\t/// @param east East component, zero id West\\n\\t/// @param west West component, zero if East\\n\\t/// @param south South component, zero if North\\n\\t/// @return result Chamber coordinate\\n\\tfunction makeCoord(uint256 north, uint256 east, uint256 west, uint256 south) internal pure returns (uint256 result) {\\n\\t\\t// North or South need to be positive, but not both\\n\\t\\tif(north > 0) {\\n\\t\\t\\trequire(south == 0, 'Crawl.makeCoord(): bad North/South');\\n\\t\\t\\tresult += (north << 192);\\n\\t\\t} else if(south > 0) {\\n\\t\\t\\tresult += south;\\n\\t\\t} else {\\n\\t\\t\\trevert('Crawl.makeCoord(): need North or South');\\n\\t\\t}\\n\\t\\t// West or East need to be positive, but not both\\n\\t\\tif(east > 0) {\\n\\t\\t\\trequire(west == 0, 'Crawl.makeCoord(): bad West/East');\\n\\t\\t\\tresult += (east << 128);\\n\\t\\t} else if(west > 0) {\\n\\t\\t\\tresult += (west << 64);\\n\\t\\t} else {\\n\\t\\t\\trevert('Crawl.makeCoord(): need West or East');\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Offsets a Chamber coordinate in one direction\\n\\t/// @param coord Chamber coordinate\\n\\t/// @param dir Direction to offset\\n\\t/// @return coord The new coordinate. If reached limits, return same coord\\n\\t// TODO: Use assembly?\\n\\tfunction offsetCoord(uint256 coord, Crawl.Dir dir) internal pure returns (uint256) {\\n\\t\\tif(dir == Crawl.Dir.North) {\\n\\t\\t\\tif(coord & mask_South > 1) return coord - 1; // --South\\n\\t\\t\\tif(coord & mask_North != mask_North) return (coord & ~mask_South) + (1 << 192); // ++North\\n\\t\\t} else if(dir == Crawl.Dir.East) {\\n\\t\\t\\tif(coord & mask_West > (1 << 64)) return coord - (1 << 64); // --West\\n\\t\\t\\tif(coord & mask_East != mask_East) return (coord & ~mask_West) + (1 << 128); // ++East\\n\\t\\t} else if(dir == Crawl.Dir.West) {\\n\\t\\t\\tif(coord & mask_East > (1 << 128)) return coord - (1 << 128); // --East\\n\\t\\t\\tif(coord & mask_West != mask_West) return (coord & ~mask_East) + (1 << 64); // ++West\\n\\t\\t} else { //if(dir == Crawl.Dir.South) {\\n\\t\\t\\tif(coord & mask_North > (1 << 192)) return coord - (1 << 192); // --North\\n\\t\\t\\tif(coord & mask_South != mask_South) return (coord & ~mask_North) + 1; // ++South\\n\\t\\t}\\n\\t\\treturn coord;\\n\\t}\\n\\n\\n\\t//-----------------------\\n\\t// String Builders\\n\\t//\\n\\n\\t/// @dev Returns a token description for tokenURI()\\n\\tfunction tokenName(string memory tokenId) public pure returns (string memory) {\\n\\t\\treturn string.concat('Chamber #', tokenId);\\n\\t}\\n\\n\\t/// @dev Short string representation of a Chamebr coordinate and Yonder\\n\\tfunction coordsToString(uint256 coord, uint256 yonder, string memory separator) public pure returns (string memory) {\\n\\t\\treturn string.concat(\\n\\t\\t\\t((coord & Crawl.mask_North) > 0\\n\\t\\t\\t\\t? string.concat('N', toString((coord & Crawl.mask_North)>>192))\\n\\t\\t\\t\\t: string.concat('S', toString(coord & Crawl.mask_South))),\\n\\t\\t\\t((coord & Crawl.mask_East) > 0\\n\\t\\t\\t\\t? string.concat(separator, 'E', toString((coord & Crawl.mask_East)>>128))\\n\\t\\t\\t\\t: string.concat(separator, 'W', toString((coord & Crawl.mask_West)>>64))),\\n\\t\\t\\t(yonder > 0 ? string.concat(separator, 'Y', toString(yonder)) : '')\\n\\t\\t);\\n\\t}\\n\\n\\t/// @dev Renders IERC721Metadata attributes for tokenURI()\\n\\t/// Reference: https://docs.opensea.io/docs/metadata-standards\\n\\tfunction renderAttributesMetadata(string[] memory labels, string[] memory values) public pure returns (string memory result) {\\n\\t\\tfor(uint256 i = 0 ; i < labels.length ; ++i) {\\n\\t\\t\\tresult = string.concat(result,\\n\\t\\t\\t\\t'{'\\n\\t\\t\\t\\t\\t'\\\"trait_type\\\":\\\"', labels[i], '\\\",'\\n\\t\\t\\t\\t\\t'\\\"value\\\":\\\"', values[i], '\\\"'\\n\\t\\t\\t\\t'}',\\n\\t\\t\\t\\t(i < (labels.length - 1) ? ',' : '')\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Returns a Chamber metadata, without maps\\n\\t/// @param chamber The Chamber, no maps required\\n\\t/// @return metadata Metadata, as plain json string\\n\\tfunction renderChamberMetadata(Crawl.ChamberData memory chamber, string memory additionalMetadata) internal pure returns (string memory) {\\n\\t\\treturn string.concat(\\n\\t\\t\\t'{'\\n\\t\\t\\t\\t'\\\"tokenId\\\":\\\"', toString(chamber.tokenId), '\\\",'\\n\\t\\t\\t\\t'\\\"name\\\":\\\"', tokenName(toString(chamber.tokenId)), '\\\",'\\n\\t\\t\\t\\t'\\\"chapter\\\":\\\"', toString(chamber.chapter), '\\\",'\\n\\t\\t\\t\\t'\\\"terrain\\\":\\\"', toString(uint256(chamber.terrain)), '\\\",'\\n\\t\\t\\t\\t'\\\"gem\\\":\\\"', toString(uint256(chamber.hoard.gemType)), '\\\",'\\n\\t\\t\\t\\t'\\\"coins\\\":\\\"', toString(chamber.hoard.coins), '\\\",'\\n\\t\\t\\t\\t'\\\"worth\\\":\\\"', toString(chamber.hoard.worth), '\\\",'\\n\\t\\t\\t\\t'\\\"coord\\\":\\\"', toString(chamber.coord), '\\\",'\\n\\t\\t\\t\\t'\\\"yonder\\\":\\\"', toString(chamber.yonder), '\\\",',\\n\\t\\t\\t\\t_renderCompassMetadata(chamber.coord),\\n\\t\\t\\t\\t_renderLocksMetadata(chamber.locks),\\n\\t\\t\\t\\tadditionalMetadata,\\n\\t\\t\\t'}'\\n\\t\\t);\\n\\t}\\n\\tfunction _renderCompassMetadata(uint256 coord) private pure returns (string memory) {\\n\\t\\treturn string.concat(\\n\\t\\t\\t'\\\"compass\\\":{',\\n\\t\\t\\t\\t((coord & Crawl.mask_North) > 0\\n\\t\\t\\t\\t\\t? string.concat('\\\"north\\\":\\\"', toString((coord & Crawl.mask_North)>>192))\\n\\t\\t\\t\\t\\t: string.concat('\\\"south\\\":\\\"', toString(coord & Crawl.mask_South))),\\n\\t\\t\\t\\t((coord & Crawl.mask_East) > 0\\n\\t\\t\\t\\t\\t? string.concat('\\\",\\\"east\\\":\\\"', toString((coord & Crawl.mask_East)>>128))\\n\\t\\t\\t\\t\\t: string.concat('\\\",\\\"west\\\":\\\"', toString((coord & Crawl.mask_West)>>64))),\\n\\t\\t\\t'\\\"},'\\n\\t\\t);\\n\\t}\\n\\tfunction _renderLocksMetadata(uint8[4] memory locks) private pure returns (string memory) {\\n\\t\\treturn string.concat(\\n\\t\\t\\t'\\\"locks\\\":[',\\n\\t\\t\\t\\t(locks[0] == 0 ? 'false,' : 'true,'),\\n\\t\\t\\t\\t(locks[1] == 0 ? 'false,' : 'true,'),\\n\\t\\t\\t\\t(locks[2] == 0 ? 'false,' : 'true,'),\\n\\t\\t\\t\\t(locks[3] == 0 ? 'false' : 'true'),\\n\\t\\t\\t'],'\\n\\t\\t);\\n\\t}\\n\\n\\n\\t//-----------------------\\n\\t// Utils\\n\\t//\\n\\n\\t/// @dev converts uint8 tile position to a bitmap position mask\\n\\tfunction tilePosToBitmap(uint8 tilePos) internal pure returns (uint256) {\\n\\t\\treturn (1 << (255 - tilePos));\\n\\t}\\n\\n\\t/// @dev overSeed has ~50% more bits\\n\\tfunction overSeed(uint256 seed_) internal pure returns (uint256) {\\n\\t\\treturn seed_ | uint256(keccak256(abi.encodePacked(seed_)));\\n\\t}\\n\\n\\t/// @dev underSeed has ~50% less bits\\n\\tfunction underSeed(uint256 seed_) internal pure returns (uint256) {\\n\\t\\treturn seed_ & uint256(keccak256(abi.encodePacked(seed_)));\\n\\t}\\n\\n\\t/// @dev maps seed value modulus to range\\n\\tfunction mapSeed(uint256 seed_, uint256 min_, uint256 maxExcl_) internal pure returns (uint256) {\\n\\t\\treturn min_ + (seed_ % (maxExcl_ - min_));\\n\\t}\\n\\n\\t/// @dev maps seed value modulus to bitmap position (takes 8 bits)\\n\\t/// the position lands in a 12x12 space at the center of the 16x16 map\\n\\tfunction mapSeedToBitmapPosition(uint256 seed_) internal pure returns (uint8) {\\n\\t\\tuint8 i = uint8(seed_ % 144);\\n\\t\\treturn ((i / 12) + 2) * 16 + (i % 12) + 2;\\n\\t}\\n\\n\\t/// @dev min function\\n\\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a < b ? a : b;\\n\\t}\\n\\n\\t/// @dev max function\\n\\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn a > b ? a : b;\\n\\t}\\n\\n\\t//-----------------------------\\n\\t// OpenZeppelin Strings library\\n\\t// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/utils/Strings.sol\\n\\t// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/utils/math/Math.sol\\n\\t//\\n\\tbytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n\\tuint8 private constant _ADDRESS_LENGTH = 20;\\n\\n\\t/// @dev Return the log in base 10, rounded down, of a positive value.\\n\\tfunction log10(uint256 value) private pure returns (uint256) {\\n\\t\\tuint256 result = 0;\\n\\t\\tunchecked {\\n\\t\\t\\tif (value >= 10**64) { value /= 10**64; result += 64; }\\n\\t\\t\\tif (value >= 10**32) { value /= 10**32; result += 32; }\\n\\t\\t\\tif (value >= 10**16) { value /= 10**16; result += 16; }\\n\\t\\t\\tif (value >= 10**8) { value /= 10**8; result += 8; }\\n\\t\\t\\tif (value >= 10**4) { value /= 10**4; result += 4; }\\n\\t\\t\\tif (value >= 10**2) { value /= 10**2; result += 2; }\\n\\t\\t\\tif (value >= 10**1) { result += 1; }\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/// @dev Return the log in base 256, rounded down, of a positive value.\\n\\tfunction log256(uint256 value) private pure returns (uint256) {\\n\\t\\tuint256 result = 0;\\n\\t\\tunchecked {\\n\\t\\t\\tif (value >> 128 > 0) { value >>= 128; result += 16; }\\n\\t\\t\\tif (value >> 64 > 0) { value >>= 64; result += 8; }\\n\\t\\t\\tif (value >> 32 > 0) { value >>= 32; result += 4; }\\n\\t\\t\\tif (value >> 16 > 0) { value >>= 16; result += 2; }\\n\\t\\t\\tif (value >> 8 > 0) { result += 1; }\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/// @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 length = log10(value) + 1;\\n\\t\\t\\tstring memory buffer = new string(length);\\n\\t\\t\\tuint256 ptr;\\n\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tptr := add(buffer, add(32, length))\\n\\t\\t\\t}\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tptr--;\\n\\t\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tmstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue /= 10;\\n\\t\\t\\t\\tif (value == 0) break;\\n\\t\\t\\t}\\n\\t\\t\\treturn buffer;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n\\t/// defined as public to be excluded from the contract ABI and avoid Stack Too Deep error\\n\\tfunction toHexString(uint256 value) public pure returns (string memory) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn toHexString(value, log256(value) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n\\t/// defined as public to be excluded from the contract ABI and avoid Stack Too Deep error\\n\\tfunction toHexString(uint256 value, uint256 length) public pure returns (string memory) {\\n\\t\\tbytes memory buffer = new bytes(2 * length + 2);\\n\\t\\tbuffer[0] = \\\"0\\\";\\n\\t\\tbuffer[1] = \\\"x\\\";\\n\\t\\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\\n\\t\\t\\tbuffer[i] = _SYMBOLS[value & 0xf];\\n\\t\\t\\tvalue >>= 4;\\n\\t\\t}\\n\\t\\trequire(value == 0, \\\"Strings: hex length insufficient\\\");\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\t/// @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n\\tfunction toHexString(address addr) public pure returns (string memory) {\\n\\t\\treturn toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n\\t}\\n\\n\\t/// @dev Converts a single `bytes1` to its ASCII `string` hexadecimal\\n\\tfunction toHexString(bytes1 value) public pure returns (string memory) {\\n\\t\\tbytes memory buffer = new bytes(2);\\n\\t\\tbuffer[0] = _SYMBOLS[uint8(value>>4) & 0xf];\\n\\t\\tbuffer[1] = _SYMBOLS[uint8(value) & 0xf];\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\t/// @dev Converts a `bytes` to its ASCII `string` hexadecimal, without '0x' prefix\\n\\tfunction toHexString(bytes memory value, uint256 start, uint256 length) public pure returns (string memory) {\\n\\t\\trequire(start < value.length, \\\"Strings: hex start overflow\\\");\\n\\t\\trequire(start + length <= value.length, \\\"Strings: hex length overflow\\\");\\n\\t\\tbytes memory buffer = new bytes(2 * length);\\n\\t\\tfor (uint256 i = 0; i < length; i++) {\\n\\t\\t\\tbuffer[i*2+0] = _SYMBOLS[uint8(value[start+i]>>4) & 0xf];\\n\\t\\t\\tbuffer[i*2+1] = _SYMBOLS[uint8(value[start+i]) & 0xf];\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n\\t/// @dev Converts a `bytes` to its ASCII `string` hexadecimal, without '0x' prefix\\n\\tfunction toHexString(bytes memory value) public pure returns (string memory) {\\n\\t\\treturn toHexString(value, 0, value.length);\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"CreatedProfile\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Crawl.Gem\",\"name\":\"gem\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"coins\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"worth\",\"type\":\"uint16\"}],\"name\":\"Give\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum Crawl.Gem\",\"name\":\"gem\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"coins\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"worth\",\"type\":\"uint16\"}],\"name\":\"Take\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"UpdatedProfile\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_query\",\"outputs\":[{\"internalType\":\"contract ICrawlerQuery\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"pfpContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pfpId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"classId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"style\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"value1\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value2\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value3\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value4\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value5\",\"type\":\"uint16\"}],\"name\":\"createProfile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerProfile\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pfpContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pfpId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"classId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"style\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"value1\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value2\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value3\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value4\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value5\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"hidden\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct CrawlerPlayer.Profile\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerStash\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"coins\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"worth\",\"type\":\"uint128\"},{\"internalType\":\"uint32[8]\",\"name\":\"gems\",\"type\":\"uint32[8]\"}],\"internalType\":\"struct CrawlerPlayer.Stash\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"hidden\",\"type\":\"bool\"}],\"name\":\"hideProfile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"playerHasProfile\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"queryContract_\",\"type\":\"address\"}],\"name\":\"setQueryContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum Crawl.Gem\",\"name\":\"gemType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"coins\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"worth\",\"type\":\"uint16\"}],\"internalType\":\"struct Crawl.Hoard\",\"name\":\"hoard\",\"type\":\"tuple\"}],\"name\":\"transferChamberHoard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"pfpContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pfpId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"classId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"style\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"value1\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value2\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value3\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value4\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"value5\",\"type\":\"uint16\"}],\"name\":\"updateProfile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CrawlerPlayer", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}