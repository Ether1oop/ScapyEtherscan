{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\nZVOID Team\r\n\r\nWebsite: https://www.zevoid.io/\r\nTelegram: https://t.me/ZeVoidPortal\r\nTwitter: https://twitter.com/ZeVoidOfficial\r\n\r\n\r\nDr_0x1\r\nHead of development\r\n*/\r\n\r\n\r\n\r\npragma solidity >=0.4.22 <0.9.0;\r\n\r\n\r\n\r\ninterface IFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n// implementation: https://etherscan.io/address/0x48d118c9185e4dbafe7f3813f8f29ec8a6248359#code\r\n// proxy: https://etherscan.io/address/0x48d118c9185e4dbafe7f3813f8f29ec8a6248359#code\r\ninterface ItrustSwap {\r\n    function lockToken(\r\n        address _tokenAddress,\r\n        address _withdrawalAddress,\r\n        uint256 _amount,\r\n        uint256 _unlockTime,\r\n        bool _mintNFT\r\n    )external payable returns (uint256 _id);\r\n\r\n    function transferLocks(uint256 _id, address _receiverAddress) external;\r\n    function addTokenToFreeList(address token) external;\r\n    function extendLockDuration(uint256 _id, uint256 _unlockTime) external;\r\n    function getFeesInETH(address _tokenAddress) external view returns (uint256);\r\n    function withdrawTokens(uint256 _id, uint256 _amount) external;\r\n\r\n    function getDepositDetails(uint256 _id)view external returns (\r\n        address _tokenAddress, \r\n        address _withdrawalAddress, \r\n        uint256 _tokenAmount, \r\n        uint256 _unlockTime, \r\n        bool _withdrawn, \r\n        uint256 _tokenId,\r\n        bool _isNFT,\r\n        uint256 _migratedLockDepositId,\r\n        bool _isNFTMinted);\r\n}\r\n\r\ninterface IPair {\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);    \r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n}\r\n\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        ); \r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n    \r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        decimals = 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {}\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {}\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract Zevoid is ERC20 {\r\n\r\n  struct Taxes { \r\n    uint256 lp_tax;\r\n    uint256 devMarketing_tax; \r\n    uint256 ETH_gasfee_tax; \r\n    uint256 team_tax; \r\n    uint256 total; \r\n    //ecosystem \r\n    uint256 early_sell_tax; \r\n    uint256 deadblock_tax; \r\n    uint256 blacklist_tax; \r\n  }\r\n  struct EarlyBuySellTracker {\r\n    uint256 buy_blockNumber;\r\n    uint256 sell_blockNumber;\r\n  }\r\n\r\n  mapping(address => EarlyBuySellTracker) first_actions_map;\r\n  uint256 ebst_treshold = 60*60*24; //24h\r\n  mapping(address => uint256) private team_members;\r\n  \r\n  struct Shares{\r\n    uint256 share_team;\r\n    uint256 share_developmentMarketing;\r\n    uint256 share_Fees;\r\n    uint256 share_LP;\r\n  }\r\n  Shares private shareObj;\r\n\r\n  address[] private team_member_list;  \r\n  address[] whitelist; \r\n  address[] blacklist; \r\n  address[] holders;\r\n\r\n  uint256 private end_blockNr = 0;\r\n  uint256 _unlockTime_in_UTC = 210 days; //7months\r\n  uint256 public unlockTime_in_UTC_local;\r\n  bool public trading_enabled = false;\r\n\r\n  uint256 public lp_eth_balance;\r\n  \r\n  Taxes public buy_taxes = Taxes({\r\n    lp_tax: 250, \r\n    devMarketing_tax: 240, \r\n    ETH_gasfee_tax: 10, \r\n    team_tax: 200, \r\n    total: (250 + 240 + 10 + 200),\r\n    //\r\n    early_sell_tax: 0, \r\n    deadblock_tax: 7300, \r\n    blacklist_tax: 7000 \r\n  });\r\n\r\n  Taxes public sell_taxes = Taxes({\r\n    lp_tax: 250,\r\n    devMarketing_tax: 240,\r\n    ETH_gasfee_tax: 10,\r\n    team_tax: 200,\r\n    total: (250 + 240 + 10 + 200),\r\n    //\r\n    early_sell_tax: 1200, \r\n    deadblock_tax: 700, \r\n    blacklist_tax: 7000\r\n  });\r\n\r\n\r\nuint256 totalTokenAmount = 7 * (10 ** 6) * (10 ** 18);\r\nuint256 initialSupply;\r\nuint256 BASISPOINT = 10000;\r\n\r\nuint256 public _maxWallet = (totalTokenAmount / 100); // 1%\r\nuint256 public _maxTx = (totalTokenAmount * 50) / BASISPOINT; //0.5%\r\n\r\nIRouter uniswapV2Router;\r\nIPair public uniswapV2Pair;\r\nItrustSwap externLocker;\r\nuint256[] locks_ids;\r\naddress public owner;\r\naddress public zeOracle_address;\r\naddress private developmentMarketing_address; \r\n\r\n\r\nconstructor(\r\n  address owner_0,\r\n  address router_v2_address, \r\n  address externLocker_address,\r\n  address developmentMarketing_address_,\r\n  address zeOracle_address_ \r\n  ) \r\n  ERC20(\"ZeVoid\", \"ZVOID\") \r\n  {\r\n    //owner: multisig  \r\n    owner = owner_0;\r\n    \r\n    initialSupply = ((totalTokenAmount * 80) / 100);\r\n    \r\n    _mint(address(this), initialSupply); //80%\r\n    _mint(owner, (totalTokenAmount - initialSupply)); //20% for CEX\r\n\r\n    zeOracle_address = zeOracle_address_;\r\n    developmentMarketing_address = developmentMarketing_address_;\r\n\r\n    uniswapV2Router = IRouter(router_v2_address); \r\n    address _pair = IFactory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n\r\n    uniswapV2Pair = IPair(_pair);\r\n    externLocker = ItrustSwap(externLocker_address);\r\n        \r\n    whitelist.push(address(this));\r\n    whitelist.push(owner);\r\n    whitelist.push(zeOracle_address);\r\n    //\r\n    whitelist.push(router_v2_address);\r\n    whitelist.push(_pair);\r\n    whitelist.push(externLocker_address);\r\n\r\n\r\n    //team members\r\n    //\r\n    team_member_list.push(0x13D47263B1B770AbD441AEAb67e5e00EDA11B1C5);    \r\n    team_members[0x13D47263B1B770AbD441AEAb67e5e00EDA11B1C5] = 2000; \r\n    //\r\n    team_member_list.push(0xA795a19fB3797466517FDC7804fdB9E87DAeDfd4);    \r\n    team_members[0xA795a19fB3797466517FDC7804fdB9E87DAeDfd4] = 2000; \r\n    //\r\n    team_member_list.push(0x11F184dFA987973933A5150531e5BeA2882b0687);    \r\n    team_members[0x11F184dFA987973933A5150531e5BeA2882b0687] = 2000; \r\n    //\r\n    team_member_list.push(0x9A22519df3fac8b3829f8F3150ae2D6C3A6b809D);    \r\n    team_members[0x9A22519df3fac8b3829f8F3150ae2D6C3A6b809D] = 2000; \r\n    //\r\n    team_member_list.push(0xDeE2DE3F2532791B5F58c5Ff0EE834586930cf99);    \r\n    team_members[0xDeE2DE3F2532791B5F58c5Ff0EE834586930cf99] = 2000; \r\n    //\r\n\r\n\r\n    //\r\n    shareObj = Shares({\r\n        share_team: 3000,\r\n        share_developmentMarketing: 3400,\r\n        share_Fees: 100,\r\n        share_LP: 3500\r\n    });\r\n}\r\n\r\n\r\n\r\nfunction plock(uint256 ethAmount) payable external onlyOwner {\r\n\r\n  if((msg.value <= externLocker.getFeesInETH(address(uniswapV2Pair))))revert('Not enough liql!');\r\n\r\n  (bool sent,) = payable(address(this)).call{value: ethAmount}(\"\");\r\n  if(sent == true){\r\n\r\n    if(initialSupply > 0 && ethAmount > 0){\r\n      addLiquidity(address(this), initialSupply, ethAmount);\r\n      lock_LP_Tokens();\r\n    }\r\n  }else{\r\n    revert('sending ETH in plock: fail');\r\n  }\r\n}\r\n\r\nmodifier onlyOwner(){\r\n  require(owner == msg.sender, 'Only Owner!');\r\n  _;\r\n}\r\n\r\nmodifier onlyOwnerZeOracle(){\r\n  require(zeOracle_address == msg.sender || owner == msg.sender, 'Only owner or zeOracle!');\r\n  _;\r\n}\r\n\r\nmodifier tradingAutoDisabled(){\r\n  bool before_trading_enabled = trading_enabled; \r\n  trading_enabled = false;\r\n  _;\r\n  trading_enabled = before_trading_enabled;\r\n}\r\n\r\n\r\nfunction set_deadblock_tax(uint256 new_deadblock_buy_tax, uint256 new_deadblock_sell_tax) onlyOwner external{\r\n  buy_taxes.deadblock_tax = new_deadblock_buy_tax;\r\n  sell_taxes.deadblock_tax = new_deadblock_sell_tax;\r\n}\r\n\r\n\r\nfunction set_unlockTime_in_UTC(uint256 new_unlockTime_in_UTC) onlyOwner external{\r\n  _unlockTime_in_UTC = new_unlockTime_in_UTC;\r\n}\r\n\r\nfunction set_early_sell_tax(uint256 new_early_sell_tax) onlyOwner external{\r\n  sell_taxes.early_sell_tax = new_early_sell_tax;\r\n}\r\n\r\n\r\nfunction set_blacklist_tax(uint256 new_blacklist_buy_tax, uint256 new_blacklist_sell_tax) onlyOwner external{\r\n  buy_taxes.blacklist_tax = new_blacklist_buy_tax;\r\n  sell_taxes.blacklist_tax = new_blacklist_sell_tax;\r\n}\r\n\r\n\r\nfunction set_buy_taxes(\r\n  uint256 new_lp_tax, \r\n  uint256 new_devMarketing_tax,\r\n  uint256 new_ETH_gasfee_tax,\r\n  uint256 new_team_tax\r\n  ) onlyOwner external{\r\n  buy_taxes.lp_tax = new_lp_tax;\r\n  buy_taxes.devMarketing_tax = new_devMarketing_tax;\r\n  buy_taxes.ETH_gasfee_tax = new_ETH_gasfee_tax;\r\n  buy_taxes.team_tax = new_team_tax;\r\n  buy_taxes.total = buy_taxes.lp_tax + buy_taxes.devMarketing_tax + buy_taxes.ETH_gasfee_tax + buy_taxes.team_tax;\r\n}\r\n\r\n\r\nfunction set_sell_taxes(  \r\n  uint256 new_lp_tax, \r\n  uint256 new_devMarketing_tax,\r\n  uint256 new_ETH_gasfee_tax,\r\n  uint256 new_team_tax\r\n) onlyOwner external{\r\n  sell_taxes.lp_tax = new_lp_tax;\r\n  sell_taxes.devMarketing_tax = new_devMarketing_tax;\r\n  sell_taxes.ETH_gasfee_tax = new_ETH_gasfee_tax;\r\n  sell_taxes.team_tax = new_team_tax;\r\n  sell_taxes.total = sell_taxes.lp_tax + sell_taxes.devMarketing_tax + sell_taxes.ETH_gasfee_tax + sell_taxes.team_tax;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nfunction set_owner(address new_owner) onlyOwner external{\r\n  add_whitelist(new_owner);\r\n  owner = new_owner;\r\n}\r\n\r\nfunction set_zeOracle_address(address new_zeOracle_address) onlyOwner external{\r\n  zeOracle_address = new_zeOracle_address;\r\n}\r\n\r\n\r\nfunction set_maxTx_maxWallet(uint256 new_maxWallet_in_ZVOID, uint256 new__maxTx_in_ZVOID) onlyOwner external{  \r\n  _maxWallet = new_maxWallet_in_ZVOID; \r\n  _maxTx = new__maxTx_in_ZVOID; \r\n}\r\n\r\n\r\nfunction set_ebst_treshold(uint256 new_ebst_treshold) onlyOwner external{\r\n  ebst_treshold = new_ebst_treshold;\r\n}\r\n\r\nfunction set_trading_enabled(bool new_trading_enabled, uint256 nBlock) onlyOwner external{\r\n  trading_enabled = new_trading_enabled;\r\n  if(end_blockNr == 0) end_blockNr = (block.number + nBlock); \r\n}\r\n\r\nfunction is_team_member(address team_member) public view returns(bool, uint256) {\r\n    for(uint256 i=0; i < team_member_list.length; i++){\r\n        if(team_member_list[i] == team_member){\r\n            return (true, i);\r\n        }\r\n    }\r\n    return (false, 0);\r\n}\r\n\r\nfunction team_shares_correct() view private returns(bool) {\r\n    uint256 total_shares = 0;\r\n    for(uint256 i=0; i < team_member_list.length; i++){\r\n        total_shares += team_members[team_member_list[i]];\r\n    }\r\n    //\r\n    if((total_shares) <= BASISPOINT){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction add_team_member(address team_member, uint256 share_perc_in_BASISPOINT) onlyOwner external returns(bool) {\r\n    (bool is_tm,) = is_team_member(team_member);\r\n    if(is_tm == true)return false;\r\n    //\r\n    team_member_list.push(team_member);    \r\n    team_members[team_member] = share_perc_in_BASISPOINT; \r\n    //\r\n    if(team_shares_correct()==false)revert('Total share is greater than 100%.');\r\n    //\r\n    return true;\r\n}\r\n\r\nfunction delete_team_member(address team_member) onlyOwner external returns(bool){    \r\n    (bool is_tm, uint256 i) = is_team_member(team_member);\r\n    if(is_tm == true){\r\n        delete team_member_list[i];\r\n        delete team_members[team_member];\r\n        return true;\r\n    } \r\n  return false;\r\n}\r\n\r\nfunction get_team_member_list() public view returns(address[] memory) {\r\n    return team_member_list;\r\n}\r\n\r\nfunction set_team_member(address old_team_member, address new_team_member, uint256 share_perc_in_BASISPOINT) onlyOwner external returns(bool){\r\n    (bool is_tm, uint256 i) = is_team_member(old_team_member);\r\n    if(is_tm == true){\r\n        team_member_list[i] = new_team_member;\r\n        //\r\n        delete team_members[old_team_member];\r\n        team_members[new_team_member] = share_perc_in_BASISPOINT;\r\n        //\r\n        if(team_shares_correct()==false)revert('Total share is greater than 100%.');\r\n        //\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nfunction is_whitelisted(address user) public view returns(bool) {\r\n  for(uint256 i=0; i<whitelist.length; i++){\r\n    if(whitelist[i] == user)return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction is_blacklisted(address user) public view returns(bool) {\r\n  for(uint256 i=0; i<blacklist.length; i++){\r\n    if(blacklist[i] == user)return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\nfunction get_holders() public view returns(address[] memory){\r\n  return holders;\r\n}\r\n\r\n\r\nfunction add_or_remove_holder(address user) private returns(uint256) {\r\n  uint256 amount = balanceOf(user);\r\n  \r\n  for(uint256 i=0; i<holders.length; i++){\r\n    if(holders[i] == user && amount == 0 || holders[i] == address(0)){\r\n      delete holders[i];\r\n      return 2;\r\n    }\r\n  }\r\n  \r\n  if(user != address(0) && amount > 0){\r\n    holders.push(user); \r\n    return 1;\r\n  }\r\n  \r\n  return 0;\r\n}\r\n\r\n\r\nfunction add_whitelist(address user) onlyOwner public returns(address){\r\n  for(uint256 i=0; i < whitelist.length; i++){\r\n    if(whitelist[i] == user){\r\n      return user;\r\n    }\r\n  }\r\n  whitelist.push(user);\r\n  return user; \r\n}\r\n\r\nfunction remove_whitelist(address user) external onlyOwner returns(address){\r\n  for(uint256 i=0; i<whitelist.length; i++){\r\n    if(whitelist[i] == user){\r\n      delete whitelist[i];\r\n      return user;\r\n    }\r\n  }\r\n  return user;\r\n}\r\n\r\nfunction add_blacklist(address user) external onlyOwner returns(address){\r\n  for(uint256 i=0; i<blacklist.length; i++){\r\n    if(blacklist[i] == user){\r\n      return user;\r\n    }\r\n  }\r\n  blacklist.push(user);\r\n  return user;  \r\n}\r\n\r\nfunction remove_blacklist(address user) external onlyOwner returns(address){\r\n  for(uint256 i=0; i<blacklist.length; i++){\r\n    if(blacklist[i] == user){\r\n      delete blacklist[i];\r\n      return user;\r\n    }\r\n  }\r\n  return user;\r\n}\r\n\r\n\r\n  function transferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 amount\r\n  ) public virtual override returns (bool) {    \r\n    require( \r\n      (is_whitelisted(from) && is_whitelisted(to)) || \r\n      trading_enabled == true,\r\n      'Paused!'\r\n    );\r\n\r\n    address spender = _msgSender(); \r\n    uint256 tax = 0;\r\n    \r\n    if(to == address(uniswapV2Pair) && from != address(uniswapV2Router)){\r\n      tax = taxnomics_sell(from); \r\n    }\r\n    \r\n    _spendAllowance(from, spender, amount);\r\n\r\n    if(tax > 0){\r\n      uint256 tax_amount = (amount * tax) / BASISPOINT; \r\n      amount -= tax_amount;\r\n      if(tax_amount > 0)_transfer(from, address(this), tax_amount);\r\n    }\r\n    //\r\n    _transfer(from, to, amount);\r\n    \r\n    //\r\n    add_or_remove_holder(to);\r\n    add_or_remove_holder(from);\r\n    //\r\n\r\n    if(to == address(uniswapV2Pair) && from != address(uniswapV2Router)){\r\n      if(amount > _maxTx && is_whitelisted(from)==false)revert('_maxWallet or _maxTx reached!');\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n\r\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {  \r\n    address owner_ = _msgSender();\r\n    require( \r\n      (is_whitelisted(owner_) && is_whitelisted(to)) || \r\n      trading_enabled == true,\r\n      'Paused!'\r\n    );\r\n    \r\n    uint256 tax = 0;\r\n    //\r\n    if(owner_ == address(uniswapV2Pair) && to != address(uniswapV2Router)){\r\n      first_actions_map[to] = EarlyBuySellTracker({buy_blockNumber: block.timestamp, sell_blockNumber: (block.timestamp + ebst_treshold)});\r\n      tax = taxnomics_buy(to);\r\n    }\r\n    //\r\n    if(tax > 0){\r\n      uint256 tax_amount = (amount * tax) / BASISPOINT; \r\n      amount -= tax_amount;\r\n      if(tax_amount > 0)_transfer(owner_, address(this), tax_amount);\r\n    }\r\n    //\r\n    _transfer(owner_, to, amount);\r\n    //\r\n    add_or_remove_holder(to);\r\n    add_or_remove_holder(owner_);\r\n    //\r\n\r\n    if(owner_ == address(uniswapV2Pair) && to != address(uniswapV2Router)){\r\n      if(maxTx_maxWallet_reached(to, amount)==true)revert('_maxWallet or _maxTx reached!');\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n\r\n  function maxTx_maxWallet_reached(address user, uint256 amount) private view returns(bool){    \r\n    if((balanceOf(user) > _maxWallet && is_whitelisted(user)==false) || \r\n    (amount > _maxTx && is_whitelisted(user)==false)) return true;\r\n    return false;\r\n  }\r\n\r\n  \r\n  function taxnomics_buy(address wallet) private view returns(uint256) {    \r\n    uint256 tax = buy_taxes.total; \r\n\r\n    if(is_whitelisted(wallet)){\r\n      tax = 0;\r\n\r\n    }else if(is_blacklisted(wallet)){   \r\n      tax = buy_taxes.blacklist_tax;\r\n\r\n    }\r\n    else if(block.number > 0 && end_blockNr > 0 && block.number <= end_blockNr){\r\n      tax = buy_taxes.deadblock_tax;\r\n    }\r\n\r\n    return tax;\r\n  }\r\n\r\n\r\n\r\n  function taxnomics_sell(address wallet) private view returns(uint256) {    \r\n    uint256 tax = sell_taxes.total; \r\n    \r\n    if(is_whitelisted(wallet)){\r\n      tax = 0;\r\n\r\n    }else if(is_blacklisted(wallet)){   \r\n      tax = sell_taxes.blacklist_tax;\r\n\r\n    }else if(block.number > 0 && end_blockNr > 0 && block.number <= end_blockNr){\r\n      tax = sell_taxes.deadblock_tax;\r\n      \r\n    }else if(\r\n      block.timestamp >= first_actions_map[wallet].buy_blockNumber &&\r\n      block.timestamp <= first_actions_map[wallet].sell_blockNumber){\r\n      tax = sell_taxes.early_sell_tax;\r\n    }\r\n\r\n    return tax;\r\n  }\r\n\r\n\r\n  function addLiquidity(address to, uint256 tokenAmount, uint256 ethAmount) private returns(uint256) {\r\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n    (\r\n      ,\r\n      ,\r\n      uint256 liquidity\r\n    ) = uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n        address(this), \r\n        tokenAmount, \r\n        0,\r\n        0, \r\n        to, \r\n        block.timestamp + 360 \r\n    );\r\n    return liquidity;\r\n  }\r\n\r\n\r\n  function swapTokensForETH(address to, uint256 tokenAmount) private {\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = uniswapV2Router.WETH();\r\n\r\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      tokenAmount, \r\n      0, \r\n      path, \r\n      to,\r\n      block.timestamp + 360\r\n    );\r\n  }\r\n\r\n\r\n  function release_all(uint256 chart_friendly_release_token_amount) external onlyOwnerZeOracle {\r\n    if((chart_friendly_release_token_amount == 0) && (balanceOf(address(this)) < chart_friendly_release_token_amount))revert('release_all() error');\r\n\r\n    address msgSender = address(this);\r\n    uint256 bal_before = msgSender.balance;\r\n    swapTokensForETH(msgSender, chart_friendly_release_token_amount);\r\n    uint256 ethBalance = msgSender.balance - bal_before;\r\n    \r\n    if(msgSender.balance < bal_before)revert('send ethBalance: fail');\r\n    //\r\n    release_team_tax(ethBalance);\r\n    //\r\n    release_ETH(zeOracle_address, ethBalance, shareObj.share_Fees);\r\n\r\n    release_ETH(developmentMarketing_address, ethBalance, shareObj.share_developmentMarketing);\r\n    //  \r\n    // //LP balance \r\n    lp_eth_balance += (ethBalance * shareObj.share_LP) / BASISPOINT;\r\n  }\r\n\r\n\r\n  function release_team_tax(uint256 ethBalance) private tradingAutoDisabled{\r\n\r\n    uint256 amount = (ethBalance * shareObj.share_team) / BASISPOINT;\r\n    \r\n    for(uint256 i=0; i < team_member_list.length; i++){\r\n      address to = team_member_list[i];\r\n      uint256 ethAmount = (amount * team_members[to]) / (BASISPOINT);\r\n      if(ethAmount > 0){\r\n        (bool sent,) = payable(to).call{value: ethAmount}(\"\");\r\n        if(sent == false)revert('send ether: fail');\r\n      }\r\n      ethAmount = 0;\r\n    }\r\n  }\r\n\r\n\r\n  function release_ETH(address to, uint256 ethBalance, uint256 shares) \r\n  private tradingAutoDisabled returns(bool) {\r\n    uint256 ethAmount = (ethBalance * shares) / BASISPOINT;\r\n\r\n    if(ethAmount > 0){\r\n      (bool sent,) = payable(to).call{value: ethAmount}(\"\");\r\n      if(sent == false)revert('send ethAmount: fail');\r\n      ethAmount = 0;\r\n      return true;\r\n    }else{\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\nfunction pool(uint256 pool_ethAmount) external onlyOwnerZeOracle tradingAutoDisabled{\r\n\r\n  if(lp_eth_balance == 0 || pool_ethAmount == 0)revert('cannot send 0!');\r\n  \r\n  address msgSender = msg.sender;\r\n  uint256 ethAmount = pool_ethAmount / 2;\r\n  uint256 tokenAmount_before = balanceOf(msgSender);\r\n  //\r\n  address[] memory path = new address[](2);\r\n  path[0] = uniswapV2Router.WETH();\r\n  path[1] = address(this);\r\n  \r\n  uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n      value: ethAmount\r\n    }(\r\n    0,\r\n    path,\r\n    msgSender,\r\n    block.timestamp + (300)\r\n  );\r\n  \r\n  uint256 tokenAmount_after = balanceOf(msgSender) - tokenAmount_before;\r\n  uint256 b_balance = balanceOf(address(this));\r\n  _transfer(msgSender, address(this), tokenAmount_after);\r\n  uint256 a_balance = balanceOf(address(this)) - b_balance;\r\n\r\n  if(a_balance != tokenAmount_after)revert('Error: while pooling');\r\n  \r\n  addLiquidity(address(this), tokenAmount_after, ethAmount);\r\n  lp_eth_balance -= pool_ethAmount;\r\n}\r\n\r\n\r\nfunction get_lock_ids() public view returns(uint256[] memory) {\r\n  return locks_ids;\r\n} \r\n\r\n\r\nfunction lock_LP_Tokens() private {\r\n  uint256 _amount = uniswapV2Pair.balanceOf(address(this));\r\n  bool allowanceAmount = uniswapV2Pair.approve(address(externLocker), _amount); \r\n\r\n  if(allowanceAmount == true){\r\n    uint256 ethAmount = externLocker.getFeesInETH(address(uniswapV2Pair));  \r\n    \r\n    uint256 endTime = _unlockTime_in_UTC + block.timestamp;\r\n    unlockTime_in_UTC_local = endTime;\r\n    uint256 externLocker_id = externLocker.lockToken{value: ethAmount}(address(uniswapV2Pair), address(this), _amount, endTime, false);\r\n\r\n    locks_ids.push(externLocker_id); \r\n\r\n  }else{\r\n    revert('approve in lock_LP_Tokens: fail');\r\n  }\r\n}\r\n\r\n\r\nfunction extendLockDuration() external onlyOwnerZeOracle{\r\n  for(uint256 i=0; i<locks_ids.length; i++){\r\n    uint256 endTime = _unlockTime_in_UTC + block.timestamp;\r\n    unlockTime_in_UTC_local = endTime;\r\n    externLocker.extendLockDuration(locks_ids[i], endTime);\r\n  }\r\n}\r\n\r\n\r\nfunction get_lp_tokens() public onlyOwner {\r\n  if(block.timestamp < unlockTime_in_UTC_local)revert('lp tokens locked.');\r\n  //\r\n  for(uint256 i=0; i<locks_ids.length; i++){\r\n    (, , uint256 _tokenAmount, , , , , , ) = externLocker.getDepositDetails(locks_ids[i]);\r\n    externLocker.withdrawTokens(locks_ids[i], _tokenAmount);\r\n  }\r\n  //\r\n  uint256 lpTokens = uniswapV2Pair.balanceOf(address(this));\r\n  if(lpTokens > 0)uniswapV2Pair.transfer(owner, lpTokens);\r\n}\r\n \r\n\r\nfunction get_contractsETH(address newContract) public onlyOwner returns(bool){  \r\n  uint256 ethAmount2 = address(this).balance;\r\n  if(ethAmount2 > 0){\r\n    (bool sent,) = payable(newContract).call{value: ethAmount2}(\"\");\r\n    return sent;\r\n  }\r\n  return false;\r\n}\r\n \r\n\r\nfunction ETH_migration(address newContract) external onlyOwner returns(bool) {\r\n  // \r\n  get_lp_tokens(); \r\n  //\r\n  uint256 lpTokens = uniswapV2Pair.balanceOf(address(this));\r\n  bool approved = uniswapV2Pair.approve(address(uniswapV2Router), lpTokens);\r\n  bool res = false;\r\n  //\r\n  if(lpTokens > 0 && approved==true){\r\n    uint256 ethAmount1 = uniswapV2Router.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n      address(uniswapV2Pair),\r\n      lpTokens,\r\n      0,\r\n      0,\r\n      newContract,\r\n      (block.timestamp + 360)\r\n    );\r\n    if(ethAmount1 > 0) res = true;\r\n  }\r\n  //\r\n  if(get_contractsETH(newContract) ==true) res=true;\r\n  return res;\r\n}\r\n\r\n  \r\n  receive() external payable {}\r\n  fallback() external payable{\r\n    revert('fallback()');\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_v2_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"externLocker_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"developmentMarketing_address_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zeOracle_address_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ETH_migration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"add_blacklist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"team_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share_perc_in_BASISPOINT\",\"type\":\"uint256\"}],\"name\":\"add_team_member\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"add_whitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_taxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMarketing_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ETH_gasfee_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"team_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"early_sell_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadblock_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blacklist_tax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"team_member\",\"type\":\"address\"}],\"name\":\"delete_team_member\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extendLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"get_contractsETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_holders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_lock_ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_lp_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_team_member_list\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"is_blacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"team_member\",\"type\":\"address\"}],\"name\":\"is_team_member\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"is_whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lp_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"plock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pool_ethAmount\",\"type\":\"uint256\"}],\"name\":\"pool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chart_friendly_release_token_amount\",\"type\":\"uint256\"}],\"name\":\"release_all\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"remove_blacklist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"remove_whitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_taxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lp_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devMarketing_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ETH_gasfee_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"team_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"early_sell_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadblock_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blacklist_tax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_blacklist_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_blacklist_sell_tax\",\"type\":\"uint256\"}],\"name\":\"set_blacklist_tax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_lp_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_devMarketing_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_ETH_gasfee_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_team_tax\",\"type\":\"uint256\"}],\"name\":\"set_buy_taxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_deadblock_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_deadblock_sell_tax\",\"type\":\"uint256\"}],\"name\":\"set_deadblock_tax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_early_sell_tax\",\"type\":\"uint256\"}],\"name\":\"set_early_sell_tax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_ebst_treshold\",\"type\":\"uint256\"}],\"name\":\"set_ebst_treshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_maxWallet_in_ZVOID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new__maxTx_in_ZVOID\",\"type\":\"uint256\"}],\"name\":\"set_maxTx_maxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"set_owner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_lp_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_devMarketing_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_ETH_gasfee_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_team_tax\",\"type\":\"uint256\"}],\"name\":\"set_sell_taxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"old_team_member\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"new_team_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share_perc_in_BASISPOINT\",\"type\":\"uint256\"}],\"name\":\"set_team_member\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"new_trading_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nBlock\",\"type\":\"uint256\"}],\"name\":\"set_trading_enabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_unlockTime_in_UTC\",\"type\":\"uint256\"}],\"name\":\"set_unlockTime_in_UTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_zeOracle_address\",\"type\":\"address\"}],\"name\":\"set_zeOracle_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trading_enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"contract IPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTime_in_UTC_local\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeOracle_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Zevoid", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000845b8c0db49fa0fc92f20d08a78ba2d78f92f8590000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000e2fe530c047f2d85298b07d9333c05737f1435fb0000000000000000000000000a4b5440e863f96324baf721a69c6f7ad59ba75100000000000000000000000072d20f97339cc22527fe89499c7347fac0ab5cd5", "EVMVersion": "byzantium", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34c0a8b3fb02e714fa3178e22080c81fbbc1c795ba109e81ea2e0018eddfe0be"}]}