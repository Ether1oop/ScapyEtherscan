{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory { function createPair(address tokenA, address tokenB) external returns (address pair); }\r\ninterface IUniswapV2Router02 {\r\n\tfunction getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\r\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n\tfunction factory() external pure returns (address);\r\n\tfunction addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\nabstract contract OWNED {\r\n\taddress internal _owner;\r\n\tevent OwnershipTransferred(address owner);\r\n\tconstructor(address contractOwner) { _owner = contractOwner; }\r\n\tmodifier onlyOwner() { require(msg.sender == _owner, \"Not the owner\"); _; }\r\n\t// function owner() external view returns (address) { return _owner; }  // moved into addressList() function\r\n\tfunction renounceOwnership() external onlyOwner { _transferOwnership(address(0)); }\r\n\tfunction transferOwnership(address newOwner) external onlyOwner { _transferOwnership(newOwner); }\r\n\tfunction _transferOwnership(address _newOwner) internal {\r\n\t\t_owner = _newOwner; \r\n\t\temit OwnershipTransferred(_newOwner); \r\n\t}\r\n}\r\n\r\ncontract BLOOD is IERC20, OWNED {\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\tuint8 private constant _decimals = 9;\r\n\tuint256 private constant _totalSupply = 100_000_000 * 10**_decimals;\r\n\tstring private constant _name = \"Blood Bank\";\r\n\tstring private constant _symbol = \"BLOOD\";\r\n\r\n\tuint256 private _maxTx; \r\n\tuint256 private _maxWallet;\r\n\r\n\tuint256 private _swapThreshold = _totalSupply;\r\n\tuint256 private _swapLimit = _totalSupply;\r\n\r\n\tuint8 private _taxRateBuy;\r\n\tuint8 private _taxRateSell;\r\n\r\n\tmapping(address => bool) private _excluded;\r\n\taddress private _treasuryWallet = address(0x35E6b861DbE175F64dEf1FAC5E2853e5613Eb764);\r\n\taddress private constant _usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n\t\r\n\taddress private constant _swapRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Uniswap V2 Router\r\n\tIUniswapV2Router02 private constant _swapRouter = IUniswapV2Router02(_swapRouterAddress);\r\n\taddress private _primaryLP;\r\n\tmapping(address => bool) private _isLP;\r\n\tbool private _initialLiquidityAdded;\r\n\t\r\n\tuint256 private _openAt;\r\n\tuint256 private _protected;\r\n\r\n\tbool private swapLocked;\r\n\tmodifier lockSwap { swapLocked = true; _; swapLocked = false; }\r\n\r\n\tconstructor() OWNED(msg.sender)  {\r\n\t\t_balances[address(msg.sender)] = _totalSupply;\r\n\t\temit Transfer(address(0), address(msg.sender), _balances[address(msg.sender)]);\r\n\r\n\t\t_changeLimits(3,6); //set max TX to 0.3%, max wallet 0.6%\r\n\r\n\t\t_excluded[_owner] = true;\r\n\t\t_excluded[address(this)] = true;\r\n\t\t_excluded[_swapRouterAddress] = true;\r\n\t\t_excluded[_treasuryWallet] = true;\r\n\r\n\t\t_primaryLP = IUniswapV2Factory(_swapRouter.factory()).createPair(address(this), _usdc);\r\n\t\t_isLP[_primaryLP] = true;\r\n\t}\r\n\r\n\tfunction addressList() external view returns (address owner, address treasury, address usdc, address swapRouter, address primaryLP) {\r\n\t\treturn (_owner, _treasuryWallet, _usdc, _swapRouterAddress, _primaryLP);\r\n\t}\r\n\r\n\tfunction totalSupply() external pure override returns (uint256) { return _totalSupply; }\r\n\tfunction decimals() external pure override returns (uint8) { return _decimals; }\r\n\tfunction symbol() external pure override returns (string memory) { return _symbol; }\r\n\tfunction name() external pure override returns (string memory) { return _name; }\r\n\tfunction balanceOf(address account) external view override returns (uint256) { return _balances[account]; }\r\n\tfunction allowance(address owner, address spender) external view override returns (uint256) { return _allowances[owner][spender]; }\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n\t\trequire(_balances[msg.sender] > 0,\"ERC20: Zero balance\");\r\n\t\t_approve(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction _approve(address owner, address spender, uint256 amount ) private {\r\n\t\trequire(owner != address(0) && spender != address(0), \"ERC20: Zero address\");\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\tfunction _checkAndApproveRouter(uint256 tokenAmount) private {\r\n\t\tif (_allowances[address(this)][_swapRouterAddress] < tokenAmount) { \r\n\t\t\t_approve(address(this), _swapRouterAddress, type(uint256).max);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _checkAndApproveRouterForToken(address _token, uint256 amount) internal {\r\n\t\tuint256 tokenAllowance;\r\n\t\tif (_token == address(this)) {\r\n\t\t\ttokenAllowance = _allowances[address(this)][_swapRouterAddress];\r\n\t\t\tif (amount > tokenAllowance) {\r\n\t\t\t\t_allowances[address(this)][_swapRouterAddress] = type(uint256).max;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttokenAllowance = IERC20(_token).allowance(address(this), _swapRouterAddress);\r\n\t\t\tif (amount > tokenAllowance) {\r\n\t\t\t\tIERC20(_token).approve(_swapRouterAddress, type(uint256).max);\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\r\n\t\t_transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction transferFrom(address from, address to, uint256 amount) public returns (bool) {\r\n\t\trequire(_allowances[from][msg.sender] >= amount,\"ERC20: amount exceeds allowance\");\r\n\t\t_allowances[from][msg.sender] -= amount;\r\n\t\t_transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction _transfer(address from, address to, uint256 amount) private {\r\n\t\trequire(from != address(0) && to != address(0), \"ERC20: Zero address\"); \r\n\t\trequire(_balances[from] >= amount, \"ERC20: amount exceeds balance\"); \r\n\t\trequire(_limitCheck(from, to, amount), \"Limits exceeded\");\r\n\t\trequire(block.timestamp>_openAt, \"Not enabled\");\r\n\r\n\t\tif (block.timestamp>=_openAt && block.timestamp<_protected && tx.gasprice>block.basefee) {\r\n\t\t\tuint256 _gpb = tx.gasprice - block.basefee;\r\n\t\t\tuint256 _gpm = 10 * (10**9);\r\n\t\t\trequire(_gpb<_gpm,\"Not enabled\");\r\n\t\t}\r\n\r\n\t\tif ( !swapLocked && !_excluded[from] && _isLP[to] ) { _processTaxTokens(); }\r\n\r\n\t\tuint256 taxTokens = _getTaxTokens(from, to, amount);\r\n\t\t_balances[from] -= amount;\r\n\t\t_balances[address(this)] += taxTokens;\r\n\t\t_balances[to] += (amount - taxTokens);\r\n\t\temit Transfer(from, to, amount);\r\n\t}\r\n\tfunction _limitCheck(address from, address to, uint256 amount) private view returns (bool) {\r\n\t\tbool txSize = true;\r\n\t\tif ( amount > _maxTx && !_excluded[from] && !_excluded[to] ) { txSize = false; }\r\n\t\tbool walletSize = true;\r\n\t\tuint256 newBalanceTo = _balances[to] + amount;\r\n\t\tif ( newBalanceTo > _maxWallet && !_excluded[from] && !_excluded[to] && !_isLP[to] ) { walletSize = false; } \r\n\t\treturn (txSize && walletSize);\r\n\t}\r\n\r\n\tfunction _getTaxTokens(address from, address to, uint256 amount) private view returns (uint256) {\r\n\t\tuint256 _taxTokensAmount;\r\n\t\tif ( (_isLP[from] && !_excluded[to]) ) { \r\n            if (block.timestamp > _openAt + 120) { _taxTokensAmount = amount * _taxRateBuy / 100; }\r\n            else if (block.timestamp > _openAt) { _taxTokensAmount = amount * 99 / 100; } //antisnipe 99% tax for 120 seconds after trading opens\r\n\t\t} else if (_isLP[to] && !_excluded[from]) { \r\n\t\t\t_taxTokensAmount = amount * _taxRateSell / 100; \r\n\t\t}\r\n\t\treturn _taxTokensAmount;\r\n\t}\r\n\r\n\r\n\tfunction addInitialLiquidity(uint256 val) external onlyOwner {\r\n\t\trequire(IERC20(_usdc).balanceOf(address(this))>0, \"No USDC\");\r\n\t\trequire(!_initialLiquidityAdded, \"Liquidity already added\");\r\n\t\t_addLiquidity(address(this), _balances[address(this)], IERC20(_usdc).balanceOf(address(this)), false);\r\n\t\t_initialLiquidityAdded = true;\r\n\r\n\t\t_swapThreshold = _totalSupply * 5 / 10000;\r\n\t\t_swapLimit = _totalSupply * 25 / 10000;\r\n\r\n\t\t_taxRateBuy = 10;\r\n\t\t_taxRateSell = 15; //anti-dump sell tax at launch\r\n\r\n\t\t_openAt = block.timestamp + (val * 7 / 10) + 1662;\r\n\t\t_protected = _openAt + 600;\r\n\t}\r\n\r\n\tfunction _addLiquidity(address _token, uint256 tokenAmount, uint256 usdcAmount, bool burnLpTokens) internal {\r\n\t\trequire(IERC20(_token).balanceOf(address(this)) >= tokenAmount, \"Not enough tokens\");\r\n\t\trequire(IERC20(_usdc).balanceOf(address(this)) >= usdcAmount, \"Not enough USDC\");\r\n\t\t_checkAndApproveRouterForToken(_token, tokenAmount);\r\n\t\t_checkAndApproveRouterForToken(_usdc, usdcAmount);\r\n\t\taddress lpRecipient = _owner;\r\n\t\tif (burnLpTokens) { lpRecipient = address(0); }\r\n\r\n\t\t_swapRouter.addLiquidity(_usdc, _token, usdcAmount, tokenAmount, 0, 0, lpRecipient, block.timestamp);\r\n\t}\r\n\r\n\tfunction setPreLaunch(uint256 t1, uint256 t2) external onlyOwner {\r\n\t\trequire(_openAt > block.timestamp, \"already live\");\r\n\t\t_openAt = block.timestamp + (t1 / t2) + 462;\r\n\t\t_protected = _openAt + 600;\r\n\t}\r\n\r\n\tfunction tax() external view returns (uint8 buyTax, uint8 sellTax) { return (_taxRateBuy, _taxRateSell); }\r\n\tfunction limits() external view returns (uint256 maxTransaction, uint256 maxWallet) { return (_maxTx, _maxWallet); }\r\n\tfunction isExcluded(address wallet) external view returns (bool) { return _excluded[wallet]; }\r\n\r\n\tfunction changeLimits(uint16 maxTxPermille, uint16 maxWalletPermille) external onlyOwner { _changeLimits(maxTxPermille, maxWalletPermille); }\r\n\tfunction _changeLimits(uint16 _maxTxPermille, uint16 _maxWalletPermille) private {\r\n\t\tuint256 newMaxTx = (_totalSupply * _maxTxPermille / 1000) + (10 * 10**_decimals); //add 10 tokens to avoid rounding issues\r\n\t\tuint256 newMaxWallet = (_totalSupply * _maxWalletPermille / 1000) + (10 * 10**_decimals); //add 10 tokens to avoid rounding issues\r\n\t\trequire(newMaxTx >= _maxTx && newMaxWallet >= _maxWallet, \"Cannot decrease limits\");\r\n\t\tif (newMaxTx > _totalSupply) { newMaxTx = _totalSupply; }\r\n\t\tif (newMaxWallet > _totalSupply) { newMaxWallet = _totalSupply; }\r\n\t\t_maxTx = newMaxTx;\r\n\t\t_maxWallet = newMaxWallet;\r\n\t}\r\n\r\n\tfunction changeTaxWallet(address walletTreasury) external onlyOwner {\r\n\t\trequire(!_isLP[walletTreasury] && walletTreasury != _swapRouterAddress && walletTreasury != address(this) && walletTreasury != address(0));\r\n\t\t_excluded[walletTreasury] = true;\r\n\t\t_treasuryWallet = walletTreasury;\r\n\t}\t\r\n\r\n\tfunction changeTaxRates(uint8 newTaxRateBuy, uint8 newTaxRateSell) external onlyOwner {\r\n\t\trequire( (newTaxRateBuy+newTaxRateSell) <= 20, \"Max roundtrip is 20%\" );\r\n\t\t_taxRateBuy = newTaxRateBuy;\r\n\t\t_taxRateSell = newTaxRateSell;\r\n\t}\r\n\t\r\n\tfunction _processTaxTokens() private lockSwap {\r\n\t\tuint256 tokensToSwap = _balances[address(this)];\r\n\t\tif (tokensToSwap >= _swapThreshold) {\r\n\t\t\tif (tokensToSwap > _swapLimit) { tokensToSwap = _swapLimit; }\r\n\t\t\tif (tokensToSwap >= 10**_decimals) {\r\n\t\t\t\t_swapTokens(address(this), _usdc, tokensToSwap, _treasuryWallet);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _swapTokens(address inputToken, address outputToken, uint256 inputAmount, address recipient) private {\t\t\r\n\t\t_checkAndApproveRouterForToken(inputToken, inputAmount);\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = inputToken;\r\n\t\tpath[1] = outputToken;\r\n\t\t_swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\t\t\tinputAmount,\r\n\t\t\t0,\r\n\t\t\tpath,\r\n\t\t\trecipient,\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t}\r\n\r\n\tfunction recoverTokens(address tokenCa) external onlyOwner {\r\n\t\trequire(tokenCa != address(this),\"Not allowed\");\r\n\t\tuint256 tokenBalance = IERC20(tokenCa).balanceOf(address(this));\r\n\t\tIERC20(tokenCa).transfer(msg.sender, tokenBalance);\r\n\t}\r\n\r\n\tfunction manualSwap() external onlyOwner { _processTaxTokens(); }\r\n\r\n\tfunction setExcluded(address wallet, bool exclude) external onlyOwner { \r\n\t\tstring memory notAllowedError = \"Not allowed\";\r\n\t\trequire(!_isLP[wallet], notAllowedError);\r\n\t\trequire(wallet != address(this), notAllowedError);\r\n\t\trequire(wallet != _swapRouterAddress, notAllowedError);\r\n\t \t_excluded[wallet] = exclude; \r\n\t}\r\n\r\n\tfunction changeSwapThresholds(uint32 minValue, uint32 minDivider, uint32 maxValue, uint32 maxDivider) external onlyOwner {\r\n\t\t_swapThreshold = _totalSupply * minValue / minDivider;\r\n\t\t_swapLimit = _totalSupply * maxValue / maxDivider;\r\n\t\trequire(_swapLimit > _swapThreshold);\r\n\t\trequire(_swapLimit <= _totalSupply * 5 / 1000); // limit must be less than 0.5% supply\r\n\t}\r\n\r\n\tfunction burn(uint256 amount) external {\r\n\t\trequire(_balances[msg.sender] >= amount, \"Low balance\");\r\n\t\t_balances[msg.sender] -= amount;\r\n\t\t_balances[address(0)] += amount;\r\n\t\temit Transfer(msg.sender, address(0), amount);\r\n\t}\r\n\tfunction setAdditionalLP(address lpAddress, bool isLiqPool) external onlyOwner {\r\n\t\tstring memory notAllowedError = \"Not allowed\";\r\n\t\trequire(!_excluded[lpAddress], notAllowedError);\r\n\t\trequire(lpAddress != _primaryLP, notAllowedError);\r\n\t\trequire(lpAddress != address(this), notAllowedError);\r\n\t\trequire(lpAddress != _swapRouterAddress, notAllowedError);\r\n\t\t_isLP[lpAddress] = isLiqPool;\r\n\t}\r\n\tfunction isLP(address ca) external view returns (bool) { return _isLP[ca]; }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"addInitialLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"primaryLP\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"maxTxPermille\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxWalletPermille\",\"type\":\"uint16\"}],\"name\":\"changeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"minValue\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minDivider\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxValue\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxDivider\",\"type\":\"uint32\"}],\"name\":\"changeSwapThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newTaxRateBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"newTaxRateSell\",\"type\":\"uint8\"}],\"name\":\"changeTaxRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletTreasury\",\"type\":\"address\"}],\"name\":\"changeTaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ca\",\"type\":\"address\"}],\"name\":\"isLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTransaction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenCa\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLiqPool\",\"type\":\"bool\"}],\"name\":\"setAdditionalLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"setExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t2\",\"type\":\"uint256\"}],\"name\":\"setPreLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BLOOD", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9a5794437b3b87ac9783196b83f215062cf882d851de51a9de2c8ce3ec3b1c1e"}]}